<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beginner - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
    <!-- Prism.js Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üéÆ Beginner's Guide to Game Math</h1>
        <p class="subtitle">Master the foundations - Vectors, operations, and basic game systems</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="beginner.html" class="nav-button active">Beginner</a>
            <a href="intermediate.html" class="nav-button">Intermediate ‚Üí</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#intro">Why Math Matters in Games</a></li>
                <li><a href="#vectors">Vectors: Position & Direction</a></li>
                <li><a href="#vector-operations">Essential Vector Operations</a></li>
                <li><a href="#trigonometry">Trigonometry for Game Developers</a></li>
                <li><a href="#easing">Easing Functions & Smooth Motion</a></li>
                <li><a href="#game-systems">Building Your First Game System</a></li>
                <li><a href="#matrices">Matrix Transformations</a></li>
            </ul>
        </div>

        <!-- INTRODUCTION -->
        <div id="intro" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üöÄ Why Math Matters in Games</h2>
            <p>When you play a game, math is happening everywhere - even if you don't see it!</p>

            <div class="example-box">
                <h4>üéØ Real Game Examples</h4>
                <ul>
                    <li><strong>Moving a character:</strong> Uses vectors to track position and direction</li>
                    <li><strong>Rotating a spaceship:</strong> Uses matrices or angles</li>
                    <li><strong>Checking if you hit an enemy:</strong> Uses vector distance calculations</li>
                    <li><strong>Creating particle effects:</strong> Uses physics and vectors</li>
                    <li><strong>Smooth camera following:</strong> Uses linear interpolation (lerp)</li>
                </ul>
            </div>

            <p>Don't worry if these terms sound scary! We'll break everything down into simple, visual examples. By the end, you'll understand exactly how games work "under the hood."</p>

            <div class="key-point">
                <strong>üí° Key Insight:</strong> Game development is just applied math. Once you understand the patterns, you can create anything you imagine!
            </div>
        </div>

        <!-- VECTORS -->
        <div id="vectors" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üìê Vectors: Your Position & Direction Tool</h2>

            <h3>What is a Vector?</h3>
            <p>Think of a vector as an arrow that points from one place to another. It has two important properties:</p>
            <ul>
                <li><strong>Direction:</strong> Which way it's pointing</li>
                <li><strong>Length (magnitude):</strong> How far it goes</li>
            </ul>

            <div class="concept-box">
                <h4>Real-World Analogy</h4>
                <p>Imagine you're telling a friend how to walk to a store. You could say:</p>
                <ul>
                    <li>"Walk 3 blocks east, then 2 blocks north"</li>
                    <li>Or in math: <strong>Vector = (3, 2)</strong></li>
                </ul>
                <p>The vector (3, 2) means: move 3 units in the X direction (horizontal) and 2 units in the Y direction (vertical).</p>
            </div>

            <h3>Interactive Demo: Understanding Vectors</h3>
            <div class="diagram">
                <canvas id="vectorBasics" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button id="btnSimpleVector">Show Simple Vector</button>
                <button id="btnPlayerVector">Player Movement Example</button>
                <button id="btnBulletVector">Bullet Direction Example</button>
            </div>
            <div id="vectorInfo" class="info-display"></div>

            <h3>Building a Vector Class - Step by Step</h3>

            <div class="step">
                <span class="step-number">1</span>
                <strong>First, let's store x and y:</strong>
            </div>

            <details>
                <summary>üìù Click to see: The Simplest Vector (Step 1)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Vector2D {
    constructor(x, y) {
        this.x = x;  // Horizontal position
        this.y = y;  // Vertical position
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using it in a game:</h4>
                    <pre><code class="language-javascript">// Create a player at position (100, 200)
let playerPosition = new Vector2D(100, 200);

// Create an enemy at position (300, 150)
let enemyPosition = new Vector2D(300, 150);</code></pre>
                </div>
            </details>

            <div class="step">
                <span class="step-number">2</span>
                <strong>Add vector addition (combining movements):</strong>
            </div>

            <details>
                <summary>üìù Click to see: Adding Movement (Step 2)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Vector2D {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    // Add another vector to this one
    add(other) {
        this.x += other.x;  // Move horizontally
        this.y += other.y;  // Move vertically
        return this;        // Allow chaining
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Moving the player:</h4>
                    <pre><code class="language-javascript">// Player starts at (100, 100)
let player = new Vector2D(100, 100);

// Player presses 'W' key - move up
let movement = new Vector2D(0, -5);  // Up is negative Y!
player.add(movement);

// Now player is at (100, 95) - moved up 5 pixels!</code></pre>
                </div>
            </details>

            <div class="step">
                <span class="step-number">3</span>
                <strong>Add distance calculation (for collision detection):</strong>
            </div>

            <details>
                <summary>üìù Click to see: Measuring Distance (Step 3)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">distance(other) {
    // Use Pythagorean theorem: ‚àö(dx¬≤ + dy¬≤)
    let dx = other.x - this.x;  // Horizontal distance
    let dy = other.y - this.y;  // Vertical distance
    return Math.sqrt(dx * dx + dy * dy);
}</code></pre>
                </div>

                <div class="key-point">
                    <strong>üí° Why distance matters:</strong> You check if a bullet hit an enemy by seeing if the distance between them is less than their combined radii!
                </div>

                <div class="example-box">
                    <h4>üéÆ Collision detection:</h4>
                    <pre><code class="language-javascript">let bullet = new Vector2D(150, 150);
let enemy = new Vector2D(155, 148);

let distance = bullet.distance(enemy);  // About 5.4 pixels

if (distance < 10) {  // Hit radius = 10 pixels
    console.log("üí• Hit!");
}</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Vector Playground</summary>
                <pre><code class="language-javascript">// ===================================
// VECTOR PLAYGROUND - Complete Implementation
// ===================================

// Moving object with position and velocity vectors
class MovingObject {
    constructor(x, y, vx, vy) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(vx, vy);
        this.radius = 10;
    }

    update() {
        // Move: position = position + velocity
        this.position.add(this.velocity);

        // Bounce off walls
        if (this.position.x < this.radius ||
            this.position.x > canvas.width - this.radius) {
            this.velocity.x *= -1;  // Reverse X direction
            this.position.x = clamp(this.position.x, this.radius,
                                    canvas.width - this.radius);
        }
        if (this.position.y < this.radius ||
            this.position.y > canvas.height - this.radius) {
            this.velocity.y *= -1;  // Reverse Y direction
            this.position.y = clamp(this.position.y, this.radius,
                                    canvas.height - this.radius);
        }
    }

    draw(ctx) {
        // Draw the object
        ctx.fillStyle = '#4fc3f7';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw velocity vector
        const end = new Vector2D(
            this.position.x + this.velocity.x * 5,
            this.position.y + this.velocity.y * 5
        );
        drawVector(ctx, this.position, end, '#ffa726', 2);
    }
}

const objects = [];
let isDragging = false;
let dragStart = null;

// Drag to create objects with custom velocity
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    dragStart = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
        currentX: e.clientX - rect.left,
        currentY: e.clientY - rect.top
    };
    isDragging = true;
});

canvas.addEventListener('mousemove', (e) => {
    if (isDragging && dragStart) {
        const rect = canvas.getBoundingClientRect();
        dragStart.currentX = e.clientX - rect.left;
        dragStart.currentY = e.clientY - rect.top;
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (isDragging && dragStart) {
        const rect = canvas.getBoundingClientRect();
        const endX = e.clientX - rect.left;
        const endY = e.clientY - rect.top;

        // Calculate velocity from drag direction
        const vx = (endX - dragStart.x) * 0.1;
        const vy = (endY - dragStart.y) * 0.1;

        objects.push(new MovingObject(dragStart.x, dragStart.y, vx, vy));
    }
    isDragging = false;
    dragStart = null;
});

// Add random object button
document.getElementById('btnAddObject').addEventListener('click', () => {
    const x = randomFloat(50, canvas.width - 50);
    const y = randomFloat(50, canvas.height - 50);
    const vx = randomFloat(-3, 3);
    const vy = randomFloat(-3, 3);
    objects.push(new MovingObject(x, y, vx, vy));
});

// Animation loop
function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);
    drawGrid(ctx, canvas.width, canvas.height);

    objects.forEach(obj => {
        obj.update();
        obj.draw(ctx);
    });

    // Draw drag preview line
    if (isDragging && dragStart) {
        ctx.strokeStyle = '#66bb6a';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(dragStart.x, dragStart.y);
        ctx.lineTo(dragStart.currentX, dragStart.currentY);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Play with Vectors!</h3>
            <div class="diagram">
                <canvas id="vectorPlayground" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddObject">Add Moving Object</button>
                <button id="btnClearObjects">Clear All</button>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Click and drag to create vectors. Objects will move along their vectors!</p>
        </div>

        <!-- VECTOR OPERATIONS -->
        <div id="vector-operations" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üîß Essential Vector Operations</h2>

            <h3>1. Normalize (Make Unit Length)</h3>
            <div class="concept-box">
                <p><strong>Problem:</strong> You want the player to always move at the same speed, regardless of direction.</p>
                <p><strong>Solution:</strong> Normalize the vector (make it length = 1), then multiply by desired speed.</p>
            </div>

            <details data-demo-id="normalize" data-deps="vector2d,clearCanvas,drawGrid,clamp">
                <summary>üìù Click to see: Normalization Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">normalize() {
    let length = this.length();
    if (length > 0) {
        this.x /= length;  // Divide by length
        this.y /= length;
    }
    return this;
}

length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Constant Speed Movement:</h4>
                    <pre><code class="language-javascript">// Get input direction (could be diagonal!)
let direction = new Vector2D(
    input.right - input.left,    // -1, 0, or 1
    input.down - input.up
);

// Normalize so diagonal isn't faster!
direction.normalize();

// Apply constant speed
let speed = 5;
direction.multiply(speed);

// Add to player position
player.add(direction);</code></pre>
                </div>
            </details>

            <div class="key-point">
                <strong>üí° Why this matters:</strong> Without normalization, moving diagonally would be 1.4x faster (because of Pythagorean theorem)! This is a common bug in games.
            </div>

            <h3>Interactive Demo: Normalization</h3>
            <div class="diagram">
                <canvas id="normalizeDemo" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button id="btnToggleNormalize">Toggle Normalization</button>
            </div>
            <div id="normalizeInfo" class="info-display">Use WASD keys to move. Watch the speed difference!</div>

            <h3>2. Dot Product (Understanding Angles)</h3>
            <div class="concept-box">
                <p><strong>What it tells you:</strong> How much two vectors point in the same direction.</p>
                <ul>
                    <li><strong>Positive:</strong> Vectors point roughly the same way</li>
                    <li><strong>Zero:</strong> Vectors are perpendicular (90 degrees)</li>
                    <li><strong>Negative:</strong> Vectors point opposite ways</li>
                </ul>
            </div>

            <details data-demo-id="dotProduct" data-deps="vector2d,clearCanvas,drawGrid,drawVector">
                <summary>üìù Click to see: Dot Product Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">dot(other) {
    return this.x * other.x + this.y * other.y;
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Check if Enemy is in Front:</h4>
                    <pre><code class="language-javascript">// Player is facing direction
let facingDir = new Vector2D(1, 0).normalize();

// Direction to enemy
let toEnemy = enemy.subtract(player).normalize();

// Check if in front
let dotProduct = facingDir.dot(toEnemy);

if (dotProduct > 0) {
    console.log("Enemy is in front!");
} else {
    console.log("Enemy is behind!");
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Dot Product</h3>
            <div class="diagram">
                <canvas id="dotProductDemo" width="800" height="400"></canvas>
            </div>
            <div id="dotInfo" class="info-display">Move your mouse to see the dot product change</div>

            <h3>3. Vector Subtraction (Finding Direction)</h3>
            <div class="concept-box">
                <p><strong>What it does:</strong> Gives you the direction from one point to another.</p>
                <p><strong>Formula:</strong> direction = target - current</p>
            </div>

            <details>
                <summary>üìù Click to see: Vector Subtraction Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">subtract(other) {
    return new Vector2D(
        this.x - other.x,
        this.y - other.y
    );
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Enemy Chasing Player</h4>
                    <pre><code class="language-javascript">// Get direction from enemy to player
const direction = player.position.subtract(enemy.position);

// Normalize and apply enemy speed
direction.normalize().multiply(enemySpeed);

// Move enemy toward player
enemy.position.add(direction);

// Now enemy moves toward player at constant speed!</code></pre>
                </div>
            </details>

            <h3>4. Cross Product (Which Side?)</h3>
            <div class="concept-box">
                <p><strong>What it tells you:</strong> In 2D, the cross product tells you if something is on the left or right side of a vector.</p>
                <ul>
                    <li><strong>Positive:</strong> Point is on the left side</li>
                    <li><strong>Zero:</strong> Point is on the line</li>
                    <li><strong>Negative:</strong> Point is on the right side</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Cross Product Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// 2D cross product returns a scalar (z-component of 3D cross product)
cross(other) {
    return this.x * other.y - this.y * other.x;
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Determine Turn Direction</h4>
                    <pre><code class="language-javascript">// Player is facing a direction
const forward = new Vector2D(1, 0);

// Direction to target
const toTarget = target.subtract(player.position).normalize();

// Which way to turn?
const crossProduct = forward.cross(toTarget);

if (crossProduct > 0) {
    console.log("Turn left!");
} else if (crossProduct < 0) {
    console.log("Turn right!");
} else {
    console.log("Go straight!");
}</code></pre>
                </div>

                <div class="key-point">
                    <strong>üí° Use case:</strong> AI pathfinding, determining if an object is "ahead" or "behind", steering behaviors!
                </div>
            </details>

            <h3>5. Vector Projection (Sliding Along Surfaces)</h3>
            <div class="concept-box">
                <p><strong>What it does:</strong> Projects one vector onto another, useful for sliding along walls or surfaces.</p>
                <p>Imagine shining a light perpendicular to a surface - the shadow of your vector is the projection!</p>
            </div>

            <details>
                <summary>üìù Click to see: Vector Projection Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Project this vector onto another vector
project(onto) {
    const dotProduct = this.dot(onto);
    const ontoLengthSq = onto.x * onto.x + onto.y * onto.y;

    if (ontoLengthSq === 0) return new Vector2D(0, 0);

    const scalar = dotProduct / ontoLengthSq;
    return new Vector2D(
        onto.x * scalar,
        onto.y * scalar
    );
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Sliding Along Walls</h4>
                    <pre><code class="language-javascript">// Player trying to move in a direction
const desiredMovement = new Vector2D(5, 3);

// Wall is horizontal (normal points up)
const wallNormal = new Vector2D(0, 1);

// Remove component of movement into wall
const intoWall = desiredMovement.project(wallNormal);
const alongWall = desiredMovement.subtract(intoWall);

// Move player along wall instead of into it
player.position.add(alongWall);

// Player now slides smoothly along walls!</code></pre>
                </div>

                <div class="key-point">
                    <strong>üí° Use case:</strong> Character controllers, smooth wall sliding, slope movement, physics collisions!
                </div>
            </details>

            <h3>6. Vector Reflection (Bouncing)</h3>
            <div class="concept-box">
                <p><strong>What it does:</strong> Reflects a vector across a surface, like a ball bouncing off a wall.</p>
                <p><strong>Physics Rule:</strong> Angle of incidence = Angle of reflection</p>
            </div>

            <details>
                <summary>üìù Click to see: Vector Reflection Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Reflect this vector across a surface (given surface normal)
reflect(normal) {
    // Formula: reflection = vector - 2 * (vector ¬∑ normal) * normal
    const dot = this.dot(normal);
    return new Vector2D(
        this.x - 2 * dot * normal.x,
        this.y - 2 * dot * normal.y
    );
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Ball Bouncing Off Walls</h4>
                    <pre><code class="language-javascript">// Ball's velocity
let velocity = new Vector2D(5, -3);

// Hit bottom wall (normal points up)
const wallNormal = new Vector2D(0, -1);

// Reflect velocity
velocity = velocity.reflect(wallNormal);

// Apply some energy loss (optional)
velocity.multiply(0.8);  // 80% of original speed

// Ball now bounces realistically!</code></pre>
                </div>

                <div class="key-point">
                    <strong>üí° Use case:</strong> Bouncing balls, bullets ricocheting, pong paddles, breakout bricks!
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Advanced Vector Operations</summary>
                <pre><code class="language-javascript">// ===================================
// ADVANCED VECTOR OPERATIONS - Complete Implementation
// ===================================

let currentDemo = 'chase';
let player = new Vector2D(400, 250);
let enemy = new Vector2D(100, 100);
let ball = new Vector2D(200, 200);
let ballVelocity = new Vector2D(5, 3);

// Track mouse as player position
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    player = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
});

// Switch demo modes
document.getElementById('btnChaseDemo').addEventListener('click', () => {
    currentDemo = 'chase';
    enemy = new Vector2D(100, 100);
});

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    if (currentDemo === 'chase') {
        // CHASE: Enemy follows player using vector subtraction
        const direction = player.subtract(enemy);
        const distance = direction.length();

        if (distance > 30) {
            // Move toward player at constant speed
            const movement = direction.copy().normalize().multiply(2);
            enemy.add(movement);
        }

        // Draw enemy and direction vector
        ctx.fillStyle = '#ef5350';
        ctx.arc(enemy.x, enemy.y, 20, 0, Math.PI * 2);
        ctx.fill();
        drawVector(ctx, enemy, player, '#ffa726', 2);
    }
    else if (currentDemo === 'cross') {
        // CROSS PRODUCT: Determine turn direction
        const forward = new Vector2D(100, 0);
        const toTarget = mousePos.subtract(center).normalize();
        const cross = forward.cross(toTarget);

        // cross > 0 = turn left, cross < 0 = turn right
        const turnText = cross > 0 ? 'TURN LEFT' : 'TURN RIGHT';
    }
    else if (currentDemo === 'project') {
        // PROJECTION: Wall sliding
        const wallDir = wallEnd.subtract(wallStart).normalize();
        const wallNormal = new Vector2D(-wallDir.y, wallDir.x);

        const movement = mousePos.subtract(playerPos);

        // Remove the wall-collision component
        const intoWall = movement.project(wallNormal);
        const alongWall = movement.subtract(intoWall);
        // alongWall is the actual movement (slides along wall)
    }
    else if (currentDemo === 'reflect') {
        // REFLECTION: Bouncing ball
        ball.add(ballVelocity);

        // Check wall collisions and reflect
        if (ball.x - 15 < 0) {
            ball.x = 15;
            const normal = new Vector2D(1, 0);  // Wall normal
            // Reflect: v' = v - 2(v¬∑n)n
            ballVelocity = ballVelocity.reflect(normal).multiply(0.95);
        }
        if (ball.x + 15 > canvas.width) {
            ball.x = canvas.width - 15;
            const normal = new Vector2D(-1, 0);
            ballVelocity = ballVelocity.reflect(normal).multiply(0.95);
        }
        // Similar for top/bottom walls...

        // Draw ball and velocity vector
        ctx.fillStyle = '#4fc3f7';
        ctx.arc(ball.x, ball.y, 15, 0, Math.PI * 2);
        ctx.fill();
        drawVector(ctx, ball, ball.add(ballVelocity.multiply(10)), '#ffa726');
    }

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Advanced Vector Operations</h3>
            <div class="diagram">
                <canvas id="advancedVectorDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnChaseDemo">Enemy Chase Player</button>
                <button id="btnCrossDemo">Cross Product (Turning)</button>
                <button id="btnProjectDemo">Wall Sliding</button>
                <button id="btnReflectDemo">Bouncing Ball</button>
            </div>
            <div id="advVectorInfo" class="info-display">Click buttons to see different vector operations in action!</div>

            <h3>Complete Vector Class</h3>
            <details>
                <summary>üìù Click to see: Full Vector2D Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Vector2D {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    // Basic operations
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }

    subtract(v) {
        return new Vector2D(this.x - v.x, this.y - v.y);
    }

    multiply(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }

    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.y /= scalar;
        }
        return this;
    }

    // Length and normalization
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    lengthSquared() {
        return this.x * this.x + this.y * this.y;
    }

    normalize() {
        const len = this.length();
        if (len > 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }

    // Distance
    distance(v) {
        const dx = v.x - this.x;
        const dy = v.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Dot product
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }

    // Cross product (2D returns scalar)
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }

    // Project this vector onto another
    project(v) {
        const dot = this.dot(v);
        const lenSq = v.lengthSquared();
        if (lenSq === 0) return new Vector2D(0, 0);
        const scalar = dot / lenSq;
        return new Vector2D(v.x * scalar, v.y * scalar);
    }

    // Reflect across a normal
    reflect(normal) {
        const dot = this.dot(normal);
        return new Vector2D(
            this.x - 2 * dot * normal.x,
            this.y - 2 * dot * normal.y
        );
    }

    // Angle of this vector
    angle() {
        return Math.atan2(this.y, this.x);
    }

    // Rotate by an angle
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const newX = this.x * cos - this.y * sin;
        const newY = this.x * sin + this.y * cos;
        this.x = newX;
        this.y = newY;
        return this;
    }

    // Copy
    copy() {
        return new Vector2D(this.x, this.y);
    }

    // Static methods
    static fromAngle(angle, length = 1) {
        return new Vector2D(
            Math.cos(angle) * length,
            Math.sin(angle) * length
        );
    }
}</code></pre>
                </div>
            </details>
        </div>

        <!-- TRIGONOMETRY -->
        <div id="trigonometry" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üìê Trigonometry for Game Developers</h2>

            <div class="concept-box">
                <h4>Why Trigonometry?</h4>
                <p>Trigonometry helps you work with angles and circular motion. It's essential for:</p>
                <ul>
                    <li>Rotating objects around points</li>
                    <li>Making objects face their movement direction</li>
                    <li>Creating circular or orbital motion</li>
                    <li>Converting between angles and directions</li>
                </ul>
            </div>

            <h3>The Unit Circle: Your Best Friend</h3>
            <div class="concept-box">
                <p>Imagine a circle with radius = 1. As you go around this circle:</p>
                <ul>
                    <li><strong>cos(angle)</strong> gives you the <strong>X position</strong></li>
                    <li><strong>sin(angle)</strong> gives you the <strong>Y position</strong></li>
                </ul>
                <p>This is the foundation of rotation in games!</p>
            </div>

            <details data-demo-id="trig" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Trigonometry Functions Explained</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Convert angle to direction vector
function angleToVector(angle) {
    return new Vector2D(
        Math.cos(angle),  // X component
        Math.sin(angle)   // Y component
    );
}

// Convert direction vector to angle
function vectorToAngle(vector) {
    return Math.atan2(vector.y, vector.x);
}

// Rotate a point around another point
function rotateAround(point, center, angle) {
    // Translate to origin
    const x = point.x - center.x;
    const y = point.y - center.y;

    // Rotate
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const newX = x * cos - y * sin;
    const newY = x * sin + y * cos;

    // Translate back
    return new Vector2D(
        newX + center.x,
        newY + center.y
    );
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Make Enemy Face Player</h4>
                    <pre><code class="language-javascript">// Calculate direction from enemy to player
const direction = player.position.subtract(enemy.position);

// Get angle to player
enemy.rotation = Math.atan2(direction.y, direction.x);

// Now enemy is rotated to face player!
// Use this angle when drawing the enemy sprite</code></pre>
                </div>
            </details>

            <h3>Common Trig Patterns in Games</h3>

            <details>
                <summary>üìù Pattern 1: Circular Motion</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class OrbitingObject {
    constructor(centerX, centerY, radius) {
        this.center = new Vector2D(centerX, centerY);
        this.radius = radius;
        this.angle = 0;
        this.speed = 0.02;  // Radians per frame
    }

    update() {
        // Increment angle
        this.angle += this.speed;

        // Calculate position on circle
        this.position = new Vector2D(
            this.center.x + Math.cos(this.angle) * this.radius,
            this.center.y + Math.sin(this.angle) * this.radius
        );
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Satellites orbiting a planet, shields rotating around a player, or planets in a solar system!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 2: Wave Motion (Bobbing/Floating)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class FloatingItem {
    constructor(x, y) {
        this.baseY = y;  // Starting height
        this.position = new Vector2D(x, y);
        this.time = 0;
        this.amplitude = 10;  // How high it bobs
        this.frequency = 2;   // How fast it bobs
    }

    update() {
        this.time += 0.05;

        // Sine wave for smooth up/down motion
        const offset = Math.sin(this.time * this.frequency) * this.amplitude;
        this.position.y = this.baseY + offset;
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Collectible items floating up and down, boats on water, or breathing animations!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 3: Projectile Arc (Parabolic Motion)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">function shootProjectile(startPos, targetPos, launchAngle = 45) {
    const angle = launchAngle * Math.PI / 180;  // Convert to radians
    const distance = startPos.distance(targetPos);

    // Calculate initial velocity needed
    const gravity = 9.8;
    const velocity = Math.sqrt(
        (distance * gravity) / Math.sin(2 * angle)
    );

    // Velocity components
    const vx = velocity * Math.cos(angle);
    const vy = velocity * Math.sin(angle);

    return { vx, vy };
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Throwing grenades, arrow trajectories, or basketball shots!
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Trigonometry Demos</summary>
                <pre><code class="language-javascript">// ===================================
// TRIGONOMETRY DEMOS - Complete Implementation
// ===================================

let mode = 'orbit';
let time = 0;
let mousePos = new Vector2D(400, 250);

// Track mouse position
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mousePos.x = e.clientX - rect.left;
    mousePos.y = e.clientY - rect.top;
});

// Orbiting objects configuration
const orbitObjects = [
    { angle: 0, radius: 80, speed: 0.02, color: '#4fc3f7' },
    { angle: Math.PI, radius: 80, speed: 0.02, color: '#66bb6a' },
    { angle: Math.PI / 2, radius: 120, speed: 0.015, color: '#ffa726' }
];

// Wave objects configuration
const waveObjects = [];
for (let i = 0; i < 10; i++) {
    waveObjects.push({
        x: 100 + i * 60,
        baseY: 250,
        amplitude: 40,
        frequency: 2,
        phase: i * 0.5  // Offset creates wave effect
    });
}

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);
    time += 0.05;
    const center = new Vector2D(400, 250);

    if (mode === 'orbit') {
        // CIRCULAR ORBIT: cos/sin for X/Y
        orbitObjects.forEach(obj => {
            obj.angle += obj.speed;

            // Key formula: position on circle
            const x = center.x + Math.cos(obj.angle) * obj.radius;
            const y = center.y + Math.sin(obj.angle) * obj.radius;

            // Draw orbit path and object
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.arc(center.x, center.y, obj.radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = obj.color;
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    else if (mode === 'wave') {
        // WAVE MOTION: sin for oscillation
        waveObjects.forEach(obj => {
            // Key formula: oscillating offset
            const offset = Math.sin((time + obj.phase) * obj.frequency) * obj.amplitude;
            const y = obj.baseY + offset;

            ctx.fillStyle = '#4fc3f7';
            ctx.arc(obj.x, y, 12, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    else if (mode === 'face') {
        // FACE TARGET: atan2 for angle to target
        const objPos = new Vector2D(400, 250);
        const direction = mousePos.subtract(objPos);

        // Key formula: angle from direction vector
        const angle = Math.atan2(direction.y, direction.x);

        // Draw rotated triangle
        ctx.save();
        ctx.translate(objPos.x, objPos.y);
        ctx.rotate(angle);
        ctx.fillStyle = '#66bb6a';
        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(-10, -10);
        ctx.lineTo(-10, 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    else if (mode === 'arc') {
        // PROJECTILE ARC: parametric parabola
        const startX = 100;
        const startY = 400;
        const launchAngle = -Math.PI / 4;  // 45 degrees up
        const velocity = 8;
        const gravity = 0.3;

        // Draw trajectory points
        for (let t = 0; t < 100; t++) {
            // Key formulas: x moves linearly, y has gravity
            const x = startX + Math.cos(launchAngle) * velocity * t;
            const y = startY + Math.sin(launchAngle) * velocity * t + 0.5 * gravity * t * t;

            if (y > canvas.height) break;

            ctx.fillStyle = `rgba(79, 195, 247, ${1 - t/100})`;
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Trigonometry in Action</h3>
            <div class="diagram">
                <canvas id="trigDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnOrbit">Circular Orbit</button>
                <button id="btnWave">Wave Motion</button>
                <button id="btnFaceTarget">Face Target</button>
                <button id="btnArc">Projectile Arc</button>
            </div>
            <div id="trigInfo" class="info-display">Move your mouse to see objects react using trigonometry!</div>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> JavaScript uses radians, not degrees! To convert: degrees √ó (œÄ / 180) = radians. Most game engines work in radians too!
            </div>

            <h3>More Advanced Trigonometry Patterns</h3>

            <details>
                <summary>üìù Pattern 4: Spiral Motion</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SpiralObject {
    constructor(centerX, centerY) {
        this.center = new Vector2D(centerX, centerY);
        this.angle = 0;
        this.radius = 0;
        this.angleSpeed = 0.05;
        this.radiusGrowth = 0.5;  // How fast spiral expands
    }

    update() {
        // Increment angle and radius
        this.angle += this.angleSpeed;
        this.radius += this.radiusGrowth;

        // Calculate position on expanding spiral
        this.position = new Vector2D(
            this.center.x + Math.cos(this.angle) * this.radius,
            this.center.y + Math.sin(this.angle) * this.radius
        );
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Whirlpool effects, drill attacks, spiral particle patterns, galaxy arms!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 5: Pendulum/Swing Motion</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Pendulum {
    constructor(pivotX, pivotY, length) {
        this.pivot = new Vector2D(pivotX, pivotY);
        this.length = length;
        this.angle = Math.PI / 4;  // Starting angle (45 degrees)
        this.angleVelocity = 0;
        this.angleAcceleration = 0;
        this.gravity = 0.5;
        this.damping = 0.995;  // Energy loss
    }

    update() {
        // Physics calculation for pendulum
        this.angleAcceleration = (-this.gravity / this.length) * Math.sin(this.angle);
        this.angleVelocity += this.angleAcceleration;
        this.angleVelocity *= this.damping;  // Apply damping
        this.angle += this.angleVelocity;

        // Calculate bob position
        this.position = new Vector2D(
            this.pivot.x + Math.sin(this.angle) * this.length,
            this.pivot.y + Math.cos(this.angle) * this.length
        );
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Swinging ropes, hanging chains, swing sets, wrecking balls, grappling hooks!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 6: Figure-8 / Lissajous Curves</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Lissajous {
    constructor(centerX, centerY, radiusX, radiusY) {
        this.center = new Vector2D(centerX, centerY);
        this.radiusX = radiusX;
        this.radiusY = radiusY;
        this.time = 0;
        this.freqX = 3;  // Frequency ratio for X
        this.freqY = 2;  // Frequency ratio for Y
        this.phase = Math.PI / 2;  // Phase shift
    }

    update() {
        this.time += 0.02;

        // Create complex patterns using different frequencies
        this.position = new Vector2D(
            this.center.x + Math.sin(this.time * this.freqX) * this.radiusX,
            this.center.y + Math.sin(this.time * this.freqY + this.phase) * this.radiusY
        );
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Complex movement patterns, boss attack patterns, decorative animations, portal effects!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 7: Angle Interpolation (Smooth Rotation)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Interpolate between two angles (handles wraparound)
function lerpAngle(start, end, t) {
    // Normalize angles to -œÄ to œÄ range
    let diff = end - start;

    // Take shortest path around circle
    while (diff > Math.PI) diff -= 2 * Math.PI;
    while (diff < -Math.PI) diff += 2 * Math.PI;

    return start + diff * t;
}

class RotatingEntity {
    constructor() {
        this.currentAngle = 0;
        this.targetAngle = 0;
        this.rotationSpeed = 0.1;  // 10% per frame
    }

    faceDirection(target) {
        // Calculate angle to target
        const dx = target.x - this.position.x;
        const dy = target.y - this.position.y;
        this.targetAngle = Math.atan2(dy, dx);
    }

    update() {
        // Smoothly rotate toward target
        this.currentAngle = lerpAngle(
            this.currentAngle,
            this.targetAngle,
            this.rotationSpeed
        );
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Turrets tracking targets, smooth camera rotation, character facing direction, vehicle steering!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 8: Field of View (FOV) Detection</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Enemy {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.facingAngle = 0;
        this.fovAngle = Math.PI / 3;  // 60 degree FOV
        this.viewDistance = 200;
    }

    canSee(target) {
        // Calculate direction to target
        const toTarget = target.subtract(this.position);
        const distance = toTarget.length();

        // Check if within view distance
        if (distance > this.viewDistance) return false;

        // Calculate angle to target
        const angleToTarget = Math.atan2(toTarget.y, toTarget.x);

        // Calculate angle difference
        let angleDiff = angleToTarget - this.facingAngle;

        // Normalize to -œÄ to œÄ
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        // Check if within FOV cone
        return Math.abs(angleDiff) < this.fovAngle / 2;
    }

    drawFOV(ctx) {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.facingAngle);

        // Draw FOV cone
        ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, this.viewDistance,
            -this.fovAngle / 2, this.fovAngle / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Stealth games, enemy detection, spotlight mechanics, radar systems, guard AI!
                </div>
            </details>

            <details>
                <summary>üìù Pattern 9: 8-Directional Sprite Selection</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Convert angle to one of 8 directions for sprite selection
function angleToDirection8(angle) {
    // Normalize angle to 0-2œÄ
    let normalized = angle % (2 * Math.PI);
    if (normalized < 0) normalized += 2 * Math.PI;

    // Divide circle into 8 sections (45 degrees each)
    const section = Math.round(normalized / (Math.PI / 4)) % 8;

    const directions = [
        'right',      // 0¬∞
        'down-right', // 45¬∞
        'down',       // 90¬∞
        'down-left',  // 135¬∞
        'left',       // 180¬∞
        'up-left',    // 225¬∞
        'up',         // 270¬∞
        'up-right'    // 315¬∞
    ];

    return directions[section];
}

class Character {
    constructor() {
        this.velocity = new Vector2D(0, 0);
        this.currentSprite = 'idle-down';
    }

    update() {
        if (this.velocity.length() > 0.1) {
            // Get movement angle
            const angle = Math.atan2(this.velocity.y, this.velocity.x);

            // Get direction
            const direction = angleToDirection8(angle);

            // Set appropriate sprite
            this.currentSprite = `walk-${direction}`;
        } else {
            this.currentSprite = 'idle-down';
        }
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Top-down RPGs, strategy games, isometric games - selecting correct character sprite based on movement direction!
                </div>
            </details>

            <h3>Interactive Demo: Advanced Trigonometry</h3>
            <div class="diagram">
                <canvas id="advancedTrigDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSpiralDemo">Spiral Motion</button>
                <button id="btnPendulumDemo">Pendulum</button>
                <button id="btnLissajousDemo">Lissajous Curve</button>
                <button id="btnFOVDemo">Field of View</button>
                <button id="btnDirectionDemo">8-Direction Sprites</button>
            </div>
            <div id="advTrigInfo" class="info-display">Explore advanced trigonometry patterns!</div>

            <h3>Practical Game System: Radar/Minimap</h3>
            <details>
                <summary>üìù Click to see: Complete Radar System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Radar {
    constructor(centerX, centerY, radius) {
        this.center = new Vector2D(centerX, centerY);
        this.radius = radius;
        this.scale = 0.1;  // World scale to radar scale
    }

    worldToRadar(worldPos, playerPos) {
        // Get position relative to player
        const relative = worldPos.subtract(playerPos);

        // Scale down to radar size
        const scaled = relative.copy().multiply(this.scale);

        // Translate to radar center
        return new Vector2D(
            this.center.x + scaled.x,
            this.center.y + scaled.y
        );
    }

    draw(ctx, entities, player) {
        // Draw radar background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw border
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw crosshairs
        ctx.beginPath();
        ctx.moveTo(this.center.x - 5, this.center.y);
        ctx.lineTo(this.center.x + 5, this.center.y);
        ctx.moveTo(this.center.x, this.center.y - 5);
        ctx.lineTo(this.center.x, this.center.y + 5);
        ctx.stroke();

        // Draw entities
        entities.forEach(entity => {
            const radarPos = this.worldToRadar(entity.position, player.position);

            // Only draw if within radar range
            const dist = radarPos.distance(this.center);
            if (dist < this.radius) {
                ctx.fillStyle = entity.isEnemy ? '#f00' : '#0f0';
                ctx.beginPath();
                ctx.arc(radarPos.x, radarPos.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Use case:</strong> Minimaps, radar systems, strategy games, awareness indicators!
                </div>
            </details>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> JavaScript uses radians, not degrees! To convert: degrees √ó (œÄ / 180) = radians. Most game engines work in radians too!
            </div>
        </div>

        <!-- EASING FUNCTIONS -->
        <div id="easing" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üé¨ Easing Functions & Smooth Motion</h2>

            <div class="concept-box">
                <h4>What are Easing Functions?</h4>
                <p>Easing functions control the rate of change over time, making animations feel natural instead of robotic. They answer the question: "How should this value change from start to end?"</p>
                <p><strong>Three types:</strong></p>
                <ul>
                    <li><strong>Ease In:</strong> Starts slow, ends fast (acceleration)</li>
                    <li><strong>Ease Out:</strong> Starts fast, ends slow (deceleration)</li>
                    <li><strong>Ease In-Out:</strong> Starts slow, speeds up, then slows down</li>
                </ul>
            </div>

            <details data-demo-id="easing" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Common Easing Functions</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// t is time (0 to 1), where 0 = start and 1 = end

// Linear (no easing - constant speed)
function easeLinear(t) {
    return t;
}

// Quadratic Ease In (gentle acceleration)
function easeInQuad(t) {
    return t * t;
}

// Quadratic Ease Out (gentle deceleration)
function easeOutQuad(t) {
    return t * (2 - t);
}

// Quadratic Ease In-Out
function easeInOutQuad(t) {
    return t < 0.5 ?
        2 * t * t :
        -1 + (4 - 2 * t) * t;
}

// Cubic (more dramatic)
function easeInCubic(t) {
    return t * t * t;
}

function easeOutCubic(t) {
    const t1 = t - 1;
    return t1 * t1 * t1 + 1;
}

// Elastic (bouncy, like a spring)
function easeOutElastic(t) {
    const p = 0.3;
    return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
}

// Bounce (like a ball bouncing)
function easeOutBounce(t) {
    if (t < 1 / 2.75) {
        return 7.5625 * t * t;
    } else if (t < 2 / 2.75) {
        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    } else if (t < 2.5 / 2.75) {
        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    } else {
        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using Easing in Your Game:</h4>
                    <pre><code class="language-javascript">class AnimatedObject {
    constructor(startPos, endPos, duration) {
        this.startPos = startPos;
        this.endPos = endPos;
        this.duration = duration;
        this.elapsed = 0;
        this.position = startPos.copy();
    }

    update(deltaTime) {
        this.elapsed += deltaTime;

        // Calculate progress (0 to 1)
        let t = this.elapsed / this.duration;
        t = Math.min(t, 1);  // Cap at 1

        // Apply easing
        const easedT = easeOutQuad(t);

        // Interpolate position
        this.position.x = lerp(this.startPos.x, this.endPos.x, easedT);
        this.position.y = lerp(this.startPos.y, this.endPos.y, easedT);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Easing Comparison</h3>
            <div class="diagram">
                <canvas id="easingDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnLinear">Linear</button>
                <button id="btnEaseIn">Ease In</button>
                <button id="btnEaseOut">Ease Out</button>
                <button id="btnEaseInOut">Ease In-Out</button>
                <button id="btnElastic">Elastic</button>
                <button id="btnBounce">Bounce</button>
                <button id="btnCompareAll">Compare All</button>
            </div>
            <div id="easingInfo" class="info-display">Watch how different easing functions affect motion</div>

            <div class="key-point">
                <strong>üí° Design Tip:</strong> Use ease-out for UI elements (feels responsive). Use ease-in-out for camera movements (feels smooth). Use elastic/bounce sparingly for special effects!
            </div>
        </div>

        <!-- GAME SYSTEMS -->
        <div id="game-systems" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üéÆ Building Your First Game System</h2>

            <p>Let's put it all together and create a simple game with a player, enemies, and projectiles!</p>

            <h3>Complete Game Loop</h3>
            <details data-demo-id="game" data-deps="vector2d,clearCanvas,clamp,randomFloat">
                <summary>üìù Click to see: Complete Game Code</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Player {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.speed = 5;
    }

    update(input) {
        // Get input direction
        let dir = new Vector2D(
            input.right - input.left,
            input.down - input.up
        );

        // Normalize and apply speed
        if (dir.length() > 0) {
            dir.normalize().multiply(this.speed);
        }

        // Update position
        this.position.add(dir);
    }

    draw(ctx) {
        ctx.fillStyle = '#4fc3f7';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, 20, 0, Math.PI * 2);
        ctx.fill();
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Complete Game</h3>
            <div class="diagram">
                <canvas id="gameDemo" width="800" height="600"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddEnemy">Add Enemy</button>
                <button id="btnResetGame">Reset Game</button>
            </div>
            <div id="gameInfo" class="info-display">Use WASD to move, Click to shoot!</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Extend the Game!</h4>
                <p>Try adding these features:</p>
                <ul>
                    <li>Make enemies move toward the player</li>
                    <li>Add a score counter</li>
                    <li>Create different enemy types</li>
                    <li>Add power-ups that increase speed</li>
                </ul>
            </div>

            <h3>üöÄ Practical Example: Homing Missiles</h3>
            <p>Let's build a complete homing missile system! This demonstrates vectors, seeking behavior, and rotation all working together.</p>

            <div class="concept-box">
                <h4>How Homing Missiles Work</h4>
                <p>A homing missile constantly adjusts its direction to track a moving target. The math behind it:</p>
                <ul>
                    <li><strong>Calculate Direction:</strong> Vector from missile to target</li>
                    <li><strong>Normalize & Apply Speed:</strong> Make it constant velocity</li>
                    <li><strong>Rotate Sprite:</strong> Use atan2 to face the right direction</li>
                    <li><strong>Add Trails:</strong> Create visual effects for polish</li>
                </ul>
            </div>

            <details data-demo-id="homingMissile" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Homing Missile Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class HomingMissile {
    constructor(x, y, target) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.target = target;
        this.speed = 3;
        this.turnRate = 0.05;  // How quickly it can turn
        this.rotation = 0;
        this.alive = true;
        this.trail = [];  // For visual effect
    }

    update() {
        // Calculate direction to target
        const toTarget = this.target.position.subtract(this.position);

        // Normalize and apply speed (seeking behavior)
        const desired = toTarget.copy().normalize().multiply(this.speed);

        // Smooth steering (lerp toward desired velocity)
        this.velocity.lerp(desired, this.turnRate);

        // Update position
        this.position.add(this.velocity);

        // Update rotation to face movement direction
        this.rotation = Math.atan2(this.velocity.y, this.velocity.x);

        // Add to trail for visual effect
        this.trail.push(this.position.copy());
        if (this.trail.length > 20) this.trail.shift();

        // Check if hit target
        if (this.position.distance(this.target.position) < 20) {
            this.alive = false;
            // Explosion effect here!
        }
    }

    draw(ctx) {
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
            const alpha = i / this.trail.length;
            ctx.fillStyle = `rgba(255, 165, 0, ${alpha * 0.5})`;
            ctx.beginPath();
            ctx.arc(this.trail[i].x, this.trail[i].y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw missile body (rotated)
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.rotation);

        // Missile body
        ctx.fillStyle = '#ef5350';
        ctx.fillRect(-10, -4, 20, 8);

        // Missile nose (pointy end)
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(15, -4);
        ctx.lineTo(15, 4);
        ctx.closePath();
        ctx.fill();

        // Fins
        ctx.fillStyle = '#c62828';
        ctx.fillRect(-8, 4, 6, 4);
        ctx.fillRect(-8, -8, 6, 4);

        ctx.restore();
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Variations & Advanced Techniques</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// VARIATION 1: Predictive Targeting (leads the target)
class PredictiveMissile extends HomingMissile {
    update() {
        // Predict where target will be
        const prediction = this.target.position.copy()
            .add(this.target.velocity.copy().multiply(10));

        // Aim for predicted position instead
        const toTarget = prediction.subtract(this.position);
        const desired = toTarget.copy().normalize().multiply(this.speed);
        this.velocity.lerp(desired, this.turnRate);
        this.position.add(this.velocity);
        this.rotation = Math.atan2(this.velocity.y, this.velocity.x);
    }
}

// VARIATION 2: Limited Fuel Missile
class FuelMissile extends HomingMissile {
    constructor(x, y, target) {
        super(x, y, target);
        this.fuel = 100;
    }

    update() {
        this.fuel -= 1;

        if (this.fuel > 0) {
            // Normal homing behavior
            super.update();
        } else {
            // Out of fuel - ballistic trajectory (gravity)
            this.velocity.y += 0.2;  // Gravity
            this.position.add(this.velocity);
            this.rotation = Math.atan2(this.velocity.y, this.velocity.x);
        }
    }
}

// VARIATION 3: Spiral/Corkscrew Missile
class SpiralMissile extends HomingMissile {
    constructor(x, y, target) {
        super(x, y, target);
        this.spiralAngle = 0;
        this.spiralRadius = 20;
    }

    update() {
        super.update();

        // Add spiral offset perpendicular to velocity
        this.spiralAngle += 0.2;
        const perpendicular = this.velocity.copy().perpendicular().normalize();
        const offset = perpendicular.multiply(
            Math.sin(this.spiralAngle) * this.spiralRadius
        );
        this.position.add(offset);
    }
}</code></pre>
                </div>

                <div class="key-point">
                    <strong>üí° Pro Tip:</strong> Adjust turnRate to change missile maneuverability. Lower = slow, wide turns (realistic). Higher = tight turns (arcade-style).
                </div>
            </details>

            <h3>Interactive Demo: Homing Missiles</h3>
            <div class="diagram">
                <canvas id="homingMissileDemo" width="800" height="600"></canvas>
            </div>
            <div class="controls">
                <button id="btnLaunchMissile">Launch Missile</button>
                <button id="btnTogglePredictive">Toggle Predictive</button>
                <button id="btnToggleFuel">Toggle Fuel Limit</button>
                <button id="btnClearMissiles">Clear All</button>
            </div>
            <div id="missileInfo" class="info-display">Move your mouse to control the target! Click "Launch Missile" or press SPACE</div>

            <div class="concept-box">
                <h4>What You're Seeing:</h4>
                <ul>
                    <li><strong>Orange trail:</strong> Shows missile's path</li>
                    <li><strong>Red line:</strong> Direction vector from missile to target</li>
                    <li><strong>Green circle:</strong> Your mouse-controlled target</li>
                    <li><strong>Rotation:</strong> Missile sprite automatically faces its velocity direction</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üéÆ Game Uses:</strong> Heat-seeking missiles, enemy homing attacks, magic spells that follow the player, auto-targeting turrets, guided projectiles in shoot-em-ups!
            </div>

        </div>

        <!-- MATRICES -->
        <div id="matrices" class="section">
            <span class="level-indicator level-beginner">BEGINNER</span>
            <h2>üîÑ Matrix Transformations</h2>

            <div class="concept-box">
                <h4>What are Matrices?</h4>
                <p>Matrices are powerful tools for transforming objects. They let you:</p>
                <ul>
                    <li><strong>Rotate:</strong> Spin an object around a point</li>
                    <li><strong>Scale:</strong> Make an object bigger or smaller</li>
                    <li><strong>Translate:</strong> Move an object to a new position</li>
                    <li><strong>Combine:</strong> Do all of the above at once!</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Matrix2D Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Matrix2D {
    constructor() {
        // Identity matrix (does nothing)
        this.a = 1; this.b = 0; this.tx = 0;
        this.c = 0; this.d = 1; this.ty = 0;
    }

    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        // Apply rotation transformation
        // ... matrix math here ...
        return this;
    }

    scale(sx, sy) {
        this.a *= sx;
        this.b *= sx;
        this.c *= sy;
        this.d *= sy;
        return this;
    }

    translate(tx, ty) {
        this.tx += tx;
        this.ty += ty;
        return this;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Transformations</h3>
            <div class="diagram">
                <canvas id="matrixDemo" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button id="btnRotate">Rotate</button>
                <button id="btnScale">Scale</button>
                <button id="btnTranslate">Translate</button>
                <button id="btnCombined">Combined Transform</button>
            </div>
            <div id="matrixInfo" class="info-display">Watch how different transformations affect the shape</div>
        </div>

        <!-- Next Steps -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Congratulations!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You've mastered the fundamentals! Ready for the next level?
            </p>
            <a href="intermediate.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                Continue to Intermediate ‚Üí
            </a>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="beginner-demos.js"></script>
</body>
</html>
