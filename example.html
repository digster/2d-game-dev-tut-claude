<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Math - Progressive Learning Path</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: #4fc3f7;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #9e9e9e;
            font-size: 1.2em;
            margin-bottom: 40px;
        }
        
        .level-nav {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .level-button {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d3354 100%);
            border: 2px solid #4fc3f7;
            color: #e0e0e0;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 16px;
        }
        
        .level-button:hover {
            background: linear-gradient(135deg, #2d3354 0%, #3d4470 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 195, 247, 0.3);
        }
        
        .level-button.active {
            background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
            color: #0a0e27;
            border-color: #29b6f6;
        }
        
        .level-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .level-beginner { background-color: #66bb6a; color: #0a0e27; }
        .level-intermediate { background-color: #ffa726; color: #0a0e27; }
        .level-advanced { background-color: #ef5350; color: #fff; }
        .level-expert { background-color: #ab47bc; color: #fff; }
        
        h2 {
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 10px;
            margin-top: 50px;
        }
        
        h3 {
            color: #29b6f6;
            margin-top: 30px;
        }
        
        .section {
            background-color: #1a1f3a;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            display: block;
        }
        
        .concept-box {
            background-color: #252b4a;
            border-left: 4px solid #4fc3f7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .challenge-box {
            background-color: #3d2817;
            border-left: 4px solid #ffa726;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .challenge-box h4 {
            color: #ffa726;
            margin-top: 0;
        }
        
        .thinking-prompt {
            background-color: #2d1b3d;
            border-left: 4px solid #d2a8ff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .thinking-prompt h4 {
            color: #d2a8ff;
            margin-top: 0;
        }
        
        .example-box {
            background-color: #1e3a2f;
            border-left: 4px solid #66bb6a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .example-box h4 {
            color: #66bb6a;
            margin-top: 0;
        }
        
        .code-container {
            background-color: #0d1117;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            border: 1px solid #30363d;
        }
        
        .code-header {
            color: #4fc3f7;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        pre {
            margin: 0;
            color: #c9d1d9;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        code {
            color: #79c0ff;
        }
        
        .comment { color: #8b949e; font-style: italic; }
        .keyword { color: #ff7b72; }
        .string { color: #a5d6ff; }
        .number { color: #79c0ff; }
        .function { color: #d2a8ff; }
        
        canvas {
            border: 2px solid #4fc3f7;
            border-radius: 8px;
            background-color: #0d1117;
            display: block;
            margin: 20px auto;
            cursor: crosshair;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        
        button {
            background-color: #4fc3f7;
            color: #0a0e27;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background-color: #29b6f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(79, 195, 247, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .diagram {
            background-color: #0d1117;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .key-point {
            background-color: #2d1b3d;
            border-left: 4px solid #d2a8ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .key-point strong {
            color: #d2a8ff;
        }
        
        .step {
            background-color: #1a2332;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #66bb6a;
        }
        
        .step-number {
            display: inline-block;
            background-color: #66bb6a;
            color: #0a0e27;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            text-align: center;
            line-height: 28px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #30363d;
        }
        
        th {
            background-color: #252b4a;
            color: #4fc3f7;
            font-weight: bold;
        }
        
        tr:hover {
            background-color: #1a2332;
        }
        
        .info-display {
            background-color: #252b4a;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .highlight {
            color: #ffd700;
            font-weight: bold;
        }
        
        details {
            background-color: #252b4a;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            cursor: pointer;
        }
        
        summary {
            font-weight: bold;
            color: #4fc3f7;
            cursor: pointer;
            user-select: none;
        }
        
        summary:hover {
            color: #29b6f6;
        }
        
        .exercise-input {
            width: 100%;
            background-color: #0d1117;
            color: #c9d1d9;
            border: 2px solid #30363d;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 10px 0;
            min-height: 100px;
        }
        
        .result {
            background-color: #1e3a2f;
            border-left: 4px solid #66bb6a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .result.error {
            background-color: #3a1e1e;
            border-left-color: #ef5350;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #252b4a;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #66bb6a 0%, #4fc3f7 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
        }
    </style>

</head>
<body>
    <div class="container">
        <h1>üéÆ Complete Game Math Guide</h1>
        <div class="subtitle">Every topic from both files - absolute beginner to expert level</div>


        <!-- COMPREHENSIVE TABLE OF CONTENTS -->
        <div style="background: linear-gradient(135deg, #1a1f3a 0%, #2d3354 100%); border-radius: 15px; padding: 30px; margin: 40px 0; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border: 2px solid #4fc3f7;">
            <div style="color: #4fc3f7; font-size: 1.8em; margin-bottom: 20px; text-align: center; font-weight: bold;">üìö Complete Table of Contents</div>
            <div style="text-align: center; color: #9e9e9e; margin-bottom: 30px;">Every topic from both files - nothing missed</div>
            
            <div style="margin: 30px 0;">
                <div style="color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px;">
                    <span style="display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.85em; background-color: #66bb6a; color: #0a0e27;">üìö FOUNDATIONS - From First File</span>
                </div>
                <ul style="list-style: none; padding-left: 20px;">
                    <li style="margin: 8px 0;"><a href="#intro" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px; transition: all 0.3s;">‚Üí Why Math Matters in Games</a></li>
                    <li style="margin: 8px 0;"><a href="#vectors" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí What are Vectors?</a></li>
                    <li style="margin: 8px 0;"><a href="#vector-operations" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Vector Operations</a></li>
                    <li style="margin: 8px 0;"><a href="#game-systems-basic" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Building Game Systems</a></li>
                    <li style="margin: 8px 0;"><a href="#matrices" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Matrix Transformations</a></li>
                </ul>
            </div>
            
            <div style="margin: 30px 0;">
                <div style="color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px;">
                    <span style="display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.85em; background-color: #ffa726; color: #0a0e27;">‚≠ê INTERMEDIATE - From Second File</span>
                </div>
                <ul style="list-style: none; padding-left: 20px;">
                    <li style="margin: 8px 0;"><a href="#lerp" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Interpolation (Lerp)</a></li>
                    <li style="margin: 8px 0;"><a href="#physics" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Physics System with Forces</a></li>
                    <li style="margin: 8px 0;"><a href="#collision" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Collision Detection</a></li>
                    <li style="margin: 8px 0;"><a href="#raycasting" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Raycasting</a></li>
                    <li style="margin: 8px 0;"><a href="#particles" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Particle Systems</a></li>
                </ul>
            </div>
            
            <div style="margin: 30px 0;">
                <div style="color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px;">
                    <span style="display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.85em; background-color: #ef5350; color: #fff;">‚≠ê‚≠ê ADVANCED - From Second File</span>
                </div>
                <ul style="list-style: none; padding-left: 20px;">
                    <li style="margin: 8px 0;"><a href="#quaternions" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Quaternions</a></li>
                    <li style="margin: 8px 0;"><a href="#steering" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Steering Behaviors</a></li>
                    <li style="margin: 8px 0;"><a href="#bezier" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí B√©zier Curves</a></li>
                    <li style="margin: 8px 0;"><a href="#pathfinding" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí A* Pathfinding</a></li>
                    <li style="margin: 8px 0;"><a href="#statemachines" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí State Machines</a></li>
                    <li style="margin: 8px 0;"><a href="#ik" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Inverse Kinematics</a></li>
                    <li style="margin: 8px 0;"><a href="#shadows" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Shadow Casting</a></li>
                </ul>
            </div>
            
            <div style="margin: 30px 0;">
                <div style="color: #ffd700; font-size: 1.3em; font-weight: bold; margin-bottom: 15px;">
                    <span style="display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 0.85em; background-color: #ab47bc; color: #fff;">‚≠ê‚≠ê‚≠ê EXPERT - From Second File</span>
                </div>
                <ul style="list-style: none; padding-left: 20px;">
                    <li style="margin: 8px 0;"><a href="#spatial" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Spatial Partitioning</a></li>
                    <li style="margin: 8px 0;"><a href="#quadtree" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí QuadTree</a></li>
                    <li style="margin: 8px 0;"><a href="#pooling" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Object Pooling</a></li>
                    <li style="margin: 8px 0;"><a href="#procgen" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Procedural Generation</a></li>
                    <li style="margin: 8px 0;"><a href="#tilemap" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Tilemap Systems</a></li>
                    <li style="margin: 8px 0;"><a href="#sound" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Sound Propagation</a></li>
                    <li style="margin: 8px 0;"><a href="#network" style="color: #29b6f6; text-decoration: none; font-size: 1.05em; padding: 5px 10px; display: inline-block; border-radius: 5px;">‚Üí Network Interpolation</a></li>
                </ul>
            </div>
        </div>
        
        <div style="position: fixed; bottom: 30px; right: 30px; background-color: #4fc3f7; color: #0a0e27; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 24px; box-shadow: 0 4px 8px rgba(79, 195, 247, 0.3); z-index: 1000;" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">‚Üë</div>


        <!-- ====================================== -->
        <!-- PART 1: BEGINNER CONTENT FROM FILE 1 -->
        <!-- ====================================== -->
        
<!-- INTRODUCTION -->
        <div id="intro" class="section">
            <h2>üöÄ Why Math Matters in Games</h2>
            <p>When you play a game, math is happening everywhere - even if you don't see it!</p>
            
            <div class="example-box">
                <h4>üéØ Real Game Examples</h4>
                <ul>
                    <li><strong>Moving a character:</strong> Uses vectors to track position and direction</li>
                    <li><strong>Rotating a spaceship:</strong> Uses matrices or quaternions</li>
                    <li><strong>Checking if you hit an enemy:</strong> Uses vector distance calculations</li>
                    <li><strong>Creating particle effects:</strong> Uses physics and vectors</li>
                </ul>
            </div>
            
            <p>Don't worry if these terms sound scary! We'll break everything down into simple, visual examples. By the end, you'll understand exactly how games work "under the hood."</p>
        </div>

        <!-- PART 1: VECTORS -->
        <div id="vectors" class="section">
            <h2>üìê Part 1: Vectors - Your Position & Direction Tool</h2>
            
            <h3>What is a Vector?</h3>
            <p>Imagine you're telling a friend how to walk to a store. You could say:</p>
            <ul>
                <li>"Walk 3 blocks east, then 2 blocks north"</li>
                <li>Or in math: <strong>Vector = (3, 2)</strong></li>
            </ul>
            
            <div class="concept-box">
                <p><strong>A vector is just a pair of numbers that tells you:</strong></p>
                <ul>
                    <li><strong>How far to move</strong> (magnitude/length)</li>
                    <li><strong>Which direction to move</strong></li>
                </ul>
            </div>

            <div class="diagram">
                <canvas id="vectorBasics" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button onclick="showVectorExample('simple')">Show Simple Vector</button>
                <button onclick="showVectorExample('player')">Player Movement Example</button>
                <button onclick="showVectorExample('bullet')">Bullet Direction Example</button>
            </div>
            <div id="vectorInfo" class="info-display"></div>

            <h3>Building a Vector Class - Step by Step</h3>
            
            <div class="step">
                <span class="step-number">1</span>
                <strong>First, let's store x and y:</strong>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù The Simplest Vector (Step 1)</div>
                <pre><code><span class="keyword">class</span> <span class="function">Vector2D</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.x = x;  <span class="comment">// Horizontal position</span>
        <span class="keyword">this</span>.y = y;  <span class="comment">// Vertical position</span>
    }
}</code></pre>
            </div>
            
            <div class="example-box">
                <h4>üéÆ Using it in a game:</h4>
                <pre><code><span class="comment">// Create a player at position (100, 200)</span>
<span class="keyword">let</span> playerPosition = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">100</span>, <span class="number">200</span>);

<span class="comment">// Create an enemy at position (300, 150)</span>
<span class="keyword">let</span> enemyPosition = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">300</span>, <span class="number">150</span>);</code></pre>
            </div>

            <div class="step">
                <span class="step-number">2</span>
                <strong>Add vector addition (combining movements):</strong>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù Adding Movement (Step 2)</div>
                <pre><code><span class="keyword">class</span> <span class="function">Vector2D</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
    }
    
    <span class="comment">// Add another vector to this one</span>
    <span class="function">add</span>(other) {
        <span class="keyword">this</span>.x += other.x;  <span class="comment">// Move horizontally</span>
        <span class="keyword">this</span>.y += other.y;  <span class="comment">// Move vertically</span>
        <span class="keyword">return</span> <span class="keyword">this</span>;        <span class="comment">// Allow chaining</span>
    }
}</code></pre>
            </div>
            
            <div class="example-box">
                <h4>üéÆ Moving the player:</h4>
                <pre><code><span class="comment">// Player starts at (100, 100)</span>
<span class="keyword">let</span> player = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">100</span>, <span class="number">100</span>);

<span class="comment">// Player presses 'W' key - move up</span>
<span class="keyword">let</span> movement = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, -<span class="number">5</span>);  <span class="comment">// Up is negative Y!</span>
player.<span class="function">add</span>(movement);

<span class="comment">// Now player is at (100, 95) - moved up 5 pixels!</span></code></pre>
            </div>

            <div class="step">
                <span class="step-number">3</span>
                <strong>Add distance calculation (for collision detection):</strong>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù Measuring Distance (Step 3)</div>
                <pre><code><span class="function">distance</span>(other) {
    <span class="comment">// Use Pythagorean theorem: ‚àö(dx¬≤ + dy¬≤)</span>
    <span class="keyword">let</span> dx = other.x - <span class="keyword">this</span>.x;  <span class="comment">// Horizontal distance</span>
    <span class="keyword">let</span> dy = other.y - <span class="keyword">this</span>.y;  <span class="comment">// Vertical distance</span>
    <span class="keyword">return</span> Math.<span class="function">sqrt</span>(dx * dx + dy * dy);
}</code></pre>
            </div>
            
            <div class="key-point">
                <strong>üí° Why distance matters:</strong> You check if a bullet hit an enemy by seeing if the distance between them is less than their combined radii!
            </div>
            
            <div class="example-box">
                <h4>üéÆ Collision detection:</h4>
                <pre><code><span class="keyword">let</span> bullet = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">150</span>, <span class="number">150</span>);
<span class="keyword">let</span> enemy = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">155</span>, <span class="number">148</span>);

<span class="keyword">let</span> distance = bullet.<span class="function">distance</span>(enemy);  <span class="comment">// About 5.4 pixels</span>

<span class="keyword">if</span> (distance < <span class="number">10</span>) {  <span class="comment">// Hit radius = 10 pixels</span>
    console.<span class="function">log</span>(<span class="string">"üí• Hit!"</span>);
}</code></pre>
            </div>

            <h3>Interactive Demo: Play with Vectors!</h3>
            <div class="diagram">
                <canvas id="vectorPlayground" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="addMovingObject()">Add Moving Object</button>
                <button onclick="clearObjects()">Clear All</button>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Click and drag to create vectors. Objects will move along their vectors!</p>
        </div>

        <!-- PART 2: VECTOR OPERATIONS -->
        <div id="vector-operations" class="section">
            <h2>üîß Part 2: Essential Vector Operations</h2>
            
            <h3>1. Normalize (Make Unit Length)</h3>
            <div class="concept-box">
                <p><strong>Problem:</strong> You want the player to always move at the same speed, regardless of direction.</p>
                <p><strong>Solution:</strong> Normalize the vector (make it length = 1), then multiply by desired speed.</p>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù Normalization Code</div>
                <pre><code><span class="function">normalize</span>() {
    <span class="keyword">let</span> length = <span class="keyword">this</span>.<span class="function">length</span>();
    <span class="keyword">if</span> (length > <span class="number">0</span>) {
        <span class="keyword">this</span>.x /= length;  <span class="comment">// Divide by length</span>
        <span class="keyword">this</span>.y /= length;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
}

<span class="function">length</span>() {
    <span class="keyword">return</span> Math.<span class="function">sqrt</span>(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y);
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Constant Speed Movement:</h4>
                <pre><code><span class="comment">// Get input direction (could be diagonal!)</span>
<span class="keyword">let</span> direction = <span class="keyword">new</span> <span class="function">Vector2D</span>(
    input.right - input.left,    <span class="comment">// -1, 0, or 1</span>
    input.down - input.up
);

<span class="comment">// Normalize so diagonal isn't faster!</span>
direction.<span class="function">normalize</span>();

<span class="comment">// Apply constant speed</span>
<span class="keyword">let</span> speed = <span class="number">5</span>;
player.<span class="function">add</span>(direction.<span class="function">multiply</span>(speed));</code></pre>
            </div>

            <div class="diagram">
                <canvas id="normalizeDemo" width="800" height="400"></canvas>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. The green vector stays constant length (normalized)!</p>

            <h3>2. Dot Product (Angle Between Vectors)</h3>
            <div class="concept-box">
                <p><strong>Use case:</strong> Check if an enemy is in front of or behind the player, or if the player is facing a target.</p>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù Dot Product</div>
                <pre><code><span class="function">dot</span>(other) {
    <span class="keyword">return</span> <span class="keyword">this</span>.x * other.x + <span class="keyword">this</span>.y * other.y;
}</code></pre>
            </div>
            
            <div class="key-point">
                <strong>üí° Magic of Dot Product:</strong>
                <ul>
                    <li>Result > 0: Vectors point in similar direction (enemy in front)</li>
                    <li>Result = 0: Vectors are perpendicular (enemy to the side)</li>
                    <li>Result < 0: Vectors point opposite ways (enemy behind)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üéÆ Field of View Check:</h4>
                <pre><code><span class="keyword">let</span> playerDir = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// Facing right</span>
<span class="keyword">let</span> toEnemy = enemy.<span class="function">subtract</span>(player).<span class="function">normalize</span>();

<span class="keyword">let</span> dotProduct = playerDir.<span class="function">dot</span>(toEnemy);

<span class="keyword">if</span> (dotProduct > <span class="number">0.5</span>) {  <span class="comment">// About 60¬∞ cone</span>
    console.<span class="function">log</span>(<span class="string">"üëÅÔ∏è Enemy spotted!"</span>);
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="dotProductDemo" width="800" height="400"></canvas>
            </div>
            <div id="dotProductInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Watch how the dot product changes based on angle!</p>
        </div>

        <!-- PART 3: PRACTICAL GAME SYSTEMS -->
        <div id="game-systems-basic" class="section">
            <h2>üéØ Part 3: Building Game Systems with Vectors</h2>
            
            <h3>System 1: Simple Player Movement</h3>
            <div class="concept-box">
                <p>Let's build a complete movement system from scratch!</p>
            </div>
            
            <div class="code-container">
                <div class="code-header">üìù Complete Movement System</div>
                <pre><code><span class="keyword">class</span> <span class="function">Player</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.speed = <span class="number">5</span>;
    }
    
    <span class="function">update</span>(keys) {
        <span class="comment">// 1. Get input direction</span>
        <span class="keyword">let</span> direction = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        
        <span class="keyword">if</span> (keys.left) direction.x -= <span class="number">1</span>;
        <span class="keyword">if</span> (keys.right) direction.x += <span class="number">1</span>;
        <span class="keyword">if</span> (keys.up) direction.y -= <span class="number">1</span>;
        <span class="keyword">if</span> (keys.down) direction.y += <span class="number">1</span>;
        
        <span class="comment">// 2. Normalize to prevent faster diagonal movement</span>
        <span class="keyword">if</span> (direction.<span class="function">length</span>() > <span class="number">0</span>) {
            direction.<span class="function">normalize</span>();
        }
        
        <span class="comment">// 3. Set velocity</span>
        <span class="keyword">this</span>.velocity = direction.<span class="function">multiply</span>(<span class="keyword">this</span>.speed);
        
        <span class="comment">// 4. Update position</span>
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
    }
}</code></pre>
            </div>

            <h3>System 2: Homing Missile</h3>
            <div class="code-container">
                <div class="code-header">üìù Homing Missile Logic</div>
                <pre><code><span class="keyword">class</span> <span class="function">HomingMissile</span> {
    <span class="keyword">constructor</span>(x, y, target) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.target = target;
        <span class="keyword">this</span>.speed = <span class="number">3</span>;
        <span class="keyword">this</span>.turnSpeed = <span class="number">0.1</span>;  <span class="comment">// How sharply it can turn</span>
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">1</span>, <span class="number">0</span>);
    }
    
    <span class="function">update</span>() {
        <span class="comment">// 1. Calculate direction to target</span>
        <span class="keyword">let</span> toTarget = <span class="keyword">this</span>.target
            .<span class="function">subtract</span>(<span class="keyword">this</span>.position)
            .<span class="function">normalize</span>();
        
        <span class="comment">// 2. Smoothly turn toward target</span>
        <span class="keyword">this</span>.velocity
            .<span class="function">add</span>(toTarget.<span class="function">multiply</span>(<span class="keyword">this</span>.turnSpeed))
            .<span class="function">normalize</span>()
            .<span class="function">multiply</span>(<span class="keyword">this</span>.speed);
        
        <span class="comment">// 3. Move</span>
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="homingDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="launchMissile()">Launch Homing Missile</button>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Click to launch homing missiles that track your cursor!</p>
        </div>

        <!-- MATRICES SECTION -->
        <div id="matrices" class="section">
            <h2>üîÑ Part 4: Matrices - The Transformation Tool</h2>
            
            <h3>What is a Matrix?</h3>
            <div class="concept-box">
                <p>Think of a matrix as a "transformation recipe" that can:</p>
                <ul>
                    <li><strong>Rotate</strong> things (spin a spaceship)</li>
                    <li><strong>Scale</strong> things (make bigger/smaller)</li>
                    <li><strong>Translate</strong> things (move position)</li>
                    <li><strong>Combine all three!</strong></li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üí° Why use matrices?</strong> Instead of rotating every vertex of a 3D model one by one, you create ONE matrix and apply it to everything. Much faster!
            </div>

            <h3>The 2D Transform Matrix</h3>
            <div class="code-container">
                <div class="code-header">üìù Simple 2D Matrix</div>
                <pre><code><span class="comment">// A 2D transformation matrix is a 3x3 grid of numbers:</span>
<span class="comment">// | a  b  tx |</span>
<span class="comment">// | c  d  ty |</span>
<span class="comment">// | 0  0  1  |</span>

<span class="keyword">class</span> <span class="function">Matrix2D</span> {
    <span class="keyword">constructor</span>() {
        <span class="comment">// Identity matrix (does nothing = no transformation)</span>
        <span class="keyword">this</span>.a = <span class="number">1</span>;  <span class="keyword">this</span>.b = <span class="number">0</span>;  <span class="keyword">this</span>.tx = <span class="number">0</span>;
        <span class="keyword">this</span>.c = <span class="number">0</span>;  <span class="keyword">this</span>.d = <span class="number">1</span>;  <span class="keyword">this</span>.ty = <span class="number">0</span>;
    }
    
    <span class="comment">// Rotate by angle (in radians)</span>
    <span class="function">rotate</span>(angle) {
        <span class="keyword">let</span> cos = Math.<span class="function">cos</span>(angle);
        <span class="keyword">let</span> sin = Math.<span class="function">sin</span>(angle);
        
        <span class="keyword">this</span>.a = cos;   <span class="keyword">this</span>.b = -sin;
        <span class="keyword">this</span>.c = sin;   <span class="keyword">this</span>.d = cos;
        
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    
    <span class="comment">// Scale by sx and sy</span>
    <span class="function">scale</span>(sx, sy) {
        <span class="keyword">this</span>.a *= sx;
        <span class="keyword">this</span>.d *= sy;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    
    <span class="comment">// Move by x and y</span>
    <span class="function">translate</span>(x, y) {
        <span class="keyword">this</span>.tx = x;
        <span class="keyword">this</span>.ty = y;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    
    <span class="comment">// Apply transformation to a point</span>
    <span class="function">transformPoint</span>(vector) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Vector2D</span>(
            vector.x * <span class="keyword">this</span>.a + vector.y * <span class="keyword">this</span>.b + <span class="keyword">this</span>.tx,
            vector.x * <span class="keyword">this</span>.c + vector.y * <span class="keyword">this</span>.d + <span class="keyword">this</span>.ty
        );
    }
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Rotating a Spaceship:</h4>
                <pre><code><span class="comment">// Spaceship shape (just 3 points for a triangle)</span>
<span class="keyword">let</span> shipPoints = [
    <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">20</span>, <span class="number">0</span>),    <span class="comment">// Nose</span>
    <span class="keyword">new</span> <span class="function">Vector2D</span>(-<span class="number">10</span>, <span class="number">10</span>), <span class="comment">// Back-left</span>
    <span class="keyword">new</span> <span class="function">Vector2D</span>(-<span class="number">10</span>, -<span class="number">10</span>) <span class="comment">// Back-right</span>
];

<span class="comment">// Create rotation matrix (45 degrees = œÄ/4 radians)</span>
<span class="keyword">let</span> rotation = <span class="keyword">new</span> <span class="function">Matrix2D</span>().<span class="function">rotate</span>(Math.PI / <span class="number">4</span>);

<span class="comment">// Transform all points</span>
<span class="keyword">let</span> rotatedPoints = shipPoints.<span class="function">map</span>(p => rotation.<span class="function">transformPoint</span>(p));</code></pre>
            </div>

            <div class="diagram">
                <canvas id="matrixDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="setTransform('rotate')">Rotate</button>
                <button onclick="setTransform('scale')">Scale</button>
                <button onclick="setTransform('translate')">Translate</button>
                <button onclick="setTransform('combined')">Combined Transform</button>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Watch how matrices transform the spaceship!</p>
        </div>

        <!-- QUICK REFERENCE -->
        <div class="section">
            <h2>üìö Quick Reference Guide</h2>
            
            <h3>Common Vector Operations</h3>
            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>When to Use</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>add()</code></td>
                        <td>Moving objects, combining forces</td>
                        <td>Player movement, physics</td>
                    </tr>
                    <tr>
                        <td><code>subtract()</code></td>
                        <td>Finding direction between two points</td>
                        <td>Homing missiles, enemy AI</td>
                    </tr>
                    <tr>
                        <td><code>multiply()</code></td>
                        <td>Scaling speed/force</td>
                        <td>Speed boosts, slow-motion</td>
                    </tr>
                    <tr>
                        <td><code>normalize()</code></td>
                        <td>Constant speed movement</td>
                        <td>Player control, enemy movement</td>
                    </tr>
                    <tr>
                        <td><code>distance()</code></td>
                        <td>Collision detection, range checks</td>
                        <td>Bullets hitting, pickup items</td>
                    </tr>
                    <tr>
                        <td><code>dot()</code></td>
                        <td>Field of view, angle checks</td>
                        <td>Stealth games, cone vision</td>
                    </tr>
                </tbody>
            </table>

            <h3>Performance Tips</h3>
            <div class="concept-box">
                <ul>
                    <li><strong>Avoid sqrt when possible:</strong> Use <code>distanceSquared()</code> for comparisons (faster!)</li>
                    <li><strong>Cache normalized vectors:</strong> Don't normalize the same vector every frame</li>
                    <li><strong>Use object pools:</strong> Reuse vector objects instead of creating new ones</li>
                    <li><strong>Batch transformations:</strong> Combine multiple matrices into one</li>
                </ul>
            </div>
        </div>

        <!-- PRACTICE EXERCISES -->
        <div class="section">
            <h2>üí™ Practice Exercises</h2>
            
            <div class="example-box">
                <h4>üéØ Exercise 1: Follow the Leader</h4>
                <p>Make an object smoothly follow another object (like a pet following the player)</p>
                <details>
                    <summary>Click for solution</summary>
                    <div class="code-container">
                        <pre><code><span class="keyword">function</span> <span class="function">followTarget</span>(follower, target, speed) {
    <span class="comment">// Get direction to target</span>
    <span class="keyword">let</span> direction = target
        .<span class="function">subtract</span>(follower)
        .<span class="function">normalize</span>();
    
    <span class="comment">// Move toward target</span>
    follower.<span class="function">add</span>(direction.<span class="function">multiply</span>(speed));
}</code></pre>
                    </div>
                </details>
            </div>

            <div class="example-box">
                <h4>üéØ Exercise 2: Bounce Off Walls</h4>
                <p>Make a ball bounce realistically when it hits walls</p>
                <details>
                    <summary>Click for solution</summary>
                    <div class="code-container">
                        <pre><code><span class="keyword">function</span> <span class="function">bounceWalls</span>(position, velocity, width, height) {
    <span class="comment">// Bounce off left/right walls</span>
    <span class="keyword">if</span> (position.x < <span class="number">0</span> || position.x > width) {
        velocity.x *= -<span class="number">1</span>;  <span class="comment">// Reverse horizontal direction</span>
    }
    
    <span class="comment">// Bounce off top/bottom walls</span>
    <span class="keyword">if</span> (position.y < <span class="number">0</span> || position.y > height) {
        velocity.y *= -<span class="number">1</span>;  <span class="comment">// Reverse vertical direction</span>
    }
}</code></pre>
                    </div>
                </details>
            </div>

            <div class="example-box">
                <h4>üéØ Exercise 3: Enemy Vision Cone</h4>
                <p>Detect if the player is within an enemy's field of view</p>
                <details>
                    <summary>Click for solution</summary>
                    <div class="code-container">
                        <pre><code><span class="keyword">function</span> <span class="function">canSeePlayer</span>(enemy, player, viewAngle, viewDistance) {
    <span class="comment">// 1. Check distance first (faster)</span>
    <span class="keyword">let</span> distance = enemy.position.<span class="function">distance</span>(player.position);
    <span class="keyword">if</span> (distance > viewDistance) <span class="keyword">return</span> <span class="keyword">false</span>;
    
    <span class="comment">// 2. Check if player is in view cone</span>
    <span class="keyword">let</span> toPlayer = player.position
        .<span class="function">subtract</span>(enemy.position)
        .<span class="function">normalize</span>();
    
    <span class="keyword">let</span> dotProduct = enemy.facing.<span class="function">dot</span>(toPlayer);
    <span class="keyword">let</span> angleThreshold = Math.<span class="function">cos</span>(viewAngle / <span class="number">2</span>);
    
    <span class="keyword">return</span> dotProduct > angleThreshold;
}</code></pre>
                    </div>
                </details>
            </div>
        </div>

        <div class="section" style="text-align: center; padding: 40px;">
            <h2>üéâ Congratulations!</h2>
            <p>You now understand the core math behind game development! These concepts are used in every game you've ever played.</p>
            <p style="margin-top: 30px; color: #9e9e9e;">Next steps: Try implementing these systems in your own game project!</p>
        </div>

        <!-- ====================================== -->
        <!-- PART 2: ADVANCED CONTENT FROM FILE 2 -->
        <!-- ====================================== -->
        
<!-- INTERMEDIATE LEVEL -->
        <div id="intermediate" class="section active">
            <span class="level-indicator level-intermediate">‚≠ê INTERMEDIATE LEVEL</span>
            
            <h2>üéØ Level 2: Practical Game Systems</h2>
            
            <p>You've learned vectors and matrices. Now let's build complete game systems that professionals use every day!</p>

            <!-- LERP Section -->
            <div id="lerp" class="concept-box">
                <h3>üåü Interpolation (Lerp) - Smooth Everything!</h3>
                <p>Lerp is arguably the MOST useful function in game development. It smoothly transitions between two values.</p>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Think About This First:</h4>
                <p>You have a camera at position A, and the player at position B. You want the camera to smoothly follow the player, not snap instantly. How would you calculate a position that's "partly" between A and B?</p>
                <details>
                    <summary>See the insight</summary>
                    <p>You need a value that's X% of the way from A to B. That's exactly what Lerp does!</p>
                    <p><strong>Formula:</strong> result = A + (B - A) √ó t</p>
                    <p>Where t is between 0 (at A) and 1 (at B)</p>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Lerp Implementation</div>
                <pre><code><span class="keyword">function</span> <span class="function">lerp</span>(start, end, t) {
    <span class="comment">// t = 0 returns start, t = 1 returns end</span>
    <span class="comment">// t = 0.5 returns the midpoint</span>
    <span class="keyword">return</span> start + (end - start) * t;
}

<span class="keyword">class</span> <span class="function">Vector2D</span> {
    <span class="comment">// ... previous methods ...</span>
    
    <span class="function">lerp</span>(target, t) {
        <span class="keyword">this</span>.x = <span class="function">lerp</span>(<span class="keyword">this</span>.x, target.x, t);
        <span class="keyword">this</span>.y = <span class="function">lerp</span>(<span class="keyword">this</span>.y, target.y, t);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Smooth Camera Follow</h4>
                <p>Implement a camera that smoothly follows the player. The camera should lag behind slightly, creating a cinematic effect.</p>
                
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>What value should 't' be for smooth following?</strong>
                    <ul>
                        <li>If t = 1, camera snaps instantly (no smoothness)</li>
                        <li>If t = 0, camera never moves</li>
                        <li>Try t = 0.1 for gentle following</li>
                    </ul>
                </div>
                
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Where should you call lerp?</strong>
                    <ul>
                        <li>In the camera's update() function</li>
                        <li>Every frame</li>
                        <li>camera.position.lerp(player.position, 0.1)</li>
                    </ul>
                </div>
            </div>

            <div class="diagram">
                <canvas id="lerpDemo" width="900" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="resetLerpDemo()">Reset</button>
                <label style="color: #fff; margin-left: 20px;">
                    Smoothness: <input type="range" id="lerpAmount" min="1" max="50" value="10" 
                    style="vertical-align: middle;" oninput="updateLerpAmount(this.value)">
                    <span id="lerpValue">0.10</span>
                </label>
            </div>
            <div id="lerpInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Notice how the camera (red) smoothly follows with a delay!</p>

            <!-- PHYSICS SYSTEM -->
            <h3 id="physics">‚öõÔ∏è Physics System - Make Things Move Realistically</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î Think: How Does Movement Actually Work?</h4>
                <p>Imagine pushing a box:</p>
                <ul>
                    <li>You apply a <strong>force</strong></li>
                    <li>The box gains <strong>velocity</strong></li>
                    <li>The velocity changes its <strong>position</strong></li>
                    <li>Friction slows it down</li>
                </ul>
                <p><strong>Question:</strong> If you're already moving at velocity V, and you apply a force F, what happens to your velocity?</p>
                <details>
                    <summary>Answer</summary>
                    <p>Your velocity <em>increases</em> by F! That's acceleration. velocity += force</p>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Physics Object Class</div>
                <pre><code><span class="keyword">class</span> <span class="function">PhysicsObject</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.acceleration = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.mass = <span class="number">1</span>;
        <span class="keyword">this</span>.friction = <span class="number">0.98</span>;  <span class="comment">// 0 = stops instantly, 1 = no friction</span>
    }
    
    <span class="function">applyForce</span>(force) {
        <span class="comment">// F = ma, so a = F/m</span>
        <span class="keyword">let</span> f = force.<span class="function">copy</span>();
        f.<span class="function">divide</span>(<span class="keyword">this</span>.mass);
        <span class="keyword">this</span>.acceleration.<span class="function">add</span>(f);
    }
    
    <span class="function">update</span>() {
        <span class="comment">// 1. Acceleration changes velocity</span>
        <span class="keyword">this</span>.velocity.<span class="function">add</span>(<span class="keyword">this</span>.acceleration);
        
        <span class="comment">// 2. Apply friction</span>
        <span class="keyword">this</span>.velocity.<span class="function">multiply</span>(<span class="keyword">this</span>.friction);
        
        <span class="comment">// 3. Velocity changes position</span>
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
        
        <span class="comment">// 4. Reset acceleration (must re-apply forces each frame!)</span>
        <span class="keyword">this</span>.acceleration.<span class="function">multiply</span>(<span class="number">0</span>);
    }
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Build a Spaceship Controller</h4>
                <p><strong>Requirements:</strong></p>
                <ul>
                    <li>W key: Apply thrust forward</li>
                    <li>A/D keys: Rotate ship</li>
                    <li>Physics automatically slows ship (no brakes in space!)</li>
                </ul>
                <p><strong>Hint:</strong> To apply thrust in the direction the ship is facing:</p>
                <details>
                    <summary>Show hint</summary>
                    <div class="code-container">
                        <pre><code><span class="comment">// Convert ship's angle to a direction vector</span>
<span class="keyword">let</span> thrustDir = <span class="keyword">new</span> <span class="function">Vector2D</span>(
    Math.<span class="function">cos</span>(ship.angle),
    Math.<span class="function">sin</span>(ship.angle)
);

<span class="comment">// Apply force in that direction</span>
<span class="keyword">let</span> thrust = thrustDir.<span class="function">multiply</span>(<span class="number">0.5</span>);
ship.<span class="function">applyForce</span>(thrust);</code></pre>
                    </div>
                </details>
            </div>

            <div class="diagram">
                <canvas id="physicsDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="resetPhysics()">Reset</button>
                <button onclick="addPlanet()">Add Gravity Well</button>
                <button onclick="toggleGravity()">Toggle Gravity</button>
            </div>
            <div id="physicsInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Use W/A/S/D to control the spaceship. Feel the realistic physics!</p>

            <!-- COLLISION DETECTION -->
            <h3 id="collision">üí• Collision Detection - When Things Hit</h3>
            
            <div class="concept-box">
                <p>There are many ways to check collisions. We'll build from simplest to most efficient!</p>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Design Question:</h4>
                <p>You have 100 enemies and 50 bullets. How many collision checks do you need to test if ANY bullet hits ANY enemy?</p>
                <ul>
                    <li>A) 150 checks</li>
                    <li>B) 5,000 checks (100 √ó 50)</li>
                    <li>C) Less than 5,000 with optimization</li>
                </ul>
                <details>
                    <summary>Answer + Why This Matters</summary>
                    <p><strong>Answer: B</strong> - You need to test every bullet against every enemy = 5,000 checks!</p>
                    <p>At 60 FPS, that's <strong>300,000 checks per second</strong>. This is why optimization matters!</p>
                    <p>In Level 4 (Expert), we'll reduce this to less than 100 checks using spatial partitioning.</p>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Circle Collision (Fastest)</div>
                <pre><code><span class="keyword">function</span> <span class="function">circleCollision</span>(obj1, obj2) {
    <span class="comment">// Calculate distance between centers</span>
    <span class="keyword">let</span> distance = obj1.position.<span class="function">distance</span>(obj2.position);
    
    <span class="comment">// If distance < sum of radii, they're touching!</span>
    <span class="keyword">let</span> minDistance = obj1.radius + obj2.radius;
    
    <span class="keyword">return</span> distance < minDistance;
}</code></pre>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Rectangle Collision (AABB)</div>
                <pre><code><span class="keyword">function</span> <span class="function">rectangleCollision</span>(rect1, rect2) {
    <span class="comment">// AABB = Axis-Aligned Bounding Box</span>
    <span class="comment">// Check if rectangles DON'T overlap, then negate</span>
    <span class="keyword">return</span> !(
        rect1.x + rect1.width < rect2.x ||   <span class="comment">// rect1 is left of rect2</span>
        rect1.x > rect2.x + rect2.width ||   <span class="comment">// rect1 is right of rect2</span>
        rect1.y + rect1.height < rect2.y ||  <span class="comment">// rect1 is above rect2</span>
        rect1.y > rect2.y + rect2.height     <span class="comment">// rect1 is below rect2</span>
    );
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Collision Response</h4>
                <p>Detection is only half the battle! When objects collide, they need to <strong>respond</strong>:</p>
                
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Separate overlapping objects</strong>
                    <p>If they're overlapping by 5 pixels, push them apart by 5 pixels</p>
                </div>
                
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Calculate collision normal</strong>
                    <p>The direction to push them apart (perpendicular to collision surface)</p>
                </div>
                
                <div class="step">
                    <span class="step-number">3</span>
                    <strong>Bounce velocity</strong>
                    <p>Reflect velocity across the normal</p>
                </div>

                <details>
                    <summary>Show complete collision response</summary>
                    <div class="code-container">
                        <pre><code><span class="keyword">function</span> <span class="function">handleCollision</span>(obj1, obj2) {
    <span class="comment">// 1. Get collision normal (from obj1 to obj2)</span>
    <span class="keyword">let</span> normal = obj2.position
        .<span class="function">subtract</span>(obj1.position)
        .<span class="function">normalize</span>();
    
    <span class="comment">// 2. Calculate overlap</span>
    <span class="keyword">let</span> distance = obj1.position.<span class="function">distance</span>(obj2.position);
    <span class="keyword">let</span> overlap = (obj1.radius + obj2.radius) - distance;
    
    <span class="comment">// 3. Separate objects</span>
    obj1.position.<span class="function">add</span>(normal.<span class="function">multiply</span>(-overlap / <span class="number">2</span>));
    obj2.position.<span class="function">add</span>(normal.<span class="function">multiply</span>(overlap / <span class="number">2</span>));
    
    <span class="comment">// 4. Bounce velocities</span>
    <span class="keyword">let</span> relativeVel = obj1.velocity.<span class="function">subtract</span>(obj2.velocity);
    <span class="keyword">let</span> velAlongNormal = relativeVel.<span class="function">dot</span>(normal);
    
    <span class="keyword">if</span> (velAlongNormal > <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// Moving apart already</span>
    
    <span class="keyword">let</span> restitution = <span class="number">0.8</span>; <span class="comment">// Bounciness (0-1)</span>
    <span class="keyword">let</span> impulse = -(1 + restitution) * velAlongNormal;
    impulse /= (<span class="number">1</span> / obj1.mass + <span class="number">1</span> / obj2.mass);
    
    <span class="keyword">let</span> impulseVector = normal.<span class="function">multiply</span>(impulse);
    obj1.velocity.<span class="function">add</span>(impulseVector.<span class="function">divide</span>(obj1.mass));
    obj2.velocity.<span class="function">subtract</span>(impulseVector.<span class="function">divide</span>(obj2.mass));
}</code></pre>
                    </div>
                </details>
            </div>

            <div class="diagram">
                <canvas id="collisionDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addBall()">Add Ball</button>
                <button onclick="clearBalls()">Clear All</button>
                <button onclick="toggleCollisionType()">Toggle Shape Type</button>
            </div>
            <div id="collisionInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Click to add balls. Watch them bounce realistically!</p>

            <!-- RAYCASTING -->
            <h3 id="raycasting">üî¶ Raycasting - Line of Sight & Shooting</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î Before We Code:</h4>
                <p>Imagine you're making a stealth game. How would you check if a guard can SEE the player?</p>
                <ul>
                    <li>Not enough to check distance (could be behind a wall!)</li>
                    <li>Not enough to check angle (could be blocked!)</li>
                    <li>What do you actually need to test?</li>
                </ul>
                <details>
                    <summary>Think about it...</summary>
                    <p>You need to cast a "ray" (imaginary line) from the guard to the player and check if any walls intersect that line!</p>
                    <p>This is called <strong>raycasting</strong> - it's how vision, shooting, and light work in games.</p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>Raycasting uses:</strong></p>
                <ul>
                    <li>Line of sight (Can enemy see player?)</li>
                    <li>Bullet trajectories (What did I hit?)</li>
                    <li>Mouse picking (What object did I click?)</li>
                    <li>Light rays (Shadows and reflections)</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Ray-Line Intersection (The Core Algorithm)</div>
                <pre><code><span class="keyword">function</span> <span class="function">rayIntersectsLine</span>(rayOrigin, rayDir, lineStart, lineEnd) {
    <span class="comment">// Ray equation: P = rayOrigin + t * rayDir</span>
    <span class="comment">// Line equation: P = lineStart + u * (lineEnd - lineStart)</span>
    <span class="comment">// We need to solve for t and u</span>
    
    <span class="keyword">let</span> v1 = rayOrigin.<span class="function">subtract</span>(lineStart);
    <span class="keyword">let</span> v2 = lineEnd.<span class="function">subtract</span>(lineStart);
    <span class="keyword">let</span> v3 = <span class="keyword">new</span> <span class="function">Vector2D</span>(-rayDir.y, rayDir.x);  <span class="comment">// Perpendicular to ray</span>
    
    <span class="keyword">let</span> dot = v2.<span class="function">dot</span>(v3);
    <span class="keyword">if</span> (Math.<span class="function">abs</span>(dot) < <span class="number">0.000001</span>) <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// Parallel!</span>
    
    <span class="keyword">let</span> t = v2.<span class="function">cross</span>(v1) / dot;  <span class="comment">// Distance along ray</span>
    <span class="keyword">let</span> u = v1.<span class="function">dot</span>(v3) / dot;     <span class="comment">// Position on line segment</span>
    
    <span class="comment">// Check if intersection is valid</span>
    <span class="keyword">if</span> (t >= <span class="number">0</span> && u >= <span class="number">0</span> && u <= <span class="number">1</span>) {
        <span class="keyword">return</span> {
            point: rayOrigin.<span class="function">add</span>(rayDir.<span class="function">multiply</span>(t)),
            distance: t
        };
    }
    
    <span class="keyword">return</span> <span class="keyword">null</span>;
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Build a Vision System</h4>
                <p><strong>Problem:</strong> An enemy should only detect the player if:</p>
                <ol>
                    <li>Player is within view distance</li>
                    <li>Player is within view cone (field of view)</li>
                    <li>No walls block the line of sight</li>
                </ol>
                <p><strong>How would you structure this check?</strong></p>
                <details>
                    <summary>Show solution approach</summary>
                    <div class="step">
                        <span class="step-number">1</span>
                        <strong>Distance check (fastest, check first)</strong>
                        <p>If distance > viewRange, return false immediately</p>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <strong>Angle check (use dot product)</strong>
                        <p>If dotProduct(enemyFacing, toPlayer) < threshold, return false</p>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <strong>Raycast check (most expensive, do last)</strong>
                        <p>Cast ray from enemy to player, check wall intersections</p>
                    </div>
                </details>
            </div>

            <div class="diagram">
                <canvas id="raycastDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addWall()">Add Wall</button>
                <button onclick="clearWalls()">Clear Walls</button>
                <button onclick="toggleRayVisualization()">Toggle All Rays</button>
            </div>
            <div id="raycastInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Red rays = blocked, Green rays = clear line of sight!</p>

            <!-- PARTICLE SYSTEMS -->
            <h3 id="particles">‚ú® Particle Systems - Explosions, Fire, Smoke</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î Design Challenge:</h4>
                <p>You want to create an explosion effect with 1000 particles. Each particle needs to:</p>
                <ul>
                    <li>Start at the explosion center</li>
                    <li>Fly outward in all directions</li>
                    <li>Be affected by gravity</li>
                    <li>Fade out over time</li>
                </ul>
                <p><strong>Question:</strong> What data does EACH particle need to store?</p>
                <details>
                    <summary>Think through it...</summary>
                    <p><strong>Particle needs:</strong></p>
                    <ul>
                        <li><code>position</code> - where it is</li>
                        <li><code>velocity</code> - how fast it's moving</li>
                        <li><code>acceleration</code> - gravity and forces</li>
                        <li><code>life</code> - how long until it disappears</li>
                        <li><code>color</code> - visual appearance</li>
                        <li><code>size</code> - can shrink over time</li>
                    </ul>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Particle Emitter System</div>
                <pre><code><span class="keyword">class</span> <span class="function">ParticleEmitter</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.particles = [];
    }
    
    <span class="function">emit</span>(count, config) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < count; i++) {
            <span class="keyword">let</span> angle = Math.<span class="function">random</span>() * Math.PI * <span class="number">2</span>;
            <span class="keyword">let</span> speed = config.speed + Math.<span class="function">random</span>() * config.speedVariation;
            
            <span class="keyword">let</span> particle = {
                position: <span class="keyword">this</span>.position.<span class="function">copy</span>(),
                velocity: <span class="keyword">new</span> <span class="function">Vector2D</span>(
                    Math.<span class="function">cos</span>(angle) * speed,
                    Math.<span class="function">sin</span>(angle) * speed
                ),
                acceleration: config.gravity.<span class="function">copy</span>(),
                life: config.lifetime,
                maxLife: config.lifetime,
                size: config.size,
                color: config.color
            };
            
            <span class="keyword">this</span>.particles.<span class="function">push</span>(particle);
        }
    }
    
    <span class="function">update</span>() {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.particles.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
            <span class="keyword">let</span> p = <span class="keyword">this</span>.particles[i];
            
            <span class="comment">// Physics</span>
            p.velocity.<span class="function">add</span>(p.acceleration);
            p.position.<span class="function">add</span>(p.velocity);
            
            <span class="comment">// Aging</span>
            p.life--;
            
            <span class="comment">// Remove dead particles</span>
            <span class="keyword">if</span> (p.life <= <span class="number">0</span>) {
                <span class="keyword">this</span>.particles.<span class="function">splice</span>(i, <span class="number">1</span>);
            }
        }
    }
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Effect Presets</h4>
                <p>Different particle configs create different effects:</p>
                <table>
                    <tr>
                        <th>Effect</th>
                        <th>Speed</th>
                        <th>Gravity</th>
                        <th>Lifetime</th>
                        <th>Color</th>
                    </tr>
                    <tr>
                        <td><strong>Explosion</strong></td>
                        <td>High (8-12)</td>
                        <td>Down (0.2)</td>
                        <td>Short (30-60)</td>
                        <td>Orange‚ÜíRed</td>
                    </tr>
                    <tr>
                        <td><strong>Fire</strong></td>
                        <td>Low (1-2)</td>
                        <td>Up (-0.1)</td>
                        <td>Medium (40-80)</td>
                        <td>Yellow‚ÜíRed</td>
                    </tr>
                    <tr>
                        <td><strong>Smoke</strong></td>
                        <td>Very Low (0.5)</td>
                        <td>Up (-0.05)</td>
                        <td>Long (100-200)</td>
                        <td>Gray</td>
                    </tr>
                    <tr>
                        <td><strong>Sparks</strong></td>
                        <td>High (6-10)</td>
                        <td>Down (0.3)</td>
                        <td>Short (20-40)</td>
                        <td>White‚ÜíYellow</td>
                    </tr>
                </table>
            </div>

            <div class="diagram">
                <canvas id="particleSystemDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="setParticleEffect('explosion')">Explosion</button>
                <button onclick="setParticleEffect('fire')">Fire</button>
                <button onclick="setParticleEffect('smoke')">Smoke</button>
                <button onclick="setParticleEffect('sparks')">Sparks</button>
                <button onclick="setParticleEffect('fountain')">Fountain</button>
            </div>
            <div id="particleSystemInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Click anywhere to spawn particles!</p>
        </div>

        <!-- ADVANCED LEVEL -->
        <div id="advanced" class="section">
            <span class="level-indicator level-advanced">‚≠ê‚≠ê ADVANCED LEVEL</span>
            
            <h2>üöÄ Level 3: Advanced Techniques</h2>
            
            <p>Ready for professional game development techniques? Let's tackle rotation, steering behaviors, and curves!</p>

            <!-- QUATERNIONS -->
            <h3 id="quaternions">üîÑ Quaternions - 3D Rotation Done Right</h3>
            
            <div class="concept-box">
                <p><strong>The Problem with Euler Angles:</strong></p>
                <ul>
                    <li>Gimbal lock (you lose a degree of freedom)</li>
                    <li>Can't smoothly interpolate between rotations</li>
                    <li>Order matters (rotate X then Y ‚â† rotate Y then X)</li>
                </ul>
                <p><strong>The Solution:</strong> Quaternions! They're 4D numbers that represent 3D rotations perfectly.</p>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Conceptual Challenge:</h4>
                <p>Imagine you want to smoothly rotate a spaceship from facing North to facing South. Using Euler angles, it might spin wildly through East or West. How can we ensure it takes the shortest path?</p>
                <details>
                    <summary>The Insight</summary>
                    <p>Quaternions encode rotation as an axis and an angle around that axis. The shortest rotation from North to South is around the vertical axis - quaternions automatically find this!</p>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Quaternion Class (Simplified)</div>
                <pre><code><span class="keyword">class</span> <span class="function">Quaternion</span> {
    <span class="keyword">constructor</span>(x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>, w = <span class="number">1</span>) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
        <span class="keyword">this</span>.z = z;
        <span class="keyword">this</span>.w = w;  <span class="comment">// w is the "real" part</span>
    }
    
    <span class="comment">// Create from axis-angle</span>
    <span class="keyword">static</span> <span class="function">fromAxisAngle</span>(axis, angle) {
        <span class="keyword">let</span> halfAngle = angle / <span class="number">2</span>;
        <span class="keyword">let</span> s = Math.<span class="function">sin</span>(halfAngle);
        
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            axis.x * s,
            axis.y * s,
            axis.z * s,
            Math.<span class="function">cos</span>(halfAngle)
        );
    }
    
    <span class="comment">// Multiply quaternions (combine rotations)</span>
    <span class="function">multiply</span>(q) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            <span class="keyword">this</span>.w * q.x + <span class="keyword">this</span>.x * q.w + <span class="keyword">this</span>.y * q.z - <span class="keyword">this</span>.z * q.y,
            <span class="keyword">this</span>.w * q.y - <span class="keyword">this</span>.x * q.z + <span class="keyword">this</span>.y * q.w + <span class="keyword">this</span>.z * q.x,
            <span class="keyword">this</span>.w * q.z + <span class="keyword">this</span>.x * q.y - <span class="keyword">this</span>.y * q.x + <span class="keyword">this</span>.z * q.w,
            <span class="keyword">this</span>.w * q.w - <span class="keyword">this</span>.x * q.x - <span class="keyword">this</span>.y * q.y - <span class="keyword">this</span>.z * q.z
        );
    }
    
    <span class="comment">// SLERP - Spherical Linear Interpolation (smooth rotation)</span>
    <span class="function">slerp</span>(target, t) {
        <span class="keyword">let</span> dot = <span class="keyword">this</span>.x * target.x + <span class="keyword">this</span>.y * target.y + 
                  <span class="keyword">this</span>.z * target.z + <span class="keyword">this</span>.w * target.w;
        
        <span class="comment">// If negative dot, negate one quaternion to take shorter path</span>
        <span class="keyword">if</span> (dot < <span class="number">0</span>) {
            target = <span class="keyword">new</span> <span class="function">Quaternion</span>(-target.x, -target.y, -target.z, -target.w);
            dot = -dot;
        }
        
        <span class="keyword">let</span> theta = Math.<span class="function">acos</span>(dot);
        <span class="keyword">let</span> sinTheta = Math.<span class="function">sin</span>(theta);
        
        <span class="keyword">let</span> w1 = Math.<span class="function">sin</span>((<span class="number">1</span> - t) * theta) / sinTheta;
        <span class="keyword">let</span> w2 = Math.<span class="function">sin</span>(t * theta) / sinTheta;
        
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            <span class="keyword">this</span>.x * w1 + target.x * w2,
            <span class="keyword">this</span>.y * w1 + target.y * w2,
            <span class="keyword">this</span>.z * w1 + target.z * w2,
            <span class="keyword">this</span>.w * w1 + target.w * w2
        );
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="quaternionDemo" width="900" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="setRotationType('euler')">Euler Angles</button>
                <button onclick="setRotationType('quaternion')">Quaternions (Smooth!)</button>
                <button onclick="randomTarget()">New Target Rotation</button>
            </div>
            <div id="quaternionInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Watch how quaternions take the shortest rotation path!</p>

            <!-- STEERING BEHAVIORS -->
            <h3 id="steering">üéØ Steering Behaviors - Intelligent Movement</h3>
            
            <div class="concept-box">
                <p>Steering behaviors create realistic, autonomous movement. Instead of telling an agent exactly where to go, you give it <strong>desires</strong> (seek target, avoid obstacles, stay with flock).</p>
            </div>

            <div class="challenge-box">
                <h4>üéØ Build These Behaviors:</h4>
                <ol>
                    <li><strong>Seek:</strong> Move toward a target</li>
                    <li><strong>Flee:</strong> Move away from a danger</li>
                    <li><strong>Arrive:</strong> Seek but slow down as you approach</li>
                    <li><strong>Wander:</strong> Move in random directions (exploration)</li>
                    <li><strong>Pursue:</strong> Predict where target will be and head there</li>
                    <li><strong>Evade:</strong> Predict where danger will be and avoid it</li>
                </ol>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Steering Behaviors Class</div>
                <pre><code><span class="keyword">class</span> <span class="function">SteeringAgent</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.maxSpeed = <span class="number">4</span>;
        <span class="keyword">this</span>.maxForce = <span class="number">0.2</span>;  <span class="comment">// How quickly it can change direction</span>
    }
    
    <span class="comment">// Core steering function</span>
    <span class="function">seek</span>(target) {
        <span class="comment">// 1. Calculate desired velocity (direct path to target)</span>
        <span class="keyword">let</span> desired = target.<span class="function">subtract</span>(<span class="keyword">this</span>.position);
        desired.<span class="function">normalize</span>();
        desired.<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);
        
        <span class="comment">// 2. Steering = desired - current velocity</span>
        <span class="keyword">let</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);  <span class="comment">// Don't turn too sharply!</span>
        
        <span class="keyword">return</span> steer;
    }
    
    <span class="function">flee</span>(target) {
        <span class="comment">// Same as seek, but opposite direction!</span>
        <span class="keyword">let</span> desired = <span class="keyword">this</span>.position.<span class="function">subtract</span>(target);
        desired.<span class="function">normalize</span>();
        desired.<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);
        
        <span class="keyword">let</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);
        
        <span class="keyword">return</span> steer;
    }
    
    <span class="function">arrive</span>(target, slowingRadius = <span class="number">100</span>) {
        <span class="keyword">let</span> desired = target.<span class="function">subtract</span>(<span class="keyword">this</span>.position);
        <span class="keyword">let</span> distance = desired.<span class="function">length</span>();
        
        desired.<span class="function">normalize</span>();
        
        <span class="comment">// If close to target, slow down!</span>
        <span class="keyword">if</span> (distance < slowingRadius) {
            <span class="keyword">let</span> speed = <span class="keyword">this</span>.maxSpeed * (distance / slowingRadius);
            desired.<span class="function">multiply</span>(speed);
        } <span class="keyword">else</span> {
            desired.<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);
        }
        
        <span class="keyword">let</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);
        
        <span class="keyword">return</span> steer;
    }
    
    <span class="function">pursue</span>(target) {
        <span class="comment">// Predict where target will be!</span>
        <span class="keyword">let</span> distance = target.position.<span class="function">distance</span>(<span class="keyword">this</span>.position);
        <span class="keyword">let</span> prediction = distance / <span class="keyword">this</span>.maxSpeed;
        
        <span class="keyword">let</span> futurePos = target.position.<span class="function">copy</span>();
        futurePos.<span class="function">add</span>(target.velocity.<span class="function">multiply</span>(prediction));
        
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">seek</span>(futurePos);
    }
    
    <span class="function">applyForce</span>(force) {
        <span class="keyword">this</span>.velocity.<span class="function">add</span>(force);
        <span class="keyword">this</span>.velocity.<span class="function">limit</span>(<span class="keyword">this</span>.maxSpeed);
    }
    
    <span class="function">update</span>() {
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
    }
}</code></pre>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Design Challenge: Flocking</h4>
                <p>Birds flock together using just 3 simple rules. Can you figure out what they might be?</p>
                <details>
                    <summary>The Three Rules</summary>
                    <ol>
                        <li><strong>Separation:</strong> Avoid crowding neighbors</li>
                        <li><strong>Alignment:</strong> Steer toward average heading of neighbors</li>
                        <li><strong>Cohesion:</strong> Steer toward average position of neighbors</li>
                    </ol>
                    <p>Combine these three forces, and you get emergent flocking behavior!</p>
                </details>
            </div>

            <div class="diagram">
                <canvas id="steeringDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="setBehavior('seek')">Seek</button>
                <button onclick="setBehavior('flee')">Flee</button>
                <button onclick="setBehavior('arrive')">Arrive</button>
                <button onclick="setBehavior('pursue')">Pursue</button>
                <button onclick="setBehavior('wander')">Wander</button>
                <button onclick="setBehavior('flock')">Flock!</button>
                <button onclick="addAgent()">Add Agent</button>
            </div>
            <div id="steeringInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse to set the target. Watch different behaviors!</p>

            <!-- BEZIER CURVES -->
            <h3 id="bezier">üìà B√©zier Curves - Smooth Paths</h3>
            
            <div class="concept-box">
                <p>B√©zier curves create smooth paths between points. They're used for:</p>
                <ul>
                    <li>Camera movement paths</li>
                    <li>Enemy patrol routes</li>
                    <li>Trajectory prediction</li>
                    <li>Animation curves</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Cubic B√©zier Curve</div>
                <pre><code><span class="keyword">function</span> <span class="function">cubicBezier</span>(p0, p1, p2, p3, t) {
    <span class="comment">// p0 and p3 are start/end points</span>
    <span class="comment">// p1 and p2 are control points</span>
    <span class="comment">// t is between 0 (start) and 1 (end)</span>
    
    <span class="keyword">let</span> u = <span class="number">1</span> - t;
    <span class="keyword">let</span> tt = t * t;
    <span class="keyword">let</span> uu = u * u;
    <span class="keyword">let</span> uuu = uu * u;
    <span class="keyword">let</span> ttt = tt * t;
    
    <span class="keyword">let</span> point = p0.<span class="function">multiply</span>(uuu);           <span class="comment">// (1-t)¬≥ * P0</span>
    point.<span class="function">add</span>(p1.<span class="function">multiply</span>(<span class="number">3</span> * uu * t));  <span class="comment">// 3(1-t)¬≤ * t * P1</span>
    point.<span class="function">add</span>(p2.<span class="function">multiply</span>(<span class="number">3</span> * u * tt)); <span class="comment">// 3(1-t) * t¬≤ * P2</span>
    point.<span class="function">add</span>(p3.<span class="function">multiply</span>(ttt));           <span class="comment">// t¬≥ * P3</span>
    
    <span class="keyword">return</span> point;
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Path Following</h4>
                <p>Make an object smoothly follow a B√©zier curve path. This is harder than it looks!</p>
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Problem:</strong> If you increment t by a fixed amount each frame, the object will speed up and slow down (because B√©zier curves aren't evenly spaced)
                </div>
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Solution:</strong> Calculate the curve length and adjust t to maintain constant speed
                </div>
            </div>

            <div class="diagram">
                <canvas id="bezierDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="resetBezier()">Reset</button>
                <button onclick="addBezierPoint()">Add Control Point</button>
                <button onclick="toggleAnimation()">Start/Stop Animation</button>
            </div>
            <p style="text-align: center; color: #9e9e9e;">Drag the control points to shape the curve!</p>

            <!-- PATHFINDING -->
            <h3 id="pathfinding">üó∫Ô∏è Pathfinding - A* Algorithm</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Pathfinding Problem:</h4>
                <p>You have a grid world with obstacles. An NPC needs to find the shortest path from point A to point B.</p>
                <p><strong>Bad approach:</strong> Try every possible path ‚Üí takes forever!</p>
                <p><strong>Smart approach:</strong> Only explore paths that look promising. But how do you know which paths are "promising"?</p>
                <details>
                    <summary>The Insight</summary>
                    <p>Use a <strong>heuristic</strong> (educated guess) to estimate remaining distance to goal!</p>
                    <p><strong>A* formula:</strong> f(n) = g(n) + h(n)</p>
                    <ul>
                        <li><strong>g(n)</strong> = actual cost from start to current node</li>
                        <li><strong>h(n)</strong> = estimated cost from current to goal (heuristic)</li>
                        <li><strong>f(n)</strong> = total estimated cost</li>
                    </ul>
                    <p>Always explore the node with lowest f(n) first!</p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>A* guarantees:</strong></p>
                <ul>
                    <li>‚úÖ Finds the shortest path (if one exists)</li>
                    <li>‚úÖ Much faster than brute force (Dijkstra)</li>
                    <li>‚úÖ The better your heuristic, the faster it runs</li>
                </ul>
                <p><strong>Common heuristics:</strong></p>
                <ul>
                    <li><strong>Manhattan distance</strong> (grid movement): |x1-x2| + |y1-y2|</li>
                    <li><strong>Euclidean distance</strong> (diagonal movement): ‚àö((x1-x2)¬≤ + (y1-y2)¬≤)</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù A* Algorithm Implementation</div>
                <pre><code><span class="keyword">function</span> <span class="function">aStar</span>(start, goal, grid) {
    <span class="keyword">let</span> openSet = [start];
    <span class="keyword">let</span> closedSet = [];
    <span class="keyword">let</span> cameFrom = <span class="keyword">new</span> Map();
    
    <span class="keyword">let</span> gScore = <span class="keyword">new</span> Map();
    gScore.<span class="function">set</span>(start, <span class="number">0</span>);
    
    <span class="keyword">let</span> fScore = <span class="keyword">new</span> Map();
    fScore.<span class="function">set</span>(start, <span class="function">heuristic</span>(start, goal));
    
    <span class="keyword">while</span> (openSet.length > <span class="number">0</span>) {
        <span class="keyword">let</span> current = openSet.<span class="function">reduce</span>((best, node) => 
            fScore.<span class="function">get</span>(node) < fScore.<span class="function">get</span>(best) ? node : best
        );
        
        <span class="keyword">if</span> (current === goal) {
            <span class="keyword">return</span> <span class="function">reconstructPath</span>(cameFrom, current);
        }
        
        openSet = openSet.<span class="function">filter</span>(n => n !== current);
        closedSet.<span class="function">push</span>(current);
        
        <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> <span class="function">getNeighbors</span>(current, grid)) {
            <span class="keyword">if</span> (closedSet.<span class="function">includes</span>(neighbor)) <span class="keyword">continue</span>;
            
            <span class="keyword">let</span> tentativeG = gScore.<span class="function">get</span>(current) + <span class="number">1</span>;
            
            <span class="keyword">if</span> (!openSet.<span class="function">includes</span>(neighbor)) {
                openSet.<span class="function">push</span>(neighbor);
            } <span class="keyword">else if</span> (tentativeG >= gScore.<span class="function">get</span>(neighbor)) {
                <span class="keyword">continue</span>;
            }
            
            cameFrom.<span class="function">set</span>(neighbor, current);
            gScore.<span class="function">set</span>(neighbor, tentativeG);
            fScore.<span class="function">set</span>(neighbor, tentativeG + <span class="function">heuristic</span>(neighbor, goal));
        }
    }
    
    <span class="keyword">return</span> <span class="keyword">null</span>;
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="pathfindingDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="setPathMode('start')">Set Start</button>
                <button onclick="setPathMode('goal')">Set Goal</button>
                <button onclick="setPathMode('wall')">Draw Walls</button>
                <button onclick="findPath()">Find Path!</button>
                <button onclick="clearPathfinding()">Clear</button>
            </div>
            <div id="pathfindingInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Set start (green) and goal (red), draw walls, then find the path! Watch A* explore!</p>

            <!-- STATE MACHINES -->
            <h3 id="statemachines">ü§ñ State Machines - AI That Makes Decisions</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The AI Problem:</h4>
                <p>You're making an enemy guard. It should:</p>
                <ul>
                    <li><strong>Patrol</strong> when everything is normal</li>
                    <li><strong>Chase</strong> when it sees the player</li>
                    <li><strong>Attack</strong> when close to player</li>
                    <li><strong>Return</strong> to patrol after losing player</li>
                </ul>
                <p><strong>Bad approach:</strong> Giant if-else chain ‚Üí spaghetti code!</p>
                <p><strong>Smart approach:</strong> State Machine ‚Üí clean, organized behavior</p>
            </div>

            <div class="code-container">
                <div class="code-header">üìù State Machine Implementation</div>
                <pre><code><span class="keyword">class</span> <span class="function">StateMachine</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.states = <span class="keyword">new</span> Map();
        <span class="keyword">this</span>.currentState = <span class="keyword">null</span>;
    }
    
    <span class="function">setState</span>(name) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.currentState) {
            <span class="keyword">this</span>.currentState.<span class="function">exit</span>();
        }
        <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.states.<span class="function">get</span>(name);
        <span class="keyword">if</span> (<span class="keyword">this</span>.currentState) {
            <span class="keyword">this</span>.currentState.<span class="function">enter</span>();
        }
    }
    
    <span class="function">update</span>(entity) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.currentState) {
            <span class="keyword">this</span>.currentState.<span class="function">update</span>(entity);
            <span class="keyword">let</span> newState = <span class="keyword">this</span>.currentState.<span class="function">checkTransitions</span>(entity);
            <span class="keyword">if</span> (newState) <span class="keyword">this</span>.<span class="function">setState</span>(newState);
        }
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="stateMachineDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addGuard()">Add Guard</button>
            </div>
            <div id="stateMachineInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Watch guards patrol, chase, and attack based on their state!</p>

            <!-- INVERSE KINEMATICS -->
            <h3 id="ik">ü¶æ Inverse Kinematics - Realistic Joint Movement</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Animation Problem:</h4>
                <p>You have a character's arm with shoulder, elbow, and hand. You want the hand to reach a target (like picking up an object).</p>
                <p><strong>Forward Kinematics (easy):</strong> Rotate shoulder ‚Üí elbow moves ‚Üí hand moves</p>
                <p>But you know where the HAND should be, not the angles!</p>
                <p><strong>Inverse Kinematics (hard):</strong> Given hand position ‚Üí calculate shoulder & elbow angles</p>
                <p><strong>Why is this hard?</strong></p>
                <details>
                    <summary>The Challenge</summary>
                    <p>Multiple solutions exist! Same hand position can be reached with different joint angles.</p>
                    <p>Plus, the target might be unreachable (too far away)!</p>
                    <p>We'll use the <strong>FABRIK algorithm</strong> (Forward And Backward Reaching IK) - it's fast and works great for games.</p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>FABRIK Algorithm:</strong></p>
                <ol>
                    <li><strong>Forward pass:</strong> Start from end, pull each joint toward target</li>
                    <li><strong>Backward pass:</strong> Start from base, restore correct bone lengths</li>
                    <li><strong>Repeat:</strong> Until close enough (usually 2-5 iterations)</li>
                </ol>
                <p><strong>Uses in games:</strong></p>
                <ul>
                    <li>Character animation (feet on uneven ground)</li>
                    <li>Robotic arms and mechanical systems</li>
                    <li>Creature tentacles and tails</li>
                    <li>Aiming systems (gun pointing)</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù FABRIK Implementation</div>
                <pre><code><span class="keyword">class</span> <span class="function">IKChain</span> {
    <span class="keyword">constructor</span>(base, lengths) {
        <span class="keyword">this</span>.base = base;           <span class="comment">// Fixed starting point</span>
        <span class="keyword">this</span>.lengths = lengths;     <span class="comment">// Length of each bone</span>
        <span class="keyword">this</span>.joints = [];          <span class="comment">// Joint positions</span>
        
        <span class="comment">// Initialize chain pointing right</span>
        <span class="keyword">let</span> x = base.x;
        <span class="keyword">for</span> (<span class="keyword">let</span> len <span class="keyword">of</span> lengths) {
            <span class="keyword">this</span>.joints.<span class="function">push</span>(<span class="keyword">new</span> <span class="function">Vector2D</span>(x, base.y));
            x += len;
        }
        <span class="keyword">this</span>.joints.<span class="function">push</span>(<span class="keyword">new</span> <span class="function">Vector2D</span>(x, base.y)); <span class="comment">// End effector</span>
    }
    
    <span class="function">solve</span>(target, iterations = <span class="number">10</span>) {
        <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter < iterations; iter++) {
            <span class="comment">// Check if already close enough</span>
            <span class="keyword">let</span> endPos = <span class="keyword">this</span>.joints[<span class="keyword">this</span>.joints.length - <span class="number">1</span>];
            <span class="keyword">if</span> (endPos.<span class="function">distance</span>(target) < <span class="number">0.1</span>) <span class="keyword">break</span>;
            
            <span class="comment">// FORWARD: Pull from end toward target</span>
            <span class="keyword">this</span>.joints[<span class="keyword">this</span>.joints.length - <span class="number">1</span>] = target.<span class="function">copy</span>();
            
            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.joints.length - <span class="number">2</span>; i >= <span class="number">0</span>; i--) {
                <span class="keyword">let</span> direction = <span class="keyword">this</span>.joints[i].<span class="function">subtract</span>(<span class="keyword">this</span>.joints[i + <span class="number">1</span>]);
                direction.<span class="function">normalize</span>();
                direction.<span class="function">multiply</span>(<span class="keyword">this</span>.lengths[i] || <span class="keyword">this</span>.lengths[<span class="keyword">this</span>.lengths.length - <span class="number">1</span>]);
                <span class="keyword">this</span>.joints[i] = <span class="keyword">this</span>.joints[i + <span class="number">1</span>].<span class="function">copy</span>().<span class="function">add</span>(direction);
            }
            
            <span class="comment">// BACKWARD: Restore base and bone lengths</span>
            <span class="keyword">this</span>.joints[<span class="number">0</span>] = <span class="keyword">this</span>.base.<span class="function">copy</span>();
            
            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="keyword">this</span>.joints.length - <span class="number">1</span>; i++) {
                <span class="keyword">let</span> direction = <span class="keyword">this</span>.joints[i + <span class="number">1</span>].<span class="function">subtract</span>(<span class="keyword">this</span>.joints[i]);
                direction.<span class="function">normalize</span>();
                direction.<span class="function">multiply</span>(<span class="keyword">this</span>.lengths[i]);
                <span class="keyword">this</span>.joints[i + <span class="number">1</span>] = <span class="keyword">this</span>.joints[i].<span class="function">copy</span>().<span class="function">add</span>(direction);
            }
        }
    }
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Add Constraints</h4>
                <p>Basic IK works, but joints can bend in unnatural ways (elbows backward!)</p>
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Add angle limits</strong>
                    <p>Each joint should only rotate within a certain range (e.g., elbow: 0¬∞ to 150¬∞)</p>
                </div>
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Add preferred angles</strong>
                    <p>If multiple solutions exist, choose the one closest to a "rest pose"</p>
                </div>
                <details>
                    <summary>Implementation hint</summary>
                    <p>After each iteration, check the angle between bones. If outside limits, clamp it!</p>
                    <div class="code-container">
                        <pre><code><span class="keyword">let</span> angle = Math.<span class="function">atan2</span>(dir.y, dir.x);
<span class="keyword">let</span> minAngle = -Math.PI / <span class="number">2</span>;
<span class="keyword">let</span> maxAngle = Math.PI / <span class="number">2</span>;
angle = Math.<span class="function">max</span>(minAngle, Math.<span class="function">min</span>(maxAngle, angle));</code></pre>
                    </div>
                </details>
            </div>

            <div class="diagram">
                <canvas id="ikDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addIKChain()">Add Arm</button>
                <button onclick="toggleIKConstraints()">Toggle Constraints</button>
                <button onclick="clearIK()">Clear</button>
            </div>
            <div id="ikInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse. Watch the robotic arms reach for it!</p>

            <!-- SHADOW CASTING -->
            <h3 id="shadows">üí° Shadow Casting - 2D Dynamic Lighting</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Lighting Problem:</h4>
                <p>You have a light source and some walls. How do you calculate what's lit and what's in shadow?</p>
                <p><strong>Naive approach:</strong> Raycast every pixel ‚Üí 1920√ó1080 = 2 million rays!</p>
                <p><strong>Smart approach:</strong> Only cast rays toward wall corners!</p>
                <p><strong>Why corners?</strong></p>
                <details>
                    <summary>The Insight</summary>
                    <p>Shadows only change direction at wall corners (vertices)!</p>
                    <p>Algorithm: Cast a ray to each vertex, slightly left and slightly right. This catches the shadow boundaries perfectly.</p>
                    <p>2 million rays ‚Üí ~50 rays = <strong>40,000√ó faster!</strong></p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>Shadow Casting Algorithm:</strong></p>
                <ol>
                    <li>Find all wall vertices visible from light</li>
                    <li>Sort vertices by angle from light</li>
                    <li>Cast rays: to each vertex ¬± small angle offset</li>
                    <li>Connect ray endpoints to form lit polygon</li>
                    <li>Everything outside polygon is shadow</li>
                </ol>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Shadow Casting Core</div>
                <pre><code><span class="keyword">function</span> <span class="function">castShadows</span>(lightPos, walls) {
    <span class="keyword">let</span> rays = [];
    
    <span class="comment">// Collect all vertices</span>
    <span class="keyword">let</span> vertices = [];
    <span class="keyword">for</span> (<span class="keyword">let</span> wall <span class="keyword">of</span> walls) {
        vertices.<span class="function">push</span>(wall.start, wall.end);
    }
    
    <span class="comment">// Calculate angle to each vertex</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> vertex <span class="keyword">of</span> vertices) {
        <span class="keyword">let</span> angle = Math.<span class="function">atan2</span>(
            vertex.y - lightPos.y,
            vertex.x - lightPos.x
        );
        
        <span class="comment">// Cast 3 rays: at vertex, slightly left, slightly right</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> offset <span class="keyword">of</span> [-<span class="number">0.0001</span>, <span class="number">0</span>, <span class="number">0.0001</span>]) {
            <span class="keyword">let</span> rayAngle = angle + offset;
            <span class="keyword">let</span> rayDir = <span class="keyword">new</span> <span class="function">Vector2D</span>(
                Math.<span class="function">cos</span>(rayAngle),
                Math.<span class="function">sin</span>(rayAngle)
            );
            
            <span class="comment">// Find closest intersection</span>
            <span class="keyword">let</span> closest = <span class="function">castRayToWalls</span>(lightPos, rayDir, walls);
            <span class="keyword">if</span> (closest) {
                rays.<span class="function">push</span>({ angle: rayAngle, point: closest });
            }
        }
    }
    
    <span class="comment">// Sort by angle</span>
    rays.<span class="function">sort</span>((a, b) => a.angle - b.angle);
    
    <span class="keyword">return</span> rays;
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Real Game Uses:</h4>
                <ul>
                    <li><strong>Stealth games:</strong> Players hide in shadows, guards have flashlights</li>
                    <li><strong>Top-down games:</strong> Dynamic day/night cycle</li>
                    <li><strong>Horror games:</strong> Atmospheric lighting effects</li>
                    <li><strong>Strategy games:</strong> Fog of war based on unit vision</li>
                </ul>
            </div>

            <div class="diagram">
                <canvas id="shadowDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addShadowWall()">Add Wall</button>
                <button onclick="clearShadowWalls()">Clear Walls</button>
                <button onclick="toggleShadowRays()">Show Rays</button>
            </div>
            <div id="shadowInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Move your mouse (light source). Watch shadows update in real-time!</p>
        </div>

        <!-- EXPERT LEVEL -->
        <div id="expert" class="section">
            <span class="level-indicator level-expert">‚≠ê‚≠ê‚≠ê EXPERT LEVEL</span>
            
            <h2>‚ö° Level 4: Optimization & Advanced Algorithms</h2>
            
            <p>Welcome to professional game development! These techniques make the difference between 20 FPS and 144 FPS.</p>

            <!-- SPATIAL HASHING -->
            <h3 id="spatial">üó∫Ô∏è Spatial Partitioning - Make Collisions O(1) Instead of O(n¬≤)</h3>
            
            <div class="concept-box">
                <p><strong>The Problem:</strong> Testing every object against every other object is O(n¬≤)</p>
                <p>1,000 objects = 500,000 collision checks per frame!</p>
                <p><strong>The Solution:</strong> Only test objects in the same "grid cell"</p>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Design Question:</h4>
                <p>You have a 1000√ó1000 pixel game world with 1000 objects. You divide it into a 10√ó10 grid (100 cells).</p>
                <p><strong>Question:</strong> If objects are evenly distributed, how many collision checks do you need now?</p>
                <details>
                    <summary>Work it out</summary>
                    <p>Average 10 objects per cell (1000 objects / 100 cells)</p>
                    <p>Per cell: 10 √ó 9 / 2 = 45 checks</p>
                    <p>Total: 100 cells √ó 45 = <strong>4,500 checks</strong></p>
                    <p>That's <strong>110√ó faster</strong> than 500,000 checks!</p>
                </details>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Spatial Hash Grid</div>
                <pre><code><span class="keyword">class</span> <span class="function">SpatialHash</span> {
    <span class="keyword">constructor</span>(cellSize) {
        <span class="keyword">this</span>.cellSize = cellSize;
        <span class="keyword">this</span>.grid = <span class="keyword">new</span> Map();  <span class="comment">// Hash map for O(1) lookup</span>
    }
    
    <span class="comment">// Convert world position to grid cell</span>
    <span class="function">hash</span>(x, y) {
        <span class="keyword">let</span> cellX = Math.<span class="function">floor</span>(x / <span class="keyword">this</span>.cellSize);
        <span class="keyword">let</span> cellY = Math.<span class="function">floor</span>(y / <span class="keyword">this</span>.cellSize);
        <span class="keyword">return</span> `${cellX},${cellY}`;  <span class="comment">// String key</span>
    }
    
    <span class="function">insert</span>(obj) {
        <span class="keyword">let</span> key = <span class="keyword">this</span>.<span class="function">hash</span>(obj.position.x, obj.position.y);
        
        <span class="keyword">if</span> (!<span class="keyword">this</span>.grid.<span class="function">has</span>(key)) {
            <span class="keyword">this</span>.grid.<span class="function">set</span>(key, []);
        }
        
        <span class="keyword">this</span>.grid.<span class="function">get</span>(key).<span class="function">push</span>(obj);
        obj._cellKey = key;  <span class="comment">// Remember which cell for removal</span>
    }
    
    <span class="function">getNearby</span>(obj) {
        <span class="comment">// Get objects in same cell AND neighboring cells</span>
        <span class="keyword">let</span> nearby = [];
        <span class="keyword">let</span> cellX = Math.<span class="function">floor</span>(obj.position.x / <span class="keyword">this</span>.cellSize);
        <span class="keyword">let</span> cellY = Math.<span class="function">floor</span>(obj.position.y / <span class="keyword">this</span>.cellSize);
        
        <span class="keyword">for</span> (<span class="keyword">let</span> dx = -<span class="number">1</span>; dx <= <span class="number">1</span>; dx++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> dy = -<span class="number">1</span>; dy <= <span class="number">1</span>; dy++) {
                <span class="keyword">let</span> key = `${cellX + dx},${cellY + dy}`;
                <span class="keyword">if</span> (<span class="keyword">this</span>.grid.<span class="function">has</span>(key)) {
                    nearby = nearby.<span class="function">concat</span>(<span class="keyword">this</span>.grid.<span class="function">get</span>(key));
                }
            }
        }
        
        <span class="keyword">return</span> nearby;
    }
    
    <span class="function">clear</span>() {
        <span class="keyword">this</span>.grid.<span class="function">clear</span>();
    }
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Using Spatial Hash for Collision</h4>
                <pre><code><span class="keyword">let</span> spatialHash = <span class="keyword">new</span> <span class="function">SpatialHash</span>(<span class="number">50</span>);  <span class="comment">// 50px cells</span>

<span class="keyword">function</span> <span class="function">update</span>() {
    <span class="comment">// 1. Clear and rebuild grid each frame</span>
    spatialHash.<span class="function">clear</span>();
    
    <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> objects) {
        spatialHash.<span class="function">insert</span>(obj);
    }
    
    <span class="comment">// 2. Only check nearby objects</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> objects) {
        <span class="keyword">let</span> nearby = spatialHash.<span class="function">getNearby</span>(obj);
        
        <span class="keyword">for</span> (<span class="keyword">let</span> other <span class="keyword">of</span> nearby) {
            <span class="keyword">if</span> (obj !== other && <span class="function">checkCollision</span>(obj, other)) {
                <span class="function">handleCollision</span>(obj, other);
            }
        }
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="spatialHashDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addObjects(50)">Add 50 Objects</button>
                <button onclick="addObjects(100)">Add 100 Objects</button>
                <button onclick="clearSpatial()">Clear</button>
                <button onclick="toggleOptimization()">Toggle Optimization</button>
                <button onclick="toggleGridDisplay()">Show/Hide Grid</button>
            </div>
            <div id="spatialInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Compare brute force vs spatial hash. The difference is HUGE!</p>

            <!-- QUAD TREE -->
            <h3 id="quadtree">üå≥ QuadTree - Hierarchical Spatial Partitioning</h3>
            
            <div class="concept-box">
                <p>Spatial hash uses fixed-size cells. QuadTree adapts to object density!</p>
                <ul>
                    <li>Divides space recursively where objects are dense</li>
                    <li>Keeps empty areas as single large cells</li>
                    <li>Better for non-uniform distributions</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù QuadTree Implementation</div>
                <pre><code><span class="keyword">class</span> <span class="function">Rectangle</span> {
    <span class="keyword">constructor</span>(x, y, w, h) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
        <span class="keyword">this</span>.w = w;
        <span class="keyword">this</span>.h = h;
    }
    
    <span class="function">contains</span>(point) {
        <span class="keyword">return</span> point.x >= <span class="keyword">this</span>.x && point.x < <span class="keyword">this</span>.x + <span class="keyword">this</span>.w &&
               point.y >= <span class="keyword">this</span>.y && point.y < <span class="keyword">this</span>.y + <span class="keyword">this</span>.h;
    }
    
    <span class="function">intersects</span>(range) {
        <span class="keyword">return</span> !(<span class="keyword">this</span>.x > range.x + range.w || 
                 <span class="keyword">this</span>.x + <span class="keyword">this</span>.w < range.x ||
                 <span class="keyword">this</span>.y > range.y + range.h ||
                 <span class="keyword">this</span>.y + <span class="keyword">this</span>.h < range.y);
    }
}

<span class="keyword">class</span> <span class="function">QuadTree</span> {
    <span class="keyword">constructor</span>(boundary, capacity = <span class="number">4</span>) {
        <span class="keyword">this</span>.boundary = boundary;  <span class="comment">// Rectangle</span>
        <span class="keyword">this</span>.capacity = capacity; <span class="comment">// Max objects before subdividing</span>
        <span class="keyword">this</span>.objects = [];
        <span class="keyword">this</span>.divided = <span class="keyword">false</span>;
    }
    
    <span class="function">subdivide</span>() {
        <span class="keyword">let</span> x = <span class="keyword">this</span>.boundary.x;
        <span class="keyword">let</span> y = <span class="keyword">this</span>.boundary.y;
        <span class="keyword">let</span> w = <span class="keyword">this</span>.boundary.w / <span class="number">2</span>;
        <span class="keyword">let</span> h = <span class="keyword">this</span>.boundary.h / <span class="number">2</span>;
        
        <span class="comment">// Create 4 sub-quadrants</span>
        <span class="keyword">this</span>.northeast = <span class="keyword">new</span> <span class="function">QuadTree</span>(<span class="keyword">new</span> <span class="function">Rectangle</span>(x + w, y, w, h), <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.northwest = <span class="keyword">new</span> <span class="function">QuadTree</span>(<span class="keyword">new</span> <span class="function">Rectangle</span>(x, y, w, h), <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.southeast = <span class="keyword">new</span> <span class="function">QuadTree</span>(<span class="keyword">new</span> <span class="function">Rectangle</span>(x + w, y + h, w, h), <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.southwest = <span class="keyword">new</span> <span class="function">QuadTree</span>(<span class="keyword">new</span> <span class="function">Rectangle</span>(x, y + h, w, h), <span class="keyword">this</span>.capacity);
        
        <span class="keyword">this</span>.divided = <span class="keyword">true</span>;
    }
    
    <span class="function">insert</span>(obj) {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.boundary.<span class="function">contains</span>(obj.position)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        
        <span class="keyword">if</span> (<span class="keyword">this</span>.objects.length < <span class="keyword">this</span>.capacity) {
            <span class="keyword">this</span>.objects.<span class="function">push</span>(obj);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        
        <span class="keyword">if</span> (!<span class="keyword">this</span>.divided) {
            <span class="keyword">this</span>.<span class="function">subdivide</span>();
        }
        
        <span class="comment">// Try to insert into children</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.northeast.<span class="function">insert</span>(obj) ||
               <span class="keyword">this</span>.northwest.<span class="function">insert</span>(obj) ||
               <span class="keyword">this</span>.southeast.<span class="function">insert</span>(obj) ||
               <span class="keyword">this</span>.southwest.<span class="function">insert</span>(obj);
    }
    
    <span class="function">query</span>(range, found = []) {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.boundary.<span class="function">intersects</span>(range)) {
            <span class="keyword">return</span> found;
        }
        
        <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> <span class="keyword">this</span>.objects) {
            <span class="keyword">if</span> (range.<span class="function">contains</span>(obj.position)) {
                found.<span class="function">push</span>(obj);
            }
        }
        
        <span class="keyword">if</span> (<span class="keyword">this</span>.divided) {
            <span class="keyword">this</span>.northeast.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.northwest.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.southeast.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.southwest.<span class="function">query</span>(range, found);
        }
        
        <span class="keyword">return</span> found;
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="quadTreeDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addQuadObjects(50)">Add 50 Objects</button>
                <button onclick="clearQuadTree()">Clear</button>
                <button onclick="toggleQueryRange()">Show Query Range</button>
            </div>
            <div id="quadTreeInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Watch the tree subdivide where objects cluster! Move mouse to query region.</p>

            <!-- OBJECT POOLING -->
            <h3 id="pooling">‚ôªÔ∏è Object Pooling - Stop Garbage Collection Lag</h3>
            
            <div class="concept-box">
                <p><strong>The Problem:</strong> Creating and destroying objects (bullets, particles, etc.) causes garbage collection pauses</p>
                <p><strong>The Solution:</strong> Reuse objects instead of creating new ones!</p>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Generic Object Pool</div>
                <pre><code><span class="keyword">class</span> <span class="function">ObjectPool</span> {
    <span class="keyword">constructor</span>(createFunc, initialSize = <span class="number">20</span>) {
        <span class="keyword">this</span>.createFunc = createFunc;
        <span class="keyword">this</span>.available = [];
        <span class="keyword">this</span>.inUse = [];
        
        <span class="comment">// Pre-create objects</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < initialSize; i++) {
            <span class="keyword">this</span>.available.<span class="function">push</span>(<span class="keyword">this</span>.<span class="function">createFunc</span>());
        }
    }
    
    <span class="function">get</span>(...args) {
        <span class="keyword">let</span> obj;
        
        <span class="keyword">if</span> (<span class="keyword">this</span>.available.length > <span class="number">0</span>) {
            <span class="comment">// Reuse existing object</span>
            obj = <span class="keyword">this</span>.available.<span class="function">pop</span>();
        } <span class="keyword">else</span> {
            <span class="comment">// Create new if pool is empty</span>
            obj = <span class="keyword">this</span>.<span class="function">createFunc</span>();
        }
        
        <span class="comment">// Reset/initialize object</span>
        <span class="keyword">if</span> (obj.reset) {
            obj.<span class="function">reset</span>(...args);
        }
        
        <span class="keyword">this</span>.inUse.<span class="function">push</span>(obj);
        obj.active = <span class="keyword">true</span>;
        
        <span class="keyword">return</span> obj;
    }
    
    <span class="function">release</span>(obj) {
        <span class="keyword">let</span> index = <span class="keyword">this</span>.inUse.<span class="function">indexOf</span>(obj);
        <span class="keyword">if</span> (index !== -<span class="number">1</span>) {
            <span class="keyword">this</span>.inUse.<span class="function">splice</span>(index, <span class="number">1</span>);
            <span class="keyword">this</span>.available.<span class="function">push</span>(obj);
            obj.active = <span class="keyword">false</span>;
        }
    }
    
    <span class="function">update</span>() {
        <span class="comment">// Auto-release dead objects</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.inUse.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
            <span class="keyword">if</span> (!<span class="keyword">this</span>.inUse[i].active) {
                <span class="keyword">this</span>.<span class="function">release</span>(<span class="keyword">this</span>.inUse[i]);
            }
        }
    }
}</code></pre>
            </div>

            <div class="example-box">
                <h4>üéÆ Using Object Pool for Bullets</h4>
                <pre><code><span class="comment">// Create pool</span>
<span class="keyword">let</span> bulletPool = <span class="keyword">new</span> <span class="function">ObjectPool</span>(() => <span class="keyword">new</span> <span class="function">Bullet</span>(), <span class="number">100</span>);

<span class="comment">// Fire bullet (no 'new' keyword!)</span>
<span class="keyword">function</span> <span class="function">fireBullet</span>(x, y, angle) {
    <span class="keyword">let</span> bullet = bulletPool.<span class="function">get</span>(x, y, angle);
    <span class="comment">// Bullet is ready to use!</span>
}

<span class="comment">// In update loop</span>
<span class="keyword">function</span> <span class="function">update</span>() {
    <span class="keyword">for</span> (<span class="keyword">let</span> bullet <span class="keyword">of</span> bulletPool.inUse) {
        bullet.<span class="function">update</span>();
        
        <span class="keyword">if</span> (bullet.isOffscreen()) {
            bullet.active = <span class="keyword">false</span>;  <span class="comment">// Will be auto-released</span>
        }
    }
    
    bulletPool.<span class="function">update</span>();  <span class="comment">// Release inactive bullets</span>
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="poolingDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="togglePooling()">Toggle Object Pooling</button>
                <button onclick="increaseSpawn()">Increase Spawn Rate</button>
                <button onclick="decreaseSpawn()">Decrease Spawn Rate</button>
            </div>
            <div id="poolingInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Click to spawn particles. Watch the performance difference!</p>

            <!-- PROCEDURAL GENERATION -->
            <h3 id="procgen">üåç Procedural Generation - Infinite Worlds</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Content Problem:</h4>
                <p>Games like Minecraft have effectively infinite worlds. Did artists hand-draw every hill?</p>
                <p><strong>Problem:</strong> You can't store infinite data!</p>
                <p><strong>Solution:</strong> Generate content on-the-fly using algorithms!</p>
                <p><strong>Key requirement:</strong> Must be deterministic (same seed = same world)</p>
                <details>
                    <summary>The Magic: Perlin Noise</summary>
                    <p><strong>Perlin Noise</strong> creates natural-looking randomness:</p>
                    <ul>
                        <li>Smooth gradients (not pure random static)</li>
                        <li>Repeatable from seed</li>
                        <li>Multiple octaves = detail levels</li>
                    </ul>
                    <p>Use it for: terrain height, biome placement, cave systems, cloud patterns, etc.</p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>Perlin Noise Properties:</strong></p>
                <ul>
                    <li><strong>Deterministic:</strong> noise(x, y, seed) always returns same value</li>
                    <li><strong>Smooth:</strong> Adjacent values are similar</li>
                    <li><strong>Octaves:</strong> Layer multiple frequencies for detail</li>
                </ul>
                <p><strong>Terrain Generation Formula:</strong></p>
                <pre style="color: #4fc3f7;">height = amplitude‚ÇÅ √ó noise(x √ó freq‚ÇÅ, y √ó freq‚ÇÅ)
       + amplitude‚ÇÇ √ó noise(x √ó freq‚ÇÇ, y √ó freq‚ÇÇ)
       + amplitude‚ÇÉ √ó noise(x √ó freq‚ÇÉ, y √ó freq‚ÇÉ)</pre>
                <p>Higher frequencies = smaller features (rocks), Lower = large features (mountains)</p>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Procedural Terrain Generator</div>
                <pre><code><span class="keyword">class</span> <span class="function">TerrainGenerator</span> {
    <span class="keyword">constructor</span>(seed) {
        <span class="keyword">this</span>.seed = seed;
        <span class="keyword">this</span>.noise = <span class="keyword">new</span> <span class="function">SimplexNoise</span>(seed);
    }
    
    <span class="function">getHeight</span>(x, y) {
        <span class="keyword">let</span> height = <span class="number">0</span>;
        <span class="keyword">let</span> amplitude = <span class="number">1</span>;
        <span class="keyword">let</span> frequency = <span class="number">0.01</span>;
        <span class="keyword">let</span> maxValue = <span class="number">0</span>;
        
        <span class="comment">// Multiple octaves for detail</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> octave = <span class="number">0</span>; octave < <span class="number">4</span>; octave++) {
            height += <span class="keyword">this</span>.noise.<span class="function">noise2D</span>(
                x * frequency,
                y * frequency
            ) * amplitude;
            
            maxValue += amplitude;
            amplitude *= <span class="number">0.5</span>;  <span class="comment">// Each octave has half amplitude</span>
            frequency *= <span class="number">2</span>;    <span class="comment">// Each octave has double frequency</span>
        }
        
        <span class="comment">// Normalize to 0-1 range</span>
        <span class="keyword">return</span> height / maxValue;
    }
    
    <span class="function">getBiome</span>(x, y) {
        <span class="keyword">let</span> temperature = <span class="keyword">this</span>.noise.<span class="function">noise2D</span>(x * <span class="number">0.005</span>, y * <span class="number">0.005</span>);
        <span class="keyword">let</span> moisture = <span class="keyword">this</span>.noise.<span class="function">noise2D</span>(x * <span class="number">0.007</span> + <span class="number">1000</span>, y * <span class="number">0.007</span>);
        
        <span class="comment">// Classify based on temp/moisture</span>
        <span class="keyword">if</span> (temperature < -<span class="number">0.3</span>) <span class="keyword">return</span> <span class="string">'snow'</span>;
        <span class="keyword">if</span> (moisture > <span class="number">0.3</span>) <span class="keyword">return</span> <span class="string">'forest'</span>;
        <span class="keyword">if</span> (moisture < -<span class="number">0.3</span>) <span class="keyword">return</span> <span class="string">'desert'</span>;
        <span class="keyword">return</span> <span class="string">'plains'</span>;
    }
}</code></pre>
            </div>

            <div class="challenge-box">
                <h4>üéØ Challenge: Dungeon Generation</h4>
                <p>Terrain is continuous. Dungeons need rooms and corridors!</p>
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>BSP (Binary Space Partitioning)</strong>
                    <p>Recursively split space into rooms</p>
                </div>
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Connect rooms with corridors</strong>
                    <p>L-shaped paths between room centers</p>
                </div>
                <div class="step">
                    <span class="step-number">3</span>
                    <strong>Add content</strong>
                    <p>Spawn enemies, loot, traps based on room size/distance</p>
                </div>
            </div>

            <div class="diagram">
                <canvas id="proceduralDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="generateTerrain()">Generate Terrain</button>
                <button onclick="generateDungeon()">Generate Dungeon</button>
                <button onclick="changeSeed()">New Seed</button>
                <button onclick="adjustOctaves()">More Detail</button>
            </div>
            <div id="proceduralInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Generate infinite unique worlds from a single seed!</p>

            <!-- TILEMAP SYSTEMS -->
            <h3 id="tilemap">üó∫Ô∏è Tilemap Systems - Chunking & Infinite Worlds</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Scale Problem:</h4>
                <p>Your world is 1,000,000 √ó 1,000,000 tiles. Loading all tiles = out of memory!</p>
                <p><strong>Bad:</strong> Load entire world ‚Üí 1 trillion tiles in RAM</p>
                <p><strong>Smart:</strong> Load only visible chunks ‚Üí ~10,000 tiles</p>
                <p><strong>How do you know which chunks to load?</strong></p>
                <details>
                    <summary>Chunking Strategy</summary>
                    <p>Divide world into 16√ó16 tile chunks. Only load chunks near the camera!</p>
                    <p><strong>Algorithm:</strong></p>
                    <ol>
                        <li>Calculate which chunk the camera is in</li>
                        <li>Load surrounding chunks (3√ó3 grid = 9 chunks)</li>
                        <li>Unload chunks that are too far away</li>
                        <li>As camera moves, load/unload dynamically</li>
                    </ol>
                    <p>Result: Infinite world, constant memory usage!</p>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>Chunking Math:</strong></p>
                <pre style="color: #4fc3f7;">chunkSize = 16 tiles
chunkX = floor(worldX / (chunkSize √ó tileSize))
chunkY = floor(worldY / (chunkSize √ó tileSize))</pre>
                <p><strong>Performance tips:</strong></p>
                <ul>
                    <li>Use Map/Set for O(1) chunk lookup</li>
                    <li>Serialize chunks to disk when unloading</li>
                    <li>Generate chunks in background thread</li>
                    <li>Batch render entire chunks (not individual tiles)</li>
                </ul>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Chunk Manager</div>
                <pre><code><span class="keyword">class</span> <span class="function">ChunkManager</span> {
    <span class="keyword">constructor</span>(chunkSize, loadRadius) {
        <span class="keyword">this</span>.chunkSize = chunkSize;
        <span class="keyword">this</span>.loadRadius = loadRadius;
        <span class="keyword">this</span>.chunks = <span class="keyword">new</span> Map();  <span class="comment">// Fast lookup</span>
    }
    
    <span class="function">getChunkKey</span>(chunkX, chunkY) {
        <span class="keyword">return</span> `${chunkX},${chunkY}`;
    }
    
    <span class="function">worldToChunk</span>(worldX, worldY) {
        <span class="keyword">return</span> {
            x: Math.<span class="function">floor</span>(worldX / <span class="keyword">this</span>.chunkSize),
            y: Math.<span class="function">floor</span>(worldY / <span class="keyword">this</span>.chunkSize)
        };
    }
    
    <span class="function">update</span>(cameraX, cameraY) {
        <span class="keyword">let</span> cameraChunk = <span class="keyword">this</span>.<span class="function">worldToChunk</span>(cameraX, cameraY);
        
        <span class="comment">// Load chunks in radius</span>
        <span class="keyword">let</span> shouldBeLoaded = <span class="keyword">new</span> Set();
        
        <span class="keyword">for</span> (<span class="keyword">let</span> dx = -<span class="keyword">this</span>.loadRadius; dx <= <span class="keyword">this</span>.loadRadius; dx++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> dy = -<span class="keyword">this</span>.loadRadius; dy <= <span class="keyword">this</span>.loadRadius; dy++) {
                <span class="keyword">let</span> chunkX = cameraChunk.x + dx;
                <span class="keyword">let</span> chunkY = cameraChunk.y + dy;
                <span class="keyword">let</span> key = <span class="keyword">this</span>.<span class="function">getChunkKey</span>(chunkX, chunkY);
                
                shouldBeLoaded.<span class="function">add</span>(key);
                
                <span class="comment">// Load if not already loaded</span>
                <span class="keyword">if</span> (!<span class="keyword">this</span>.chunks.<span class="function">has</span>(key)) {
                    <span class="keyword">this</span>.<span class="function">loadChunk</span>(chunkX, chunkY);
                }
            }
        }
        
        <span class="comment">// Unload chunks outside radius</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="keyword">this</span>.chunks.<span class="function">keys</span>()) {
            <span class="keyword">if</span> (!shouldBeLoaded.<span class="function">has</span>(key)) {
                <span class="keyword">this</span>.<span class="function">unloadChunk</span>(key);
            }
        }
    }
    
    <span class="function">loadChunk</span>(chunkX, chunkY) {
        <span class="keyword">let</span> key = <span class="keyword">this</span>.<span class="function">getChunkKey</span>(chunkX, chunkY);
        <span class="keyword">let</span> chunk = <span class="keyword">this</span>.<span class="function">generateChunk</span>(chunkX, chunkY);
        <span class="keyword">this</span>.chunks.<span class="function">set</span>(key, chunk);
    }
    
    <span class="function">unloadChunk</span>(key) {
        <span class="comment">// Could save to disk here</span>
        <span class="keyword">this</span>.chunks.<span class="function">delete</span>(key);
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="tilemapDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="increaseLoadRadius()">Increase Load Radius</button>
                <button onclick="decreaseLoadRadius()">Decrease Load Radius</button>
                <button onclick="toggleChunkBorders()">Show Chunk Borders</button>
            </div>
            <div id="tilemapInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Use arrow keys or drag to move. Watch chunks load/unload dynamically!</p>

            <!-- SOUND PROPAGATION -->
            <h3 id="sound">üîä Sound Propagation - Realistic Audio</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Audio Problem:</h4>
                <p>A gun fires behind a wall. Should you hear it at full volume?</p>
                <p><strong>Naive:</strong> Volume = distance only ‚Üí walls don't matter</p>
                <p><strong>Realistic:</strong> Sound waves bounce and attenuate through materials</p>
                <p><strong>Question:</strong> How do you simulate sound traveling through a level?</p>
                <details>
                    <summary>The Solution</summary>
                    <p>Combine raycasting with wave propagation!</p>
                    <ol>
                        <li><strong>Line of sight:</strong> Raycast to check if sound path is clear</li>
                        <li><strong>Wall attenuation:</strong> Each wall reduces volume</li>
                        <li><strong>Reflections:</strong> Sound bounces off walls (echoes)</li>
                        <li><strong>Occlusion:</strong> Materials have different absorption rates</li>
                    </ol>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>Sound Propagation Formula:</strong></p>
                <pre style="color: #4fc3f7;">finalVolume = baseVolume √ó distanceAttenuation √ó occlusionFactor

distanceAttenuation = 1 / (1 + distance / rolloffDistance)

occlusionFactor = 1 - (wallCount √ó wallAbsorption)</pre>
                <p><strong>Material properties:</strong></p>
                <table>
                    <tr>
                        <th>Material</th>
                        <th>Absorption</th>
                        <th>Reflection</th>
                    </tr>
                    <tr>
                        <td>Air</td>
                        <td>0.0</td>
                        <td>0.0</td>
                    </tr>
                    <tr>
                        <td>Wood</td>
                        <td>0.3</td>
                        <td>0.4</td>
                    </tr>
                    <tr>
                        <td>Concrete</td>
                        <td>0.6</td>
                        <td>0.7</td>
                    </tr>
                    <tr>
                        <td>Metal</td>
                        <td>0.8</td>
                        <td>0.9</td>
                    </tr>
                </table>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Sound Propagation System</div>
                <pre><code><span class="keyword">class</span> <span class="function">SoundPropagation</span> {
    <span class="keyword">constructor</span>(walls) {
        <span class="keyword">this</span>.walls = walls;
    }
    
    <span class="function">calculateVolume</span>(source, listener, baseVolume = <span class="number">1</span>) {
        <span class="keyword">let</span> distance = source.<span class="function">distance</span>(listener);
        
        <span class="comment">// Distance attenuation</span>
        <span class="keyword">let</span> rolloff = <span class="number">100</span>;
        <span class="keyword">let</span> distAttenuation = <span class="number">1</span> / (<span class="number">1</span> + distance / rolloff);
        
        <span class="comment">// Check occlusion</span>
        <span class="keyword">let</span> wallsHit = <span class="keyword">this</span>.<span class="function">countWallsBetween</span>(source, listener);
        <span class="keyword">let</span> occlusionFactor = Math.<span class="function">max</span>(<span class="number">0</span>, <span class="number">1</span> - wallsHit * <span class="number">0.4</span>);
        
        <span class="comment">// Calculate reflections (simplified)</span>
        <span class="keyword">let</span> reflections = <span class="keyword">this</span>.<span class="function">calculateReflections</span>(source, listener);
        <span class="keyword">let</span> reflectionBonus = reflections * <span class="number">0.1</span>;
        
        <span class="keyword">return</span> baseVolume * distAttenuation * occlusionFactor + reflectionBonus;
    }
    
    <span class="function">countWallsBetween</span>(source, listener) {
        <span class="keyword">let</span> direction = listener.<span class="function">subtract</span>(source);
        <span class="keyword">let</span> count = <span class="number">0</span>;
        
        <span class="keyword">for</span> (<span class="keyword">let</span> wall <span class="keyword">of</span> <span class="keyword">this</span>.walls) {
            <span class="keyword">if</span> (<span class="function">rayIntersectsWall</span>(source, direction, wall)) {
                count++;
            }
        }
        
        <span class="keyword">return</span> count;
    }
    
    <span class="function">calculateReflections</span>(source, listener) {
        <span class="comment">// Cast rays in multiple directions</span>
        <span class="comment">// Find how many bounce paths exist to listener</span>
        <span class="keyword">let</span> reflectionCount = <span class="number">0</span>;
        
        <span class="keyword">for</span> (<span class="keyword">let</span> angle = <span class="number">0</span>; angle < Math.PI * <span class="number">2</span>; angle += Math.PI / <span class="number">8</span>) {
            <span class="keyword">let</span> bouncePoint = <span class="keyword">this</span>.<span class="function">castReflectionRay</span>(source, angle);
            <span class="keyword">if</span> (bouncePoint) {
                <span class="keyword">let</span> toListener = listener.<span class="function">distance</span>(bouncePoint);
                <span class="keyword">if</span> (toListener < <span class="number">200</span>) reflectionCount++;
            }
        }
        
        <span class="keyword">return</span> reflectionCount;
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="soundDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="addSoundWall()">Add Wall</button>
                <button onclick="playSoundEffect()">Play Sound</button>
                <button onclick="toggleSoundVisualization()">Show Sound Waves</button>
            </div>
            <div id="soundInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Click to place sound source. Watch how walls affect volume!</p>

            <!-- NETWORK INTERPOLATION -->
            <h3 id="network">üåê Network Interpolation - Smooth Multiplayer</h3>
            
            <div class="thinking-prompt">
                <h4>ü§î The Multiplayer Problem:</h4>
                <p>Server sends player positions at 20 updates/second. Your game runs at 60 FPS.</p>
                <p><strong>Naive:</strong> Update position when packet arrives ‚Üí teleporting/jittery movement</p>
                <p><strong>Smart:</strong> Interpolate between past positions ‚Üí smooth movement</p>
                <p><strong>But there's lag! How do you predict the future?</strong></p>
                <details>
                    <summary>The Techniques</summary>
                    <p><strong>Client-Side Prediction:</strong></p>
                    <ul>
                        <li>Immediately apply local inputs (feels responsive)</li>
                        <li>When server confirms, reconcile differences</li>
                    </ul>
                    <p><strong>Server Reconciliation:</strong></p>
                    <ul>
                        <li>Server is authoritative (prevents cheating)</li>
                        <li>Client replays unconfirmed inputs after correction</li>
                    </ul>
                    <p><strong>Entity Interpolation:</strong></p>
                    <ul>
                        <li>Render entities slightly in the past (100-200ms)</li>
                        <li>Smoothly interpolate between known positions</li>
                    </ul>
                </details>
            </div>

            <div class="concept-box">
                <p><strong>The Three-Pronged Approach:</strong></p>
                <table>
                    <tr>
                        <th>Technique</th>
                        <th>For</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><strong>Prediction</strong></td>
                        <td>Local player</td>
                        <td>Instant response</td>
                    </tr>
                    <tr>
                        <td><strong>Reconciliation</strong></td>
                        <td>Local player</td>
                        <td>Fix mispredictions</td>
                    </tr>
                    <tr>
                        <td><strong>Interpolation</strong></td>
                        <td>Remote players</td>
                        <td>Smooth movement</td>
                    </tr>
                </table>
            </div>

            <div class="code-container">
                <div class="code-header">üìù Client-Side Prediction & Interpolation</div>
                <pre><code><span class="keyword">class</span> <span class="function">NetworkedEntity</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        
        <span class="comment">// For interpolation</span>
        <span class="keyword">this</span>.positionBuffer = [];  <span class="comment">// Past server positions</span>
        <span class="keyword">this</span>.renderTime = <span class="number">100</span>;      <span class="comment">// Render 100ms in past</span>
        
        <span class="comment">// For prediction</span>
        <span class="keyword">this</span>.inputSequence = <span class="number">0</span>;
        <span class="keyword">this</span>.pendingInputs = [];
    }
    
    <span class="comment">// CLIENT: Apply input with prediction</span>
    <span class="function">applyInput</span>(input) {
        <span class="keyword">this</span>.inputSequence++;
        
        <span class="comment">// Immediately apply (prediction)</span>
        <span class="keyword">this</span>.velocity.<span class="function">add</span>(input);
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
        
        <span class="comment">// Store for reconciliation</span>
        <span class="keyword">this</span>.pendingInputs.<span class="function">push</span>({
            sequence: <span class="keyword">this</span>.inputSequence,
            input: input,
            position: <span class="keyword">this</span>.position.<span class="function">copy</span>()
        });
        
        <span class="comment">// Send to server</span>
        <span class="function">sendToServer</span>({ sequence: <span class="keyword">this</span>.inputSequence, input });
    }
    
    <span class="comment">// CLIENT: Reconcile with server</span>
    <span class="function">onServerUpdate</span>(serverPos, lastProcessedInput) {
        <span class="comment">// Remove confirmed inputs</span>
        <span class="keyword">this</span>.pendingInputs = <span class="keyword">this</span>.pendingInputs.<span class="function">filter</span>(
            i => i.sequence > lastProcessedInput
        );
        
        <span class="comment">// Server position is authoritative</span>
        <span class="keyword">this</span>.position = serverPos.<span class="function">copy</span>();
        
        <span class="comment">// Replay unconfirmed inputs</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> input <span class="keyword">of</span> <span class="keyword">this</span>.pendingInputs) {
            <span class="keyword">this</span>.position.<span class="function">add</span>(input.input);
        }
    }
    
    <span class="comment">// CLIENT: Interpolate remote entities</span>
    <span class="function">interpolate</span>(currentTime) {
        <span class="keyword">let</span> renderTime = currentTime - <span class="keyword">this</span>.renderTime;
        
        <span class="comment">// Find positions to interpolate between</span>
        <span class="keyword">let</span> from = <span class="keyword">null</span>, to = <span class="keyword">null</span>;
        
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="keyword">this</span>.positionBuffer.length - <span class="number">1</span>; i++) {
            <span class="keyword">if</span> (<span class="keyword">this</span>.positionBuffer[i].time <= renderTime &&
                renderTime <= <span class="keyword">this</span>.positionBuffer[i + <span class="number">1</span>].time) {
                from = <span class="keyword">this</span>.positionBuffer[i];
                to = <span class="keyword">this</span>.positionBuffer[i + <span class="number">1</span>];
                <span class="keyword">break</span>;
            }
        }
        
        <span class="keyword">if</span> (from && to) {
            <span class="keyword">let</span> t = (renderTime - from.time) / (to.time - from.time);
            <span class="keyword">this</span>.position = from.position.<span class="function">lerp</span>(to.position, t);
        }
    }
}</code></pre>
            </div>

            <div class="diagram">
                <canvas id="networkDemo" width="900" height="600"></canvas>
            </div>
            <div class="controls">
                <button onclick="adjustLatency(-50)">Less Lag</button>
                <button onclick="adjustLatency(50)">More Lag</button>
                <button onclick="togglePrediction()">Toggle Prediction</button>
                <button onclick="toggleInterpolation()">Toggle Interpolation</button>
            </div>
            <div id="networkInfo" class="info-display"></div>
            <p style="text-align: center; color: #9e9e9e;">Use WASD. Watch how prediction keeps YOUR player smooth despite lag!</p>

            <!-- FINAL CHALLENGE -->
            <div class="challenge-box" style="margin-top: 50px;">
                <h4>üèÜ Ultimate Expert Challenge: AAA Game Systems</h4>
                <p>You now know the techniques used in professional games. Can you combine them?</p>
                <ol>
                    <li><strong>Procedurally generate</strong> an infinite tilemap world</li>
                    <li><strong>Chunk loading</strong> for performance (only render visible chunks)</li>
                    <li><strong>Pathfinding</strong> for AI navigation across chunks</li>
                    <li><strong>Shadow casting</strong> for dynamic lighting</li>
                    <li><strong>Sound propagation</strong> through walls</li>
                    <li><strong>Particle systems</strong> for effects</li>
                    <li><strong>Object pooling</strong> for thousands of objects</li>
                    <li><strong>Spatial hash</strong> for collision detection</li>
                    <li><strong>Network sync</strong> for multiplayer</li>
                    <li>Maintain <strong>60 FPS</strong> with 1000+ entities!</li>
                </ol>
                <p><strong>Welcome to professional game development! üéÆ</strong></p>
            </div>
        </div>

        <div class="section" style="text-align: center; padding: 40px; display: block;">
            <h2>üéØ Your Journey</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress" style="width: 33%;">
                    Level 2: Intermediate
                </div>
            </div>
            <p style="margin-top: 30px; color: #9e9e9e;">You've learned the math that powers every professional game. Now go build something amazing!</p>
        </div>
    </div>

<script>
// ===================================
// CORE CLASSES
// ===================================

class Vector2D {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    
    subtract(other) {
        return new Vector2D(this.x - other.x, this.y - other.y);
    }
    
    multiply(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.y /= scalar;
        }
        return this;
    }
    
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    distance(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    normalize() {
        const len = this.length();
        if (len > 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }
    
    copy() {
        return new Vector2D(this.x, this.y);
    }
    
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    
    cross(other) {
        return this.x * other.y - this.y * other.x;
    }
    
    lerp(target, t) {
        this.x += (target.x - this.x) * t;
        this.y += (target.y - this.y) * t;
        return this;
    }
    
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const newX = this.x * cos - this.y * sin;
        const newY = this.x * sin + this.y * cos;
        this.x = newX;
        this.y = newY;
        return this;
    }
    
    angle() {
        return Math.atan2(this.y, this.x);
    }
    
    limit(max) {
        const len = this.length();
        if (len > max) {
            this.normalize();
            this.multiply(max);
        }
        return this;
    }
    
    setLength(len) {
        this.normalize();
        this.multiply(len);
        return this;
    }
}

class Matrix2D {
    constructor() {
        this.a = 1; this.b = 0; this.tx = 0;
        this.c = 0; this.d = 1; this.ty = 0;
    }
    
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a = this.a * cos - this.c * sin;
        const c = this.a * sin + this.c * cos;
        const b = this.b * cos - this.d * sin;
        const d = this.b * sin + this.d * cos;
        this.a = a; this.b = b;
        this.c = c; this.d = d;
        return this;
    }
    
    scale(sx, sy) {
        this.a *= sx; this.b *= sy;
        this.c *= sx; this.d *= sy;
        return this;
    }
    
    translate(tx, ty) {
        this.tx += tx;
        this.ty += ty;
        return this;
    }
    
    transformPoint(point) {
        return new Vector2D(
            point.x * this.a + point.y * this.b + this.tx,
            point.x * this.c + point.y * this.d + this.ty
        );
    }
}

// ===================================
// HELPER FUNCTIONS
// ===================================

function drawVector(ctx, start, end, color, width = 2) {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
    
    const angle = Math.atan2(end.y - start.y, end.x - start.x);
    const headLength = 10;
    ctx.beginPath();
    ctx.moveTo(end.x, end.y);
    ctx.lineTo(
        end.x - headLength * Math.cos(angle - Math.PI / 6),
        end.y - headLength * Math.sin(angle - Math.PI / 6)
    );
    ctx.moveTo(end.x, end.y);
    ctx.lineTo(
        end.x - headLength * Math.cos(angle + Math.PI / 6),
        end.y - headLength * Math.sin(angle + Math.PI / 6)
    );
    ctx.stroke();
}

function drawPoint(ctx, pos, color, label) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    if (label) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '14px Arial';
        ctx.fillText(label, pos.x + 10, pos.y - 10);
    }
}

function drawGrid(ctx, width, height, spacing, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    
    for (let x = 0; x <= width; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }
    
    for (let y = 0; y <= height; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
}

// ===================================
// FILE 1 DEMOS (Beginner Content)
// ===================================

        // ===================================
        // DEMO 1: VECTOR BASICS
        // ===================================
        
        const vectorBasicsCanvas = document.getElementById('vectorBasics');
        const vbCtx = vectorBasicsCanvas.getContext('2d');
        let currentVectorExample = 'simple';
        
        function showVectorExample(type) {
            currentVectorExample = type;
            drawVectorBasics();
        }
        
        function drawVectorBasics() {
            const ctx = vbCtx;
            const width = vectorBasicsCanvas.width;
            const height = vectorBasicsCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#1a2332';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            const info = document.getElementById('vectorInfo');
            
            if (currentVectorExample === 'simple') {
                // Draw a simple vector
                const start = new Vector2D(200, 300);
                const end = new Vector2D(500, 150);
                
                drawVector(ctx, start, end, '#4fc3f7', 3);
                drawPoint(ctx, start, '#66bb6a', 'Start (200, 300)');
                drawPoint(ctx, end, '#ff5252', 'End (500, 150)');
                
                const vector = end.subtract(start);
                info.innerHTML = `<strong>Vector:</strong> (${vector.x.toFixed(0)}, ${vector.y.toFixed(0)})<br>
                                  <strong>Length:</strong> ${vector.length().toFixed(1)} pixels<br>
                                  <strong>Meaning:</strong> "Move ${vector.x.toFixed(0)} pixels right and ${Math.abs(vector.y).toFixed(0)} pixels up"`;
            }
            else if (currentVectorExample === 'player') {
                const player = new Vector2D(300, 200);
                const movement = new Vector2D(150, 0);
                const newPos = new Vector2D(player.x + movement.x, player.y + movement.y);
                
                drawPoint(ctx, player, '#66bb6a', 'üë§ Player');
                drawVector(ctx, player, newPos, '#ffd700', 3);
                drawPoint(ctx, newPos, '#ff5252', 'New Position');
                
                info.innerHTML = `<strong>Movement Vector:</strong> (${movement.x}, ${movement.y})<br>
                                  <strong>Action:</strong> Player pressed 'D' key (move right)<br>
                                  <strong>New Position:</strong> (${newPos.x}, ${newPos.y})`;
            }
            else if (currentVectorExample === 'bullet') {
                const gun = new Vector2D(200, 300);
                const target = new Vector2D(600, 100);
                const direction = target.subtract(gun);
                const normalized = direction.copy().normalize();
                const bulletEnd = new Vector2D(
                    gun.x + normalized.x * 150,
                    gun.y + normalized.y * 150
                );
                
                drawPoint(ctx, gun, '#66bb6a', 'üî´ Gun');
                drawPoint(ctx, target, '#ff5252', 'üéØ Target');
                drawVector(ctx, gun, target, '#4fc3f7', 1, true);
                drawVector(ctx, gun, bulletEnd, '#ffd700', 3);
                
                info.innerHTML = `<strong>Direction Vector:</strong> (${direction.x.toFixed(0)}, ${direction.y.toFixed(0)})<br>
                                  <strong>Normalized:</strong> (${normalized.x.toFixed(2)}, ${normalized.y.toFixed(2)})<br>
                                  <strong>Yellow vector</strong> shows bullet's actual movement per frame`;
            }
        }

        drawVectorBasics();
        
        // ===================================
        // DEMO 2: VECTOR PLAYGROUND
        // ===================================
        
        const playgroundCanvas = document.getElementById('vectorPlayground');
        const pgCtx = playgroundCanvas.getContext('2d');
        let movingObjects = [];
        let isDragging = false;
        let dragStart = null;
        
        class MovingObject {
            constructor(pos, vel) {
                this.position = pos.copy();
                this.velocity = vel.copy();
                this.radius = 8;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.trail = [];
            }
            
            update(width, height) {
                this.trail.push(this.position.copy());
                if (this.trail.length > 50) this.trail.shift();
                
                this.position.add(this.velocity);
                
                // Bounce off walls
                if (this.position.x < this.radius || this.position.x > width - this.radius) {
                    this.velocity.x *= -0.95;
                    this.position.x = Math.max(this.radius, Math.min(width - this.radius, this.position.x));
                }
                if (this.position.y < this.radius || this.position.y > height - this.radius) {
                    this.velocity.y *= -0.95;
                    this.position.y = Math.max(this.radius, Math.min(height - this.radius, this.position.y));
                }
            }
            
            draw(ctx) {
                // Draw trail
                ctx.strokeStyle = this.color + '40';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length - 1; i++) {
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                }
                ctx.stroke();
                
                // Draw object
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw velocity vector
                const end = new Vector2D(
                    this.position.x + this.velocity.x * 5,
                    this.position.y + this.velocity.y * 5
                );
                drawVector(ctx, this.position, end, '#ffd700', 2);
            }
        }
        
        playgroundCanvas.addEventListener('mousedown', (e) => {
            const rect = playgroundCanvas.getBoundingClientRect();
            dragStart = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
            isDragging = true;
        });
        
        playgroundCanvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = playgroundCanvas.getBoundingClientRect();
            const currentPos = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
            
            // Draw preview
            const ctx = pgCtx;
            updatePlayground();
            drawVector(ctx, dragStart, currentPos, '#4fc3f7', 3);
        });
        
        playgroundCanvas.addEventListener('mouseup', (e) => {
            if (!isDragging) return;
            
            const rect = playgroundCanvas.getBoundingClientRect();
            const dragEnd = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
            
            const velocity = dragEnd.subtract(dragStart).multiply(0.2);
            movingObjects.push(new MovingObject(dragStart, velocity));
            
            isDragging = false;
            dragStart = null;
        });
        
        function addMovingObject() {
            const pos = new Vector2D(
                Math.random() * (playgroundCanvas.width - 100) + 50,
                Math.random() * (playgroundCanvas.height - 100) + 50
            );
            const vel = new Vector2D(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            movingObjects.push(new MovingObject(pos, vel));
        }
        
        function clearObjects() {
            movingObjects = [];
        }
        
        function updatePlayground() {
            const ctx = pgCtx;
            const width = playgroundCanvas.width;
            const height = playgroundCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw objects
            for (let obj of movingObjects) {
                obj.update(width, height);
                obj.draw(ctx);
            }
        }
        
        function animatePlayground() {
            updatePlayground();
            requestAnimationFrame(animatePlayground);
        }
        animatePlayground();
        
        // ===================================
        // DEMO 3: NORMALIZE DEMO
        // ===================================
        
        const normalizeCanvas = document.getElementById('normalizeDemo');
        const nmCtx = normalizeCanvas.getContext('2d');
        let mousePos = new Vector2D(400, 200);
        
        normalizeCanvas.addEventListener('mousemove', (e) => {
            const rect = normalizeCanvas.getBoundingClientRect();
            mousePos = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
        });
        
        function updateNormalizeDemo() {
            const ctx = nmCtx;
            const width = normalizeCanvas.width;
            const height = normalizeCanvas.height;
            const center = new Vector2D(width / 2, height / 2);
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Original vector (to mouse)
            const toMouse = mousePos.subtract(center);
            drawVector(ctx, center, mousePos, '#ff5252', 2);
            
            // Normalized vector (constant length)
            const normalized = toMouse.copy().normalize();
            const normalizedEnd = new Vector2D(
                center.x + normalized.x * 100,
                center.y + normalized.y * 100
            );
            drawVector(ctx, center, normalizedEnd, '#66bb6a', 3);
            
            // Draw center point
            drawPoint(ctx, center, '#4fc3f7', 'Center');
            
            // Info
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.fillText('Red: Original vector (to mouse)', 20, 30);
            ctx.fillText('Green: Normalized (always length 100)', 20, 55);
            ctx.fillText(`Original length: ${toMouse.length().toFixed(1)}`, 20, 85);
            ctx.fillText(`Normalized: (${normalized.x.toFixed(2)}, ${normalized.y.toFixed(2)})`, 20, 110);
            
            requestAnimationFrame(updateNormalizeDemo);
        }
        updateNormalizeDemo();
        
        // ===================================
        // DEMO 4: DOT PRODUCT
        // ===================================
        
        const dotCanvas = document.getElementById('dotProductDemo');
        const dpCtx = dotCanvas.getContext('2d');
        let dotMousePos = new Vector2D(600, 200);
        
        dotCanvas.addEventListener('mousemove', (e) => {
            const rect = dotCanvas.getBoundingClientRect();
            dotMousePos = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
        });
        
        function updateDotProductDemo() {
            const ctx = dpCtx;
            const width = dotCanvas.width;
            const height = dotCanvas.height;
            const center = new Vector2D(width / 2, height / 2);
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Player direction (facing right)
            const playerDir = new Vector2D(1, 0);
            const playerDirEnd = new Vector2D(center.x + 150, center.y);
            drawVector(ctx, center, playerDirEnd, '#4fc3f7', 3);
            
            // Direction to mouse
            const toMouse = dotMousePos.subtract(center).normalize();
            const toMouseEnd = new Vector2D(
                center.x + toMouse.x * 150,
                center.y + toMouse.y * 150
            );
            drawVector(ctx, center, toMouseEnd, '#66bb6a', 3);
            
            // Calculate dot product
            const dot = playerDir.dot(toMouse);
            const angle = Math.acos(dot) * (180 / Math.PI);
            
            // Draw field of view cone
            ctx.fillStyle = dot > 0.5 ? 'rgba(102, 187, 106, 0.1)' : 'rgba(255, 82, 82, 0.1)';
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.arc(center.x, center.y, 200, -Math.PI / 3, Math.PI / 3);
            ctx.closePath();
            ctx.fill();
            
            drawPoint(ctx, center, '#ffd700', '');
            
            // Info
            const info = document.getElementById('dotProductInfo');
            const status = dot > 0.5 ? '‚úÖ DETECTED!' : dot > 0 ? '‚ö†Ô∏è Edge of view' : '‚ùå Behind';
            const color = dot > 0.5 ? '#66bb6a' : dot > 0 ? '#ffd700' : '#ff5252';
            
            info.innerHTML = `<span style="color: ${color}"><strong>Dot Product:</strong> ${dot.toFixed(3)}</span><br>
                              <strong>Angle:</strong> ${angle.toFixed(1)}¬∞<br>
                              <strong>Status:</strong> <span style="color: ${color}">${status}</span>`;
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.fillText('Blue: Player facing direction', 20, 30);
            ctx.fillText('Green: Direction to mouse', 20, 55);
            ctx.fillText('Shaded area: Field of view (60¬∞ cone)', 20, 80);
            
            requestAnimationFrame(updateDotProductDemo);
        }
        updateDotProductDemo();
        
        // ===================================
        // DEMO 5: HOMING MISSILE
        // ===================================
        
        const homingCanvas = document.getElementById('homingDemo');
        const hmCtx = homingCanvas.getContext('2d');
        let missiles = [];
        let targetPos = new Vector2D(700, 250);
        
        class HomingMissile {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(2, 0);
                this.speed = 3;
                this.turnSpeed = 0.08;
                this.trail = [];
            }
            
            update(target) {
                this.trail.push(this.position.copy());
                if (this.trail.length > 80) this.trail.shift();
                
                const toTarget = target.subtract(this.position).normalize();
                this.velocity.add(toTarget.multiply(this.turnSpeed));
                this.velocity.normalize().multiply(this.speed);
                
                this.position.add(this.velocity);
                
                // Remove if too close to target
                return this.position.distance(target) > 20;
            }
            
            draw(ctx) {
                // Trail
                ctx.strokeStyle = '#ff5252';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const alpha = i / this.trail.length;
                    ctx.globalAlpha = alpha;
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Missile body
                ctx.fillStyle = '#ff5252';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Direction indicator
                const vel = this.velocity.copy().normalize().multiply(15);
                const end = new Vector2D(
                    this.position.x + vel.x,
                    this.position.y + vel.y
                );
                drawVector(ctx, this.position, end, '#ffd700', 2);
            }
        }
        
        homingCanvas.addEventListener('mousemove', (e) => {
            const rect = homingCanvas.getBoundingClientRect();
            targetPos = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
        });
        
        function launchMissile() {
            missiles.push(new HomingMissile(50, 250));
        }
        
        function updateHomingDemo() {
            const ctx = hmCtx;
            const width = homingCanvas.width;
            const height = homingCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update missiles
            missiles = missiles.filter(m => m.update(targetPos));
            
            // Draw missiles
            for (let missile of missiles) {
                missile.draw(ctx);
            }
            
            // Draw target
            ctx.fillStyle = '#66bb6a';
            ctx.beginPath();
            ctx.arc(targetPos.x, targetPos.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.fillText('üéØ', targetPos.x - 10, targetPos.y + 8);
            
            // Instructions
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.fillText(`Active Missiles: ${missiles.length}`, 20, 30);
            ctx.fillText('Move mouse to change target', 20, 55);
            
            requestAnimationFrame(updateHomingDemo);
        }
        updateHomingDemo();
        
        // ===================================
        // DEMO 6: MATRIX TRANSFORMATIONS
        // ===================================
        
        const matrixCanvas = document.getElementById('matrixDemo');
        const mtCtx = matrixCanvas.getContext('2d');
        let currentTransform = 'rotate';
        let transformTime = 0;
        
        // Spaceship shape
        const shipShape = [
            new Vector2D(30, 0),
            new Vector2D(-15, 15),
            new Vector2D(-10, 0),
            new Vector2D(-15, -15)
        ];
        
        function setTransform(type) {
            currentTransform = type;
            transformTime = 0;
        }
        
        function updateMatrixDemo() {
            const ctx = mtCtx;
            const width = matrixCanvas.width;
            const height = matrixCanvas.height;
            const center = new Vector2D(width / 2, height / 2);
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            transformTime += 0.02;
            
            // Original ship (gray)
            drawShip(ctx, center, shipShape, '#4fc3f7', 0.3);
            
            // Create transformation matrix
            let matrix = new Matrix2D();
            matrix.translate(center.x, center.y);
            
            if (currentTransform === 'rotate') {
                matrix.rotate(transformTime);
            } else if (currentTransform === 'scale') {
                const scale = 1 + Math.sin(transformTime) * 0.5;
                matrix.scale(scale, scale);
            } else if (currentTransform === 'translate') {
                const offset = Math.sin(transformTime) * 100;
                matrix.translate(offset, 0);
            } else if (currentTransform === 'combined') {
                matrix.rotate(transformTime);
                const scale = 1 + Math.sin(transformTime * 2) * 0.3;
                matrix.scale(scale, scale);
            }
            
            // Transform and draw ship
            const transformed = shipShape.map(p => {
                // Apply matrix (translate to origin, transform, translate back)
                const centered = new Vector2D(p.x, p.y);
                return matrix.transformPoint(centered);
            });
            
            drawShip(ctx, new Vector2D(0, 0), transformed, '#66bb6a', 1, true);
            
            // Info
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.fillText(`Transform: ${currentTransform.toUpperCase()}`, 20, 30);
            ctx.fillText('Light blue: Original shape', 20, 55);
            ctx.fillText('Green: Transformed shape', 20, 80);
            
            requestAnimationFrame(updateMatrixDemo);
        }
        
        function drawShip(ctx, offset, points, color, alpha, fill = false) {
            ctx.globalAlpha = alpha;
            
            if (fill) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(points[0].x + offset.x, points[0].y + offset.y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x + offset.x, points[i].y + offset.y);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(points[0].x + offset.x, points[0].y + offset.y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x + offset.x, points[i].y + offset.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            ctx.globalAlpha = 1;
        }
        
        updateMatrixDemo();
    

// ===================================
// FILE 2 DEMOS (Advanced Content)
// ===================================

        // ===================================
        // NAVIGATION
        // ===================================
        
        function showLevel(level) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            
            // Show selected section
            document.getElementById(level).classList.add('active');
            
            // Update buttons
            document.querySelectorAll('.level-button').forEach(b => b.classList.remove('active'));
            event.target.closest('.level-button').classList.add('active');
            
            // Update progress bar
            const progress = document.getElementById('overallProgress');
            if (level === 'intermediate') {
                progress.style.width = '33%';
                progress.textContent = 'Level 2: Intermediate';
            } else if (level === 'advanced') {
                progress.style.width = '66%';
                progress.textContent = 'Level 3: Advanced';
            } else if (level === 'expert') {
                progress.style.width = '100%';
                progress.textContent = 'Level 4: Expert';
            }
        }
        
        // ===================================
        // LERP DEMO
        // ===================================
        
        const lerpCanvas = document.getElementById('lerpDemo');
        const lerpCtx = lerpCanvas.getContext('2d');
        let lerpTarget = new Vector2D(450, 250);
        let lerpCamera = new Vector2D(450, 250);
        let lerpAmount = 0.1;
        
        lerpCanvas.addEventListener('mousemove', (e) => {
            const rect = lerpCanvas.getBoundingClientRect();
            lerpTarget = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
        });
        
        function updateLerpAmount(value) {
            lerpAmount = value / 100;
            document.getElementById('lerpValue').textContent = lerpAmount.toFixed(2);
        }
        
        function resetLerpDemo() {
            lerpCamera = new Vector2D(450, 250);
            lerpTarget = new Vector2D(450, 250);
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function updateLerpDemo() {
            const ctx = lerpCtx;
            const width = lerpCanvas.width;
            const height = lerpCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update camera position
            lerpCamera.x = lerp(lerpCamera.x, lerpTarget.x, lerpAmount);
            lerpCamera.y = lerp(lerpCamera.y, lerpTarget.y, lerpAmount);
            
            // Draw connection line
            ctx.strokeStyle = '#4fc3f7';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lerpCamera.x, lerpCamera.y);
            ctx.lineTo(lerpTarget.x, lerpTarget.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw target (player)
            ctx.fillStyle = '#66bb6a';
            ctx.beginPath();
            ctx.arc(lerpTarget.x, lerpTarget.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText('üë§', lerpTarget.x - 10, lerpTarget.y + 8);
            
            // Draw camera
            ctx.fillStyle = '#ff5252';
            ctx.beginPath();
            ctx.arc(lerpCamera.x, lerpCamera.y, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText('üì∑', lerpCamera.x - 8, lerpCamera.y + 6);
            
            // Info
            const distance = lerpCamera.distance(lerpTarget);
            const info = document.getElementById('lerpInfo');
            info.innerHTML = `<strong>Distance:</strong> ${distance.toFixed(1)} pixels<br>
                              <strong>Lerp Amount:</strong> ${lerpAmount.toFixed(2)} (${(lerpAmount * 100).toFixed(0)}% per frame)<br>
                              <strong>Effect:</strong> ${lerpAmount < 0.05 ? 'Very slow, cinematic' : lerpAmount < 0.15 ? 'Smooth following' : 'Quick response'}`;
            
            requestAnimationFrame(updateLerpDemo);
        }
        updateLerpDemo();
        
        // ===================================
        // PHYSICS DEMO
        // ===================================
        
        const physicsCanvas = document.getElementById('physicsDemo');
        const physicsCtx = physicsCanvas.getContext('2d');
        
        class PhysicsObject {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(0, 0);
                this.acceleration = new Vector2D(0, 0);
                this.angle = 0;
                this.mass = 1;
                this.friction = 0.99;
            }
            
            applyForce(force) {
                let f = force.copy();
                f.divide(this.mass);
                this.acceleration.add(f);
            }
            
            update() {
                this.velocity.add(this.acceleration);
                this.velocity.multiply(this.friction);
                this.position.add(this.velocity);
                this.acceleration.multiply(0);
                
                // Wrap around screen
                if (this.position.x < 0) this.position.x = physicsCanvas.width;
                if (this.position.x > physicsCanvas.width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = physicsCanvas.height;
                if (this.position.y > physicsCanvas.height) this.position.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);
                
                // Draw ship
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-10, 10);
                ctx.lineTo(-5, 0);
                ctx.lineTo(-10, -10);
                ctx.closePath();
                ctx.fill();
                
                // Draw thrust
                if (keys.w) {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-5, 3);
                    ctx.lineTo(-15, 0);
                    ctx.lineTo(-5, -3);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Draw velocity vector
                if (this.velocity.length() > 0.5) {
                    const vel = this.velocity.copy().normalize().multiply(30);
                    ctx.strokeStyle = '#66bb6a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    ctx.lineTo(this.position.x + vel.x, this.position.y + vel.y);
                    ctx.stroke();
                }
            }
        }
        
        class Planet {
            constructor(x, y, mass = 1000) {
                this.position = new Vector2D(x, y);
                this.mass = mass;
                this.radius = Math.sqrt(mass) * 0.5;
            }
            
            attract(obj) {
                const force = this.position.subtract(obj.position);
                const distance = Math.max(force.length(), 20);
                const strength = (this.mass * obj.mass) / (distance * distance);
                force.normalize();
                force.multiply(strength * 0.1);
                return force;
            }
            
            draw(ctx) {
                ctx.fillStyle = '#ff5252';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Gravity field visualization
                ctx.strokeStyle = 'rgba(255, 82, 82, 0.3)';
                ctx.lineWidth = 1;
                for (let r = this.radius + 20; r < 200; r += 20) {
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        let ship = new PhysicsObject(450, 300);
        let planets = [];
        let keys = { w: false, a: false, s: false, d: false };
        let gravityEnabled = true;
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'w') keys.w = true;
            if (e.key === 'a') keys.a = true;
            if (e.key === 's') keys.s = true;
            if (e.key === 'd') keys.d = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w') keys.w = false;
            if (e.key === 'a') keys.a = false;
            if (e.key === 's') keys.s = false;
            if (e.key === 'd') keys.d = false;
        });
        
        function resetPhysics() {
            ship = new PhysicsObject(450, 300);
            planets = [];
        }
        
        function addPlanet() {
            const x = Math.random() * (physicsCanvas.width - 200) + 100;
            const y = Math.random() * (physicsCanvas.height - 200) + 100;
            planets.push(new Planet(x, y, 500 + Math.random() * 1000));
        }
        
        function toggleGravity() {
            gravityEnabled = !gravityEnabled;
        }
        
        function updatePhysicsDemo() {
            const ctx = physicsCtx;
            const width = physicsCanvas.width;
            const height = physicsCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Handle input
            if (keys.w) {
                const thrust = new Vector2D(Math.cos(ship.angle), Math.sin(ship.angle));
                thrust.multiply(0.3);
                ship.applyForce(thrust);
            }
            
            if (keys.a) ship.angle -= 0.05;
            if (keys.d) ship.angle += 0.05;
            
            // Apply gravity
            if (gravityEnabled) {
                for (let planet of planets) {
                    const gravity = planet.attract(ship);
                    ship.applyForce(gravity);
                }
            }
            
            ship.update();
            
            // Draw planets
            for (let planet of planets) {
                planet.draw(ctx);
            }
            
            // Draw ship
            ship.draw(ctx);
            
            // Info
            const info = document.getElementById('physicsInfo');
            info.innerHTML = `<strong>Speed:</strong> ${ship.velocity.length().toFixed(1)}<br>
                              <strong>Angle:</strong> ${(ship.angle * 180 / Math.PI).toFixed(0)}¬∞<br>
                              <strong>Planets:</strong> ${planets.length}<br>
                              <strong>Gravity:</strong> ${gravityEnabled ? 'ON' : 'OFF'}<br>
                              <strong>Controls:</strong> W=Thrust, A/D=Rotate`;
            
            requestAnimationFrame(updatePhysicsDemo);
        }
        updatePhysicsDemo();
        
        // ===================================
        // COLLISION DEMO
        // ===================================
        
        const collisionCanvas = document.getElementById('collisionDemo');
        const collisionCtx = collisionCanvas.getContext('2d');
        let balls = [];
        let collisionType = 'circle';
        
        class Ball {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6
                );
                this.radius = 15 + Math.random() * 15;
                this.mass = this.radius;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }
            
            update(width, height) {
                this.position.add(this.velocity);
                
                // Bounce off walls
                if (this.position.x - this.radius < 0 || this.position.x + this.radius > width) {
                    this.velocity.x *= -0.9;
                    this.position.x = Math.max(this.radius, Math.min(width - this.radius, this.position.x));
                }
                
                if (this.position.y - this.radius < 0 || this.position.y + this.radius > height) {
                    this.velocity.y *= -0.9;
                    this.position.y = Math.max(this.radius, Math.min(height - this.radius, this.position.y));
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function addBall() {
            const x = Math.random() * (collisionCanvas.width - 100) + 50;
            const y = Math.random() * (collisionCanvas.height - 100) + 50;
            balls.push(new Ball(x, y));
        }
        
        function clearBalls() {
            balls = [];
        }
        
        function toggleCollisionType() {
            collisionType = collisionType === 'circle' ? 'rectangle' : 'circle';
        }
        
        function handleBallCollision(b1, b2) {
            const normal = b2.position.subtract(b1.position);
            const distance = normal.length();
            const overlap = (b1.radius + b2.radius) - distance;
            
            if (overlap <= 0) return;
            
            normal.normalize();
            
            // Separate
            b1.position.add(normal.copy().multiply(-overlap / 2));
            b2.position.add(normal.copy().multiply(overlap / 2));
            
            // Bounce
            const relativeVel = b1.velocity.subtract(b2.velocity);
            const velAlongNormal = relativeVel.dot(normal);
            
            if (velAlongNormal > 0) return;
            
            const restitution = 0.8;
            const impulse = -(1 + restitution) * velAlongNormal;
            const totalMass = b1.mass + b2.mass;
            const impulsePerMass = impulse / totalMass;
            
            const impulseVector = normal.copy().multiply(impulsePerMass);
            b1.velocity.add(impulseVector.copy().multiply(b2.mass));
            b2.velocity.add(impulseVector.copy().multiply(-b1.mass));
        }
        
        function updateCollisionDemo() {
            const ctx = collisionCtx;
            const width = collisionCanvas.width;
            const height = collisionCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update balls
            for (let ball of balls) {
                ball.update(width, height);
            }
            
            // Check collisions
            let collisions = 0;
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const distance = balls[i].position.distance(balls[j].position);
                    if (distance < balls[i].radius + balls[j].radius) {
                        handleBallCollision(balls[i], balls[j]);
                        collisions++;
                    }
                }
            }
            
            // Draw balls
            for (let ball of balls) {
                ball.draw(ctx);
            }
            
            // Info
            const info = document.getElementById('collisionInfo');
            info.innerHTML = `<strong>Balls:</strong> ${balls.length}<br>
                              <strong>Collisions This Frame:</strong> ${collisions}<br>
                              <strong>Checks Per Frame:</strong> ${(balls.length * (balls.length - 1)) / 2}`;
            
            requestAnimationFrame(updateCollisionDemo);
        }
        updateCollisionDemo();
        
        // Initialize with some balls
        for (let i = 0; i < 10; i++) {
            addBall();
        }
        
        // ===================================
        // QUATERNION DEMO
        // ===================================
        
        const quaternionCanvas = document.getElementById('quaternionDemo');
        const qCtx = quaternionCanvas.getContext('2d');
        
        class Quaternion {
            constructor(x = 0, y = 0, z = 0, w = 1) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            
            static fromAxisAngle(axis, angle) {
                const halfAngle = angle / 2;
                const s = Math.sin(halfAngle);
                return new Quaternion(
                    axis.x * s,
                    axis.y * s,
                    axis.z * s,
                    Math.cos(halfAngle)
                );
            }
            
            slerp(target, t) {
                let dot = this.x * target.x + this.y * target.y + this.z * target.z + this.w * target.w;
                
                if (dot < 0) {
                    target = new Quaternion(-target.x, -target.y, -target.z, -target.w);
                    dot = -dot;
                }
                
                if (dot > 0.9995) {
                    return new Quaternion(
                        this.x + t * (target.x - this.x),
                        this.y + t * (target.y - this.y),
                        this.z + t * (target.z - this.z),
                        this.w + t * (target.w - this.w)
                    );
                }
                
                const theta = Math.acos(dot);
                const sinTheta = Math.sin(theta);
                const w1 = Math.sin((1 - t) * theta) / sinTheta;
                const w2 = Math.sin(t * theta) / sinTheta;
                
                return new Quaternion(
                    this.x * w1 + target.x * w2,
                    this.y * w1 + target.y * w2,
                    this.z * w1 + target.z * w2,
                    this.w * w1 + target.w * w2
                );
            }
            
            toEuler() {
                const sinr_cosp = 2 * (this.w * this.x + this.y * this.z);
                const cosr_cosp = 1 - 2 * (this.x * this.x + this.y * this.y);
                const roll = Math.atan2(sinr_cosp, cosr_cosp);
                
                const sinp = 2 * (this.w * this.y - this.z * this.x);
                const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI / 2 : Math.asin(sinp);
                
                const siny_cosp = 2 * (this.w * this.z + this.x * this.y);
                const cosy_cosp = 1 - 2 * (this.y * this.y + this.z * this.z);
                const yaw = Math.atan2(siny_cosp, cosy_cosp);
                
                return { roll, pitch, yaw };
            }
        }
        
        let quatRotationType = 'quaternion';
        let quatStart = Quaternion.fromAxisAngle(new Vector2D(0, 0, 1), 0);
        let quatTarget = Quaternion.fromAxisAngle(new Vector2D(0, 0, 1), Math.PI);
        let quatCurrent = quatStart;
        let quatT = 0;
        let eulerAngleStart = 0;
        let eulerAngleTarget = Math.PI;
        let eulerAngleCurrent = 0;
        
        function setRotationType(type) {
            quatRotationType = type;
            quatT = 0;
            quatCurrent = quatStart;
            eulerAngleCurrent = eulerAngleStart;
        }
        
        function randomTarget() {
            quatT = 0;
            const randomAngle = Math.random() * Math.PI * 2;
            quatTarget = Quaternion.fromAxisAngle(new Vector2D(0, 0, 1), randomAngle);
            eulerAngleTarget = randomAngle;
        }
        
        function updateQuaternionDemo() {
            const ctx = qCtx;
            const width = quaternionCanvas.width;
            const height = quaternionCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Update rotation
            if (quatT < 1) {
                quatT += 0.01;
                
                if (quatRotationType === 'quaternion') {
                    quatCurrent = quatStart.slerp(quatTarget, quatT);
                } else {
                    // Linear interpolation of Euler angles (can cause weird paths)
                    eulerAngleCurrent = eulerAngleStart + (eulerAngleTarget - eulerAngleStart) * quatT;
                }
            }
            
            // Get current angle
            let currentAngle;
            if (quatRotationType === 'quaternion') {
                const euler = quatCurrent.toEuler();
                currentAngle = euler.yaw;
            } else {
                currentAngle = eulerAngleCurrent;
            }
            
            // Draw reference circle
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw start position (faded)
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(eulerAngleStart);
            ctx.globalAlpha = 0.3;
            drawShipSimple(ctx, '#4fc3f7');
            ctx.restore();
            
            // Draw target position (faded)
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(eulerAngleTarget);
            ctx.globalAlpha = 0.3;
            drawShipSimple(ctx, '#66bb6a');
            ctx.restore();
            
            // Draw current position
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentAngle);
            ctx.globalAlpha = 1;
            drawShipSimple(ctx, quatRotationType === 'quaternion' ? '#ffd700' : '#ff5252');
            ctx.restore();
            
            // Draw path traveled
            ctx.strokeStyle = quatRotationType === 'quaternion' ? '#ffd700' : '#ff5252';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, 150, eulerAngleStart, currentAngle, eulerAngleStart > currentAngle);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Info
            const info = document.getElementById('quaternionInfo');
            const rotated = ((currentAngle - eulerAngleStart) * 180 / Math.PI).toFixed(0);
            info.innerHTML = `<strong>Method:</strong> ${quatRotationType === 'quaternion' ? 'Quaternion (SLERP)' : 'Euler Angles (Linear)'}<br>
                              <strong>Progress:</strong> ${(quatT * 100).toFixed(0)}%<br>
                              <strong>Rotated:</strong> ${rotated}¬∞<br>
                              <strong>Blue:</strong> Start position | <strong>Green:</strong> Target<br>
                              <strong>${quatRotationType === 'quaternion' ? 'Yellow' : 'Red'}:</strong> Current (${quatRotationType === 'quaternion' ? 'shortest path!' : 'linear interpolation'})`;
            
            requestAnimationFrame(updateQuaternionDemo);
        }
        
        function drawShipSimple(ctx, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(30, 0);
            ctx.lineTo(-15, 15);
            ctx.lineTo(-10, 0);
            ctx.lineTo(-15, -15);
            ctx.closePath();
            ctx.fill();
        }
        
        updateQuaternionDemo();
        
        // ===================================
        // STEERING BEHAVIORS DEMO
        // ===================================
        
        const steeringCanvas = document.getElementById('steeringDemo');
        const stCtx = steeringCanvas.getContext('2d');
        
        class SteeringAgent {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(Math.random() - 0.5, Math.random() - 0.5);
                this.maxSpeed = 4;
                this.maxForce = 0.2;
                this.radius = 8;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.wanderAngle = Math.random() * Math.PI * 2;
            }
            
            seek(target) {
                let desired = target.subtract(this.position);
                desired.normalize();
                desired.multiply(this.maxSpeed);
                let steer = desired.subtract(this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            flee(target) {
                let desired = this.position.subtract(target);
                const distance = desired.length();
                if (distance > 200) return new Vector2D(0, 0);
                desired.normalize();
                desired.multiply(this.maxSpeed);
                let steer = desired.subtract(this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            arrive(target, slowingRadius = 100) {
                let desired = target.subtract(this.position);
                let distance = desired.length();
                desired.normalize();
                
                if (distance < slowingRadius) {
                    let speed = this.maxSpeed * (distance / slowingRadius);
                    desired.multiply(speed);
                } else {
                    desired.multiply(this.maxSpeed);
                }
                
                let steer = desired.subtract(this.velocity);
                steer.limit(this.maxForce);
                return steer;
            }
            
            pursue(target) {
                let distance = target.position.distance(this.position);
                let prediction = distance / this.maxSpeed;
                let futurePos = target.position.copy();
                futurePos.add(target.velocity.copy().multiply(prediction));
                return this.seek(futurePos);
            }
            
            wander() {
                this.wanderAngle += (Math.random() - 0.5) * 0.5;
                let wanderForce = new Vector2D(
                    Math.cos(this.wanderAngle),
                    Math.sin(this.wanderAngle)
                );
                wanderForce.multiply(0.5);
                return wanderForce;
            }
            
            separate(agents) {
                let steer = new Vector2D(0, 0);
                let count = 0;
                
                for (let other of agents) {
                    if (other === this) continue;
                    let distance = this.position.distance(other.position);
                    if (distance < 50 && distance > 0) {
                        let diff = this.position.subtract(other.position);
                        diff.normalize();
                        diff.divide(distance);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.divide(count);
                    steer.normalize();
                    steer.multiply(this.maxSpeed);
                    steer.add(this.velocity.copy().multiply(-1));
                    steer.limit(this.maxForce);
                }
                
                return steer;
            }
            
            align(agents) {
                let sum = new Vector2D(0, 0);
                let count = 0;
                
                for (let other of agents) {
                    if (other === this) continue;
                    let distance = this.position.distance(other.position);
                    if (distance < 50) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divide(count);
                    sum.normalize();
                    sum.multiply(this.maxSpeed);
                    let steer = sum.subtract(this.velocity);
                    steer.limit(this.maxForce);
                    return steer;
                }
                
                return new Vector2D(0, 0);
            }
            
            cohesion(agents) {
                let sum = new Vector2D(0, 0);
                let count = 0;
                
                for (let other of agents) {
                    if (other === this) continue;
                    let distance = this.position.distance(other.position);
                    if (distance < 50) {
                        sum.add(other.position);
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.divide(count);
                    return this.seek(sum);
                }
                
                return new Vector2D(0, 0);
            }
            
            applyForce(force) {
                this.velocity.add(force);
                this.velocity.limit(this.maxSpeed);
            }
            
            update(width, height) {
                this.position.add(this.velocity);
                
                // Wrap around
                if (this.position.x < 0) this.position.x = width;
                if (this.position.x > width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = height;
                if (this.position.y > height) this.position.y = 0;
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Direction indicator
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.position.x, this.position.y);
                ctx.lineTo(
                    this.position.x + Math.cos(angle) * 15,
                    this.position.y + Math.sin(angle) * 15
                );
                ctx.stroke();
            }
        }
        
        let steeringAgents = [];
        let steeringBehavior = 'seek';
        let steeringTarget = new Vector2D(450, 300);
        
        steeringCanvas.addEventListener('mousemove', (e) => {
            const rect = steeringCanvas.getBoundingClientRect();
            steeringTarget = new Vector2D(
                e.clientX - rect.left,
                e.clientY - rect.top
            );
        });
        
        function setBehavior(type) {
            steeringBehavior = type;
        }
        
        function addAgent() {
            const x = Math.random() * steeringCanvas.width;
            const y = Math.random() * steeringCanvas.height;
            steeringAgents.push(new SteeringAgent(x, y));
        }
        
        // Initialize with some agents
        for (let i = 0; i < 20; i++) {
            addAgent();
        }
        
        function updateSteeringDemo() {
            const ctx = stCtx;
            const width = steeringCanvas.width;
            const height = steeringCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Apply behaviors
            for (let agent of steeringAgents) {
                let force = new Vector2D(0, 0);
                
                switch(steeringBehavior) {
                    case 'seek':
                        force = agent.seek(steeringTarget);
                        break;
                    case 'flee':
                        force = agent.flee(steeringTarget);
                        break;
                    case 'arrive':
                        force = agent.arrive(steeringTarget);
                        break;
                    case 'pursue':
                        force = agent.pursue({ position: steeringTarget, velocity: new Vector2D(0, 0) });
                        break;
                    case 'wander':
                        force = agent.wander();
                        break;
                    case 'flock':
                        let sep = agent.separate(steeringAgents).multiply(1.5);
                        let ali = agent.align(steeringAgents).multiply(1.0);
                        let coh = agent.cohesion(steeringAgents).multiply(1.0);
                        force.add(sep).add(ali).add(coh);
                        break;
                }
                
                agent.applyForce(force);
                agent.update(width, height);
            }
            
            // Draw target
            if (steeringBehavior !== 'wander' && steeringBehavior !== 'flock') {
                ctx.fillStyle = steeringBehavior === 'flee' ? '#ff5252' : '#66bb6a';
                ctx.beginPath();
                ctx.arc(steeringTarget.x, steeringTarget.y, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw agents
            for (let agent of steeringAgents) {
                agent.draw(ctx);
            }
            
            // Info
            const info = document.getElementById('steeringInfo');
            info.innerHTML = `<strong>Behavior:</strong> ${steeringBehavior.toUpperCase()}<br>
                              <strong>Agents:</strong> ${steeringAgents.length}<br>
                              <strong>Tip:</strong> ${getBehaviorTip(steeringBehavior)}`;
            
            requestAnimationFrame(updateSteeringDemo);
        }
        
        function getBehaviorTip(behavior) {
            const tips = {
                seek: 'Agents move directly toward target',
                flee: 'Agents run away from danger',
                arrive: 'Agents slow down as they approach',
                pursue: 'Would predict moving target\'s future position',
                wander: 'Agents explore randomly',
                flock: 'Emergent behavior from 3 simple rules!'
            };
            return tips[behavior] || '';
        }
        
        updateSteeringDemo();
        
        // ===================================
        // BEZIER DEMO
        // ===================================
        
        const bezierCanvas = document.getElementById('bezierDemo');
        const bzCtx = bezierCanvas.getContext('2d');
        
        let bezierPoints = [
            new Vector2D(100, 300),
            new Vector2D(300, 100),
            new Vector2D(600, 500),
            new Vector2D(800, 300)
        ];
        let bezierT = 0;
        let bezierAnimating = false;
        let bezierDragging = -1;
        
        function cubicBezier(p0, p1, p2, p3, t) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;
            
            let point = new Vector2D(
                uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
                uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
            );
            
            return point;
        }
        
        bezierCanvas.addEventListener('mousedown', (e) => {
            const rect = bezierCanvas.getBoundingClientRect();
            const mousePos = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
            
            for (let i = 0; i < bezierPoints.length; i++) {
                if (mousePos.distance(bezierPoints[i]) < 20) {
                    bezierDragging = i;
                    break;
                }
            }
        });
        
        bezierCanvas.addEventListener('mousemove', (e) => {
            if (bezierDragging >= 0) {
                const rect = bezierCanvas.getBoundingClientRect();
                bezierPoints[bezierDragging] = new Vector2D(
                    e.clientX - rect.left,
                    e.clientY - rect.top
                );
            }
        });
        
        bezierCanvas.addEventListener('mouseup', () => {
            bezierDragging = -1;
        });
        
        function resetBezier() {
            bezierPoints = [
                new Vector2D(100, 300),
                new Vector2D(300, 100),
                new Vector2D(600, 500),
                new Vector2D(800, 300)
            ];
            bezierT = 0;
            bezierAnimating = false;
        }
        
        function addBezierPoint() {
            if (bezierPoints.length < 6) {
                const last = bezierPoints[bezierPoints.length - 1];
                bezierPoints.push(new Vector2D(last.x + 100, last.y));
            }
        }
        
        function toggleAnimation() {
            bezierAnimating = !bezierAnimating;
            if (bezierAnimating) bezierT = 0;
        }
        
        function updateBezierDemo() {
            const ctx = bzCtx;
            const width = bezierCanvas.width;
            const height = bezierCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            if (bezierPoints.length >= 4) {
                // Draw curve
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let t = 0; t <= 1; t += 0.01) {
                    const point = cubicBezier(bezierPoints[0], bezierPoints[1], bezierPoints[2], bezierPoints[3], t);
                    if (t === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                
                // Draw control lines
                ctx.strokeStyle = '#30363d';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(bezierPoints[0].x, bezierPoints[0].y);
                ctx.lineTo(bezierPoints[1].x, bezierPoints[1].y);
                ctx.moveTo(bezierPoints[2].x, bezierPoints[2].y);
                ctx.lineTo(bezierPoints[3].x, bezierPoints[3].y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw control points
                for (let i = 0; i < bezierPoints.length; i++) {
                    ctx.fillStyle = i === 0 || i === 3 ? '#66bb6a' : '#ffa726';
                    ctx.beginPath();
                    ctx.arc(bezierPoints[i].x, bezierPoints[i].y, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw animated object
                if (bezierAnimating) {
                    bezierT += 0.005;
                    if (bezierT > 1) bezierT = 0;
                }
                
                const currentPoint = cubicBezier(bezierPoints[0], bezierPoints[1], bezierPoints[2], bezierPoints[3], bezierT);
                ctx.fillStyle = '#ff5252';
                ctx.beginPath();
                ctx.arc(currentPoint.x, currentPoint.y, 12, 0, Math.PI * 2);
                ctx.fill();
            }
            
            requestAnimationFrame(updateBezierDemo);
        }
        
        updateBezierDemo();
        
        // ===================================
        // SPATIAL HASH DEMO
        // ===================================
        
        const spatialCanvas = document.getElementById('spatialHashDemo');
        const spCtx = spatialCanvas.getContext('2d');
        
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            
            hash(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            }
            
            insert(obj) {
                const key = this.hash(obj.position.x, obj.position.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(obj);
            }
            
            getNearby(obj) {
                const nearby = [];
                const cellX = Math.floor(obj.position.x / this.cellSize);
                const cellY = Math.floor(obj.position.y / this.cellSize);
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cellX + dx},${cellY + dy}`;
                        if (this.grid.has(key)) {
                            nearby.push(...this.grid.get(key));
                        }
                    }
                }
                
                return nearby;
            }
            
            clear() {
                this.grid.clear();
            }
        }
        
        let spatialObjects = [];
        let spatialHash = new SpatialHash(100);
        let useOptimization = true;
        let showGrid = true;
        let spatialChecks = 0;
        
        class SpatialObject {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3);
                this.radius = 8;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }
            
            update(width, height) {
                this.position.add(this.velocity);
                
                if (this.position.x < this.radius || this.position.x > width - this.radius) {
                    this.velocity.x *= -1;
                }
                if (this.position.y < this.radius || this.position.y > height - this.radius) {
                    this.velocity.y *= -1;
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function addObjects(count) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * (spatialCanvas.width - 100) + 50;
                const y = Math.random() * (spatialCanvas.height - 100) + 50;
                spatialObjects.push(new SpatialObject(x, y));
            }
        }
        
        function clearSpatial() {
            spatialObjects = [];
        }
        
        function toggleOptimization() {
            useOptimization = !useOptimization;
        }
        
        function toggleGridDisplay() {
            showGrid = !showGrid;
        }
        
        // Initialize with some objects
        addObjects(50);
        
        function updateSpatialDemo() {
            const ctx = spCtx;
            const width = spatialCanvas.width;
            const height = spatialCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            if (showGrid && useOptimization) {
                ctx.strokeStyle = '#1a2332';
                ctx.lineWidth = 1;
                for (let x = 0; x < width; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }
            
            // Update objects
            for (let obj of spatialObjects) {
                obj.update(width, height);
            }
            
            // Check collisions
            spatialChecks = 0;
            if (useOptimization) {
                spatialHash.clear();
                for (let obj of spatialObjects) {
                    spatialHash.insert(obj);
                }
                
                for (let obj of spatialObjects) {
                    const nearby = spatialHash.getNearby(obj);
                    spatialChecks += nearby.length;
                }
            } else {
                spatialChecks = spatialObjects.length * (spatialObjects.length - 1) / 2;
            }
            
            // Draw objects
            for (let obj of spatialObjects) {
                obj.draw(ctx);
            }
            
            // Info
            const info = document.getElementById('spatialInfo');
            const maxChecks = spatialObjects.length * (spatialObjects.length - 1) / 2;
            const efficiency = maxChecks > 0 ? ((maxChecks - spatialChecks) / maxChecks * 100).toFixed(1) : 0;
            
            info.innerHTML = `<strong>Objects:</strong> ${spatialObjects.length}<br>
                              <strong>Method:</strong> ${useOptimization ? 'Spatial Hash' : 'Brute Force'}<br>
                              <strong>Collision Checks:</strong> ${spatialChecks} / ${maxChecks}<br>
                              <strong>Efficiency Gain:</strong> ${useOptimization ? efficiency + '% fewer checks!' : 'N/A'}<br>
                              <strong>Grid:</strong> ${showGrid ? 'Visible' : 'Hidden'}`;
            
            requestAnimationFrame(updateSpatialDemo);
        }
        
        updateSpatialDemo();
        
        // ===================================
        // QUADTREE DEMO
        // ===================================
        
        const quadCanvas = document.getElementById('quadTreeDemo');
        const qdCtx = quadCanvas.getContext('2d');
        
        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            
            contains(point) {
                return point.x >= this.x && point.x < this.x + this.w &&
                       point.y >= this.y && point.y < this.y + this.h;
            }
            
            intersects(range) {
                return !(this.x > range.x + range.w || 
                         this.x + this.w < range.x ||
                         this.y > range.y + range.h ||
                         this.y + this.h < range.y);
            }
        }
        
        class QuadTree {
            constructor(boundary, capacity = 4) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.objects = [];
                this.divided = false;
            }
            
            subdivide() {
                const x = this.boundary.x;
                const y = this.boundary.y;
                const w = this.boundary.w / 2;
                const h = this.boundary.h / 2;
                
                this.northeast = new QuadTree(new Rectangle(x + w, y, w, h), this.capacity);
                this.northwest = new QuadTree(new Rectangle(x, y, w, h), this.capacity);
                this.southeast = new QuadTree(new Rectangle(x + w, y + h, w, h), this.capacity);
                this.southwest = new QuadTree(new Rectangle(x, y + h, w, h), this.capacity);
                
                this.divided = true;
            }
            
            insert(obj) {
                if (!this.boundary.contains(obj.position)) {
                    return false;
                }
                
                if (this.objects.length < this.capacity) {
                    this.objects.push(obj);
                    return true;
                }
                
                if (!this.divided) {
                    this.subdivide();
                }
                
                return this.northeast.insert(obj) ||
                       this.northwest.insert(obj) ||
                       this.southeast.insert(obj) ||
                       this.southwest.insert(obj);
            }
            
            query(range, found = []) {
                if (!this.boundary.intersects(range)) {
                    return found;
                }
                
                for (let obj of this.objects) {
                    if (range.contains(obj.position)) {
                        found.push(obj);
                    }
                }
                
                if (this.divided) {
                    this.northeast.query(range, found);
                    this.northwest.query(range, found);
                    this.southeast.query(range, found);
                    this.southwest.query(range, found);
                }
                
                return found;
            }
            
            draw(ctx) {
                ctx.strokeStyle = '#30363d';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.boundary.x, this.boundary.y, this.boundary.w, this.boundary.h);
                
                if (this.divided) {
                    this.northeast.draw(ctx);
                    this.northwest.draw(ctx);
                    this.southeast.draw(ctx);
                    this.southwest.draw(ctx);
                }
            }
        }
        
        let quadTree;
        let quadObjects = [];
        let quadQueryRange = null;
        let showQueryRange = false;
        let quadMousePos = new Vector2D(450, 300);
        
        function initQuadTree() {
            quadTree = new QuadTree(new Rectangle(0, 0, quadCanvas.width, quadCanvas.height), 4);
            for (let obj of quadObjects) {
                quadTree.insert(obj);
            }
        }
        
        function addQuadObjects(count) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * quadCanvas.width;
                const y = Math.random() * quadCanvas.height;
                quadObjects.push(new SpatialObject(x, y));
            }
            initQuadTree();
        }
        
        function clearQuadTree() {
            quadObjects = [];
            initQuadTree();
        }
        
        function toggleQueryRange() {
            showQueryRange = !showQueryRange;
        }
        
        quadCanvas.addEventListener('mousemove', (e) => {
            const rect = quadCanvas.getBoundingClientRect();
            quadMousePos = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        // Initialize
        addQuadObjects(100);
        
        function updateQuadTreeDemo() {
            const ctx = qdCtx;
            const width = quadCanvas.width;
            const height = quadCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Rebuild tree each frame
            initQuadTree();
            
            // Draw quadtree
            quadTree.draw(ctx);
            
            // Query range
            let foundObjects = [];
            if (showQueryRange) {
                quadQueryRange = new Rectangle(quadMousePos.x - 75, quadMousePos.y - 75, 150, 150);
                foundObjects = quadTree.query(quadQueryRange);
                
                ctx.strokeStyle = '#66bb6a';
                ctx.lineWidth = 2;
                ctx.strokeRect(quadQueryRange.x, quadQueryRange.y, quadQueryRange.w, quadQueryRange.h);
            }
            
            // Draw objects
            for (let obj of quadObjects) {
                obj.update(width, height);
                
                if (showQueryRange && foundObjects.includes(obj)) {
                    ctx.fillStyle = '#66bb6a';
                    ctx.beginPath();
                    ctx.arc(obj.position.x, obj.position.y, obj.radius + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                obj.draw(ctx);
            }
            
            // Info
            const info = document.getElementById('quadTreeInfo');
            info.innerHTML = `<strong>Objects:</strong> ${quadObjects.length}<br>
                              <strong>Query Range:</strong> ${showQueryRange ? 'ON (green square)' : 'OFF'}<br>
                              ${showQueryRange ? `<strong>Found in Range:</strong> ${foundObjects.length}<br>` : ''}
                              <strong>Tip:</strong> Watch tree subdivide where objects cluster!`;
            
            requestAnimationFrame(updateQuadTreeDemo);
        }
        
        updateQuadTreeDemo();
        
        // ===================================
        // OBJECT POOLING DEMO
        // ===================================
        
        const poolCanvas = document.getElementById('poolingDemo');
        const plCtx = poolCanvas.getContext('2d');
        
        class ObjectPool {
            constructor(createFunc, initialSize = 20) {
                this.createFunc = createFunc;
                this.available = [];
                this.inUse = [];
                
                for (let i = 0; i < initialSize; i++) {
                    this.available.push(this.createFunc());
                }
            }
            
            get(...args) {
                let obj;
                
                if (this.available.length > 0) {
                    obj = this.available.pop();
                } else {
                    obj = this.createFunc();
                }
                
                if (obj.reset) {
                    obj.reset(...args);
                }
                
                this.inUse.push(obj);
                obj.active = true;
                
                return obj;
            }
            
            update() {
                for (let i = this.inUse.length - 1; i >= 0; i--) {
                    if (!this.inUse[i].active) {
                        this.available.push(this.inUse[i]);
                        this.inUse.splice(i, 1);
                    }
                }
            }
        }
        
        class Particle {
            constructor() {
                this.position = new Vector2D(0, 0);
                this.velocity = new Vector2D(0, 0);
                this.life = 0;
                this.maxLife = 60;
                this.active = false;
                this.radius = 3;
                this.color = '#4fc3f7';
            }
            
            reset(x, y) {
                this.position = new Vector2D(x, y);
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.velocity = new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed);
                this.life = this.maxLife;
                this.active = true;
            }
            
            update() {
                this.position.add(this.velocity);
                this.life--;
                
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        let particlePool = new ObjectPool(() => new Particle(), 500);
        let usePooling = true;
        let spawnRate = 10;
        let frameCount = 0;
        let lastFrameTime = performance.now();
        let fps = 60;
        
        poolCanvas.addEventListener('click', (e) => {
            const rect = poolCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            for (let i = 0; i < spawnRate; i++) {
                if (usePooling) {
                    particlePool.get(x, y);
                } else {
                    const p = new Particle();
                    p.reset(x, y);
                    particlePool.inUse.push(p);
                }
            }
        });
        
        function togglePooling() {
            usePooling = !usePooling;
        }
        
        function increaseSpawn() {
            spawnRate = Math.min(spawnRate + 10, 100);
        }
        
        function decreaseSpawn() {
            spawnRate = Math.max(spawnRate - 10, 10);
        }
        
        function updatePoolingDemo() {
            const ctx = plCtx;
            const width = poolCanvas.width;
            const height = poolCanvas.height;
            const currentTime = performance.now();
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update particles
            for (let particle of particlePool.inUse) {
                particle.update();
                particle.draw(ctx);
            }
            
            if (usePooling) {
                particlePool.update();
            }
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
            }
            
            // Info
            const info = document.getElementById('poolingInfo');
            info.innerHTML = `<strong>Pooling:</strong> ${usePooling ? 'ON' : 'OFF'}<br>
                              <strong>Active Particles:</strong> ${particlePool.inUse.length}<br>
                              <strong>Pool Size:</strong> ${particlePool.available.length}<br>
                              <strong>Spawn Rate:</strong> ${spawnRate} per click<br>
                              <strong>FPS:</strong> ${fps}<br>
                              <strong>Click to spawn particles!</strong>`;
            
            requestAnimationFrame(updatePoolingDemo);
        }
        
        updatePoolingDemo();
        
        // ===================================
        // RAYCASTING DEMO
        // ===================================
        
        const raycastCanvas = document.getElementById('raycastDemo');
        const rcCtx = raycastCanvas.getContext('2d');
        
        class Wall {
            constructor(x1, y1, x2, y2) {
                this.start = new Vector2D(x1, y1);
                this.end = new Vector2D(x2, y2);
            }
            
            draw(ctx) {
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.start.x, this.start.y);
                ctx.lineTo(this.end.x, this.end.y);
                ctx.stroke();
            }
        }
        
        let walls = [];
        let raySource = new Vector2D(450, 300);
        let showAllRays = true;
        let rayAngles = 64;
        
        raycastCanvas.addEventListener('mousemove', (e) => {
            const rect = raycastCanvas.getBoundingClientRect();
            raySource = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        function addWall() {
            const x1 = Math.random() * raycastCanvas.width;
            const y1 = Math.random() * raycastCanvas.height;
            const angle = Math.random() * Math.PI * 2;
            const length = 50 + Math.random() * 150;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;
            walls.push(new Wall(x1, y1, x2, y2));
        }
        
        function clearWalls() {
            walls = [];
        }
        
        function toggleRayVisualization() {
            showAllRays = !showAllRays;
        }
        
        function rayIntersectsWall(rayOrigin, rayDir, wall) {
            const x1 = wall.start.x;
            const y1 = wall.start.y;
            const x2 = wall.end.x;
            const y2 = wall.end.y;
            
            const x3 = rayOrigin.x;
            const y3 = rayOrigin.y;
            const x4 = rayOrigin.x + rayDir.x;
            const y4 = rayOrigin.y + rayDir.y;
            
            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
            
            if (t > 0 && t < 1 && u > 0) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1),
                    distance: u
                };
            }
            
            return null;
        }
        
        // Add initial walls
        walls.push(new Wall(100, 100, 800, 100));
        walls.push(new Wall(800, 100, 800, 500));
        walls.push(new Wall(800, 500, 100, 500));
        walls.push(new Wall(100, 500, 100, 100));
        walls.push(new Wall(300, 200, 600, 400));
        walls.push(new Wall(400, 150, 500, 450));
        
        function updateRaycastDemo() {
            const ctx = rcCtx;
            const width = raycastCanvas.width;
            const height = raycastCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            if (showAllRays) {
                // Cast rays in all directions
                for (let i = 0; i < rayAngles; i++) {
                    const angle = (i / rayAngles) * Math.PI * 2;
                    const rayDir = new Vector2D(Math.cos(angle), Math.sin(angle)).multiply(1000);
                    
                    let closest = null;
                    let closestDist = Infinity;
                    
                    for (let wall of walls) {
                        const hit = rayIntersectsWall(raySource, rayDir, wall);
                        if (hit && hit.distance < closestDist) {
                            closest = hit;
                            closestDist = hit.distance;
                        }
                    }
                    
                    if (closest) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(raySource.x, raySource.y);
                        ctx.lineTo(closest.x, closest.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw walls
            for (let wall of walls) {
                wall.draw(ctx);
            }
            
            // Draw ray source
            ctx.fillStyle = '#66bb6a';
            ctx.beginPath();
            ctx.arc(raySource.x, raySource.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Info
            const info = document.getElementById('raycastInfo');
            info.innerHTML = `<strong>Walls:</strong> ${walls.length}<br>
                              <strong>Rays:</strong> ${showAllRays ? rayAngles : 'Hidden'}<br>
                              <strong>Tip:</strong> This is how 2D lighting and vision cones work!`;
            
            requestAnimationFrame(updateRaycastDemo);
        }
        
        updateRaycastDemo();
        
        // ===================================
        // PARTICLE SYSTEM DEMO
        // ===================================
        
        const particleSystemCanvas = document.getElementById('particleSystemDemo');
        const psCtx = particleSystemCanvas.getContext('2d');
        
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.emitters = [];
            }
            
            emit(x, y, config) {
                for (let i = 0; i < config.count; i++) {
                    const angle = config.spread ? 
                        Math.random() * Math.PI * 2 : 
                        config.angle + (Math.random() - 0.5) * config.spread;
                    const speed = config.speed + (Math.random() - 0.5) * config.speedVariation;
                    
                    this.particles.push({
                        position: new Vector2D(x, y),
                        velocity: new Vector2D(Math.cos(angle) * speed, Math.sin(angle) * speed),
                        acceleration: config.gravity.copy(),
                        life: config.lifetime,
                        maxLife: config.lifetime,
                        size: config.size + (Math.random() - 0.5) * 2,
                        color: config.color,
                        alpha: 1
                    });
                }
            }
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    p.velocity.add(p.acceleration);
                    p.position.add(p.velocity);
                    p.life--;
                    p.alpha = p.life / p.maxLife;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            draw(ctx) {
                for (let p of this.particles) {
                    ctx.fillStyle = p.color.replace('1)', p.alpha + ')');
                    ctx.beginPath();
                    ctx.arc(p.position.x, p.position.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        const particleSystem = new ParticleSystem();
        let currentEffect = 'explosion';
        
        const particleEffects = {
            explosion: {
                count: 50,
                speed: 8,
                speedVariation: 4,
                spread: Math.PI * 2,
                angle: 0,
                gravity: new Vector2D(0, 0.2),
                lifetime: 40,
                size: 4,
                color: 'rgba(255, 150, 50, 1)'
            },
            fire: {
                count: 20,
                speed: 1.5,
                speedVariation: 0.5,
                spread: Math.PI / 4,
                angle: -Math.PI / 2,
                gravity: new Vector2D(0, -0.1),
                lifetime: 60,
                size: 6,
                color: 'rgba(255, 200, 50, 1)'
            },
            smoke: {
                count: 15,
                speed: 0.8,
                speedVariation: 0.3,
                spread: Math.PI / 3,
                angle: -Math.PI / 2,
                gravity: new Vector2D(0, -0.05),
                lifetime: 120,
                size: 8,
                color: 'rgba(100, 100, 100, 1)'
            },
            sparks: {
                count: 30,
                speed: 7,
                speedVariation: 3,
                spread: Math.PI * 2,
                angle: 0,
                gravity: new Vector2D(0, 0.3),
                lifetime: 30,
                size: 2,
                color: 'rgba(255, 255, 100, 1)'
            },
            fountain: {
                count: 10,
                speed: 6,
                speedVariation: 2,
                spread: Math.PI / 6,
                angle: -Math.PI / 2,
                gravity: new Vector2D(0, 0.2),
                lifetime: 80,
                size: 4,
                color: 'rgba(100, 150, 255, 1)'
            }
        };
        
        function setParticleEffect(effect) {
            currentEffect = effect;
        }
        
        particleSystemCanvas.addEventListener('click', (e) => {
            const rect = particleSystemCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            particleSystem.emit(x, y, particleEffects[currentEffect]);
        });
        
        function updateParticleSystemDemo() {
            const ctx = psCtx;
            const width = particleSystemCanvas.width;
            const height = particleSystemCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            particleSystem.update();
            particleSystem.draw(ctx);
            
            const info = document.getElementById('particleSystemInfo');
            info.innerHTML = `<strong>Effect:</strong> ${currentEffect.toUpperCase()}<br>
                              <strong>Active Particles:</strong> ${particleSystem.particles.length}<br>
                              <strong>Tip:</strong> Different configs create different effects!`;
            
            requestAnimationFrame(updateParticleSystemDemo);
        }
        
        updateParticleSystemDemo();
        
        // ===================================
        // PATHFINDING DEMO (A*)
        // ===================================
        
        const pathfindingCanvas = document.getElementById('pathfindingDemo');
        const pfCtx = pathfindingCanvas.getContext('2d');
        
        const gridSize = 30;
        const cols = Math.floor(pathfindingCanvas.width / gridSize);
        const rows = Math.floor(pathfindingCanvas.height / gridSize);
        
        let pathGrid = [];
        let pathStart = null;
        let pathGoal = null;
        let pathMode = 'start';
        let foundPath = [];
        let exploredNodes = [];
        
        // Initialize grid
        for (let i = 0; i < cols; i++) {
            pathGrid[i] = [];
            for (let j = 0; j < rows; j++) {
                pathGrid[i][j] = {
                    x: i,
                    y: j,
                    wall: false
                };
            }
        }
        
        function setPathMode(mode) {
            pathMode = mode;
        }
        
        pathfindingCanvas.addEventListener('click', (e) => {
            const rect = pathfindingCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / gridSize);
            const y = Math.floor((e.clientY - rect.top) / gridSize);
            
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                if (pathMode === 'start') {
                    pathStart = { x, y };
                } else if (pathMode === 'goal') {
                    pathGoal = { x, y };
                } else if (pathMode === 'wall') {
                    pathGrid[x][y].wall = !pathGrid[x][y].wall;
                }
            }
        });
        
        pathfindingCanvas.addEventListener('mousemove', (e) => {
            if (e.buttons === 1 && pathMode === 'wall') {
                const rect = pathfindingCanvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / gridSize);
                const y = Math.floor((e.clientY - rect.top) / gridSize);
                
                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    pathGrid[x][y].wall = true;
                }
            }
        });
        
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        
        function getNeighbors(node) {
            const neighbors = [];
            const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            for (let [dx, dy] of dirs) {
                const nx = node.x + dx;
                const ny = node.y + dy;
                
                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !pathGrid[nx][ny].wall) {
                    neighbors.push(pathGrid[nx][ny]);
                }
            }
            
            return neighbors;
        }
        
        function findPath() {
            if (!pathStart || !pathGoal) return;
            
            exploredNodes = [];
            foundPath = [];
            
            const openSet = [pathGrid[pathStart.x][pathStart.y]];
            const closedSet = [];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            gScore.set(pathGrid[pathStart.x][pathStart.y], 0);
            fScore.set(pathGrid[pathStart.x][pathStart.y], heuristic(pathStart, pathGoal));
            
            while (openSet.length > 0) {
                let current = openSet.reduce((best, node) => 
                    (fScore.get(node) || Infinity) < (fScore.get(best) || Infinity) ? node : best
                );
                
                exploredNodes.push(current);
                
                if (current.x === pathGoal.x && current.y === pathGoal.y) {
                    // Reconstruct path
                    let temp = current;
                    while (temp) {
                        foundPath.unshift(temp);
                        temp = cameFrom.get(temp);
                    }
                    return;
                }
                
                openSet.splice(openSet.indexOf(current), 1);
                closedSet.push(current);
                
                for (let neighbor of getNeighbors(current)) {
                    if (closedSet.includes(neighbor)) continue;
                    
                    const tentativeG = (gScore.get(current) || Infinity) + 1;
                    
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    } else if (tentativeG >= (gScore.get(neighbor) || Infinity)) {
                        continue;
                    }
                    
                    cameFrom.set(neighbor, current);
                    gScore.set(neighbor, tentativeG);
                    fScore.set(neighbor, tentativeG + heuristic(neighbor, pathGoal));
                }
            }
        }
        
        function clearPathfinding() {
            pathStart = null;
            pathGoal = null;
            foundPath = [];
            exploredNodes = [];
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    pathGrid[i][j].wall = false;
                }
            }
        }
        
        function updatePathfindingDemo() {
            const ctx = pfCtx;
            const width = pathfindingCanvas.width;
            const height = pathfindingCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#1a2332';
            ctx.lineWidth = 1;
            for (let i = 0; i <= cols; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, height);
                ctx.stroke();
            }
            for (let j = 0; j <= rows; j++) {
                ctx.beginPath();
                ctx.moveTo(0, j * gridSize);
                ctx.lineTo(width, j * gridSize);
                ctx.stroke();
            }
            
            // Draw explored nodes
            for (let node of exploredNodes) {
                ctx.fillStyle = 'rgba(79, 195, 247, 0.2)';
                ctx.fillRect(node.x * gridSize, node.y * gridSize, gridSize, gridSize);
            }
            
            // Draw path
            for (let node of foundPath) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.fillRect(node.x * gridSize, node.y * gridSize, gridSize, gridSize);
            }
            
            // Draw walls
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (pathGrid[i][j].wall) {
                        ctx.fillStyle = '#4fc3f7';
                        ctx.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
                    }
                }
            }
            
            // Draw start
            if (pathStart) {
                ctx.fillStyle = '#66bb6a';
                ctx.fillRect(pathStart.x * gridSize, pathStart.y * gridSize, gridSize, gridSize);
            }
            
            // Draw goal
            if (pathGoal) {
                ctx.fillStyle = '#ff5252';
                ctx.fillRect(pathGoal.x * gridSize, pathGoal.y * gridSize, gridSize, gridSize);
            }
            
            const info = document.getElementById('pathfindingInfo');
            info.innerHTML = `<strong>Mode:</strong> ${pathMode.toUpperCase()}<br>
                              <strong>Path Length:</strong> ${foundPath.length > 0 ? foundPath.length : 'No path'}<br>
                              <strong>Nodes Explored:</strong> ${exploredNodes.length}<br>
                              <strong>Tip:</strong> Light blue = explored, Yellow = shortest path!`;
            
            requestAnimationFrame(updatePathfindingDemo);
        }
        
        updatePathfindingDemo();
        
        // ===================================
        // STATE MACHINE DEMO
        // ===================================
        
        const stateMachineCanvas = document.getElementById('stateMachineDemo');
        const smCtx = stateMachineCanvas.getContext('2d');
        
        class Guard {
            constructor(x, y) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(0, 0);
                this.maxSpeed = 2;
                this.state = 'patrol';
                this.waypoints = [
                    new Vector2D(x, y),
                    new Vector2D(x + 200, y),
                    new Vector2D(x + 200, y + 200),
                    new Vector2D(x, y + 200)
                ];
                this.currentWaypoint = 0;
                this.viewDistance = 150;
                this.attackDistance = 50;
            }
            
            update(player) {
                const dist = this.position.distance(player);
                
                // State transitions
                if (this.state === 'patrol') {
                    if (dist < this.viewDistance) {
                        this.state = 'chase';
                    }
                } else if (this.state === 'chase') {
                    if (dist > this.viewDistance * 1.5) {
                        this.state = 'patrol';
                    } else if (dist < this.attackDistance) {
                        this.state = 'attack';
                    }
                } else if (this.state === 'attack') {
                    if (dist > this.attackDistance * 1.2) {
                        this.state = 'chase';
                    }
                }
                
                // State actions
                if (this.state === 'patrol') {
                    const target = this.waypoints[this.currentWaypoint];
                    const dir = target.subtract(this.position);
                    
                    if (dir.length() < 10) {
                        this.currentWaypoint = (this.currentWaypoint + 1) % this.waypoints.length;
                    } else {
                        dir.normalize().multiply(this.maxSpeed);
                        this.velocity = dir;
                    }
                } else if (this.state === 'chase') {
                    const dir = player.subtract(this.position);
                    dir.normalize().multiply(this.maxSpeed * 1.5);
                    this.velocity = dir;
                } else if (this.state === 'attack') {
                    this.velocity.multiply(0.5);
                }
                
                this.position.add(this.velocity);
            }
            
            draw(ctx) {
                // Draw view range
                const colors = {
                    patrol: 'rgba(79, 195, 247, 0.1)',
                    chase: 'rgba(255, 165, 0, 0.1)',
                    attack: 'rgba(255, 82, 82, 0.2)'
                };
                
                ctx.fillStyle = colors[this.state];
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.viewDistance, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw guard
                const guardColors = {
                    patrol: '#4fc3f7',
                    chase: '#ffa726',
                    attack: '#ff5252'
                };
                
                ctx.fillStyle = guardColors[this.state];
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw state text
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText(this.state.toUpperCase(), this.position.x - 20, this.position.y - 25);
            }
        }
        
        let guards = [];
        let playerPos = new Vector2D(450, 300);
        
        function addGuard() {
            const x = Math.random() * (stateMachineCanvas.width - 400) + 200;
            const y = Math.random() * (stateMachineCanvas.height - 400) + 200;
            guards.push(new Guard(x, y));
        }
        
        // Add initial guards
        addGuard();
        addGuard();
        
        stateMachineCanvas.addEventListener('mousemove', (e) => {
            const rect = stateMachineCanvas.getBoundingClientRect();
            playerPos = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        function updateStateMachineDemo() {
            const ctx = smCtx;
            const width = stateMachineCanvas.width;
            const height = stateMachineCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw guards
            for (let guard of guards) {
                guard.update(playerPos);
                guard.draw(ctx);
            }
            
            // Draw player
            ctx.fillStyle = '#66bb6a';
            ctx.beginPath();
            ctx.arc(playerPos.x, playerPos.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Count states
            const stateCounts = { patrol: 0, chase: 0, attack: 0 };
            for (let guard of guards) {
                stateCounts[guard.state]++;
            }
            
            const info = document.getElementById('stateMachineInfo');
            info.innerHTML = `<strong>Guards:</strong> ${guards.length}<br>
                              <strong>Patrolling:</strong> ${stateCounts.patrol}<br>
                              <strong>Chasing:</strong> ${stateCounts.chase}<br>
                              <strong>Attacking:</strong> ${stateCounts.attack}<br>
                              <strong>Tip:</strong> Move close to see state transitions!`;
            
            requestAnimationFrame(updateStateMachineDemo);
        }
        
        updateStateMachineDemo();
        
        // ===================================
        // INVERSE KINEMATICS DEMO
        // ===================================
        
        const ikCanvas = document.getElementById('ikDemo');
        const ikCtx = ikCanvas.getContext('2d');
        
        class IKChain {
            constructor(base, lengths) {
                this.base = base.copy();
                this.lengths = lengths;
                this.joints = [];
                this.constraints = false;
                
                // Initialize chain
                let pos = base.copy();
                this.joints.push(pos.copy());
                for (let len of lengths) {
                    pos.x += len;
                    this.joints.push(pos.copy());
                }
            }
            
            solve(target, iterations = 10) {
                const endIndex = this.joints.length - 1;
                
                for (let iter = 0; iter < iterations; iter++) {
                    const dist = this.joints[endIndex].distance(target);
                    if (dist < 0.1) break;
                    
                    // Forward: pull from end toward target
                    this.joints[endIndex] = target.copy();
                    
                    for (let i = endIndex - 1; i >= 0; i--) {
                        const direction = this.joints[i].subtract(this.joints[i + 1]);
                        const length = this.lengths[i] || this.lengths[this.lengths.length - 1];
                        direction.normalize().multiply(length);
                        this.joints[i] = this.joints[i + 1].copy().add(direction);
                    }
                    
                    // Backward: restore base
                    this.joints[0] = this.base.copy();
                    
                    for (let i = 0; i < endIndex; i++) {
                        const direction = this.joints[i + 1].subtract(this.joints[i]);
                        const length = this.lengths[i];
                        direction.normalize().multiply(length);
                        this.joints[i + 1] = this.joints[i].copy().add(direction);
                    }
                }
            }
            
            draw(ctx) {
                // Draw bones
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(this.joints[0].x, this.joints[0].y);
                for (let i = 1; i < this.joints.length; i++) {
                    ctx.lineTo(this.joints[i].x, this.joints[i].y);
                }
                ctx.stroke();
                
                // Draw joints
                for (let joint of this.joints) {
                    ctx.fillStyle = '#66bb6a';
                    ctx.beginPath();
                    ctx.arc(joint.x, joint.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        let ikChains = [];
        let ikTarget = new Vector2D(450, 300);
        
        function addIKChain() {
            const x = Math.random() * (ikCanvas.width - 400) + 200;
            const y = Math.random() * (ikCanvas.height - 400) + 200;
            const lengths = [60, 60, 60];
            ikChains.push(new IKChain(new Vector2D(x, y), lengths));
        }
        
        function toggleIKConstraints() {
            // Toggle for future implementation
        }
        
        function clearIK() {
            ikChains = [];
        }
        
        // Add initial chains
        addIKChain();
        addIKChain();
        
        ikCanvas.addEventListener('mousemove', (e) => {
            const rect = ikCanvas.getBoundingClientRect();
            ikTarget = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        function updateIKDemo() {
            const ctx = ikCtx;
            const width = ikCanvas.width;
            const height = ikCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw chains
            for (let chain of ikChains) {
                chain.solve(ikTarget);
                chain.draw(ctx);
            }
            
            // Draw target
            ctx.fillStyle = '#ff5252';
            ctx.beginPath();
            ctx.arc(ikTarget.x, ikTarget.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            const info = document.getElementById('ikInfo');
            info.innerHTML = `<strong>Chains:</strong> ${ikChains.length}<br>
                              <strong>Joints per chain:</strong> ${ikChains.length > 0 ? ikChains[0].joints.length : 0}<br>
                              <strong>Algorithm:</strong> FABRIK<br>
                              <strong>Tip:</strong> Each arm reaches for the target independently!`;
            
            requestAnimationFrame(updateIKDemo);
        }
        
        updateIKDemo();
        
        // ===================================
        // SHADOW CASTING DEMO
        // ===================================
        
        const shadowCanvas = document.getElementById('shadowDemo');
        const shCtx = shadowCanvas.getContext('2d');
        
        let shadowWalls = [];
        let lightPos = new Vector2D(450, 300);
        let showShadowRays = false;
        
        function addShadowWall() {
            const x1 = Math.random() * shadowCanvas.width;
            const y1 = Math.random() * shadowCanvas.height;
            const angle = Math.random() * Math.PI * 2;
            const length = 80 + Math.random() * 120;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;
            shadowWalls.push(new Wall(x1, y1, x2, y2));
        }
        
        function clearShadowWalls() {
            shadowWalls = [];
        }
        
        function toggleShadowRays() {
            showShadowRays = !showShadowRays;
        }
        
        // Add border walls
        shadowWalls.push(new Wall(50, 50, 850, 50));
        shadowWalls.push(new Wall(850, 50, 850, 550));
        shadowWalls.push(new Wall(850, 550, 50, 550));
        shadowWalls.push(new Wall(50, 550, 50, 50));
        
        // Add some obstacles
        addShadowWall();
        addShadowWall();
        addShadowWall();
        
        shadowCanvas.addEventListener('mousemove', (e) => {
            const rect = shadowCanvas.getBoundingClientRect();
            lightPos = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        function castLightRays() {
            const rays = [];
            const vertices = [];
            
            // Collect all vertices
            for (let wall of shadowWalls) {
                vertices.push(wall.start, wall.end);
            }
            
            // Cast rays to each vertex
            for (let vertex of vertices) {
                const angle = Math.atan2(vertex.y - lightPos.y, vertex.x - lightPos.x);
                
                for (let offset of [-0.0001, 0, 0.0001]) {
                    const rayAngle = angle + offset;
                    const rayDir = new Vector2D(Math.cos(rayAngle) * 2000, Math.sin(rayAngle) * 2000);
                    
                    let closest = null;
                    let closestDist = Infinity;
                    
                    for (let wall of shadowWalls) {
                        const hit = rayIntersectsWall(lightPos, rayDir, wall);
                        if (hit && hit.distance < closestDist) {
                            closest = { x: hit.x, y: hit.y };
                            closestDist = hit.distance;
                        }
                    }
                    
                    if (closest) {
                        rays.push({ angle: rayAngle, point: closest });
                    }
                }
            }
            
            rays.sort((a, b) => a.angle - b.angle);
            return rays;
        }
        
        function updateShadowDemo() {
            const ctx = shCtx;
            const width = shadowCanvas.width;
            const height = shadowCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            const rays = castLightRays();
            
            // Draw lit area
            if (rays.length > 0) {
                const gradient = ctx.createRadialGradient(lightPos.x, lightPos.y, 0, lightPos.x, lightPos.y, 300);
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0.0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(rays[0].point.x, rays[0].point.y);
                for (let ray of rays) {
                    ctx.lineTo(ray.point.x, ray.point.y);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw rays
            if (showShadowRays) {
                ctx.strokeStyle = 'rgba(255, 255, 100, 0.3)';
                ctx.lineWidth = 1;
                for (let ray of rays) {
                    ctx.beginPath();
                    ctx.moveTo(lightPos.x, lightPos.y);
                    ctx.lineTo(ray.point.x, ray.point.y);
                    ctx.stroke();
                }
            }
            
            // Draw walls
            for (let wall of shadowWalls) {
                wall.draw(ctx);
            }
            
            // Draw light source
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(lightPos.x, lightPos.y, 15, 0, Math.PI * 2);
            ctx.fill();
            
            const info = document.getElementById('shadowInfo');
            info.innerHTML = `<strong>Walls:</strong> ${shadowWalls.length}<br>
                              <strong>Rays Cast:</strong> ${rays.length}<br>
                              <strong>Tip:</strong> Only ${rays.length} rays for perfect shadows!`;
            
            requestAnimationFrame(updateShadowDemo);
        }
        
        updateShadowDemo();
        
        // ===================================
        // PROCEDURAL GENERATION DEMO
        // ===================================
        
        const proceduralCanvas = document.getElementById('proceduralDemo');
        const procCtx = proceduralCanvas.getContext('2d');
        
        // Simple noise implementation
        class SimplexNoise {
            constructor(seed = 0) {
                this.seed = seed;
            }
            
            noise2D(x, y) {
                // Simple hash-based noise (not true simplex, but works for demo)
                const n = Math.sin(x * 12.9898 + y * 78.233 + this.seed) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }
        }
        
        let terrainSeed = Math.random() * 10000;
        let terrainNoise = new SimplexNoise(terrainSeed);
        let octaves = 4;
        let proceduralMode = 'terrain';
        
        function generateTerrain() {
            proceduralMode = 'terrain';
        }
        
        function generateDungeon() {
            proceduralMode = 'dungeon';
        }
        
        function changeSeed() {
            terrainSeed = Math.random() * 10000;
            terrainNoise = new SimplexNoise(terrainSeed);
        }
        
        function adjustOctaves() {
            octaves = octaves < 6 ? octaves + 1 : 1;
        }
        
        function getTerrainHeight(x, y) {
            let height = 0;
            let amplitude = 1;
            let frequency = 0.01;
            let maxValue = 0;
            
            for (let i = 0; i < octaves; i++) {
                height += terrainNoise.noise2D(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            
            return (height / maxValue + 1) / 2; // Normalize to 0-1
        }
        
        function updateProceduralDemo() {
            const ctx = procCtx;
            const width = proceduralCanvas.width;
            const height = proceduralCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            const tileSize = 10;
            
            if (proceduralMode === 'terrain') {
                for (let x = 0; x < width; x += tileSize) {
                    for (let y = 0; y < height; y += tileSize) {
                        const h = getTerrainHeight(x, y);
                        
                        let color;
                        if (h < 0.3) color = '#1a4d7a'; // Water
                        else if (h < 0.4) color = '#d4c090'; // Beach
                        else if (h < 0.6) color = '#4a7c3b'; // Grass
                        else if (h < 0.75) color = '#5a8a4a'; // Forest
                        else color = '#8b8680'; // Mountain
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, tileSize, tileSize);
                    }
                }
            } else {
                // Simple dungeon generation
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(0, 0, width, height);
                
                // Draw some rooms
                for (let i = 0; i < 10; i++) {
                    const roomX = Math.floor(Math.random() * 15) * 60;
                    const roomY = Math.floor(Math.random() * 10) * 60;
                    const roomW = (2 + Math.floor(Math.random() * 3)) * 30;
                    const roomH = (2 + Math.floor(Math.random() * 3)) * 30;
                    
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(roomX, roomY, roomW, roomH);
                }
            }
            
            const info = document.getElementById('proceduralInfo');
            info.innerHTML = `<strong>Mode:</strong> ${proceduralMode.toUpperCase()}<br>
                              <strong>Seed:</strong> ${terrainSeed.toFixed(0)}<br>
                              <strong>Octaves:</strong> ${octaves}<br>
                              <strong>Tip:</strong> Same seed = same world!`;
            
            requestAnimationFrame(updateProceduralDemo);
        }
        
        updateProceduralDemo();
        
        // ===================================
        // TILEMAP CHUNKING DEMO
        // ===================================
        
        const tilemapCanvas = document.getElementById('tilemapDemo');
        const tmCtx = tilemapCanvas.getContext('2d');
        
        const chunkSize = 16;
        const tileSize = 20;
        let loadRadius = 2;
        let showChunkBorders = true;
        let cameraPos = new Vector2D(0, 0);
        let isDragging2 = false;
        let lastMousePos = null;
        
        class ChunkManager {
            constructor() {
                this.chunks = new Map();
                this.noise = new SimplexNoise(12345);
            }
            
            getChunkKey(cx, cy) {
                return `${cx},${cy}`;
            }
            
            worldToChunk(wx, wy) {
                return {
                    x: Math.floor(wx / (chunkSize * tileSize)),
                    y: Math.floor(wy / (chunkSize * tileSize))
                };
            }
            
            generateChunk(cx, cy) {
                const chunk = [];
                for (let x = 0; x < chunkSize; x++) {
                    chunk[x] = [];
                    for (let y = 0; y < chunkSize; y++) {
                        const wx = cx * chunkSize + x;
                        const wy = cy * chunkSize + y;
                        const value = this.noise.noise2D(wx * 0.1, wy * 0.1);
                        chunk[x][y] = value > 0 ? 1 : 0;
                    }
                }
                return chunk;
            }
            
            update(camX, camY) {
                const camChunk = this.worldToChunk(camX, camY);
                const shouldBeLoaded = new Set();
                
                for (let dx = -loadRadius; dx <= loadRadius; dx++) {
                    for (let dy = -loadRadius; dy <= loadRadius; dy++) {
                        const cx = camChunk.x + dx;
                        const cy = camChunk.y + dy;
                        const key = this.getChunkKey(cx, cy);
                        shouldBeLoaded.add(key);
                        
                        if (!this.chunks.has(key)) {
                            this.chunks.set(key, {
                                x: cx,
                                y: cy,
                                tiles: this.generateChunk(cx, cy)
                            });
                        }
                    }
                }
                
                // Unload far chunks
                for (let key of this.chunks.keys()) {
                    if (!shouldBeLoaded.has(key)) {
                        this.chunks.delete(key);
                    }
                }
            }
        }
        
        const chunkManager = new ChunkManager();
        
        tilemapCanvas.addEventListener('mousedown', (e) => {
            isDragging2 = true;
            lastMousePos = new Vector2D(e.clientX, e.clientY);
        });
        
        tilemapCanvas.addEventListener('mousemove', (e) => {
            if (isDragging2 && lastMousePos) {
                const dx = e.clientX - lastMousePos.x;
                const dy = e.clientY - lastMousePos.y;
                cameraPos.x -= dx;
                cameraPos.y -= dy;
                lastMousePos = new Vector2D(e.clientX, e.clientY);
            }
        });
        
        tilemapCanvas.addEventListener('mouseup', () => {
            isDragging2 = false;
        });
        
        function increaseLoadRadius() {
            loadRadius = Math.min(loadRadius + 1, 5);
        }
        
        function decreaseLoadRadius() {
            loadRadius = Math.max(loadRadius - 1, 1);
        }
        
        function toggleChunkBorders() {
            showChunkBorders = !showChunkBorders;
        }
        
        function updateTilemapDemo() {
            const ctx = tmCtx;
            const width = tilemapCanvas.width;
            const height = tilemapCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            chunkManager.update(cameraPos.x + width / 2, cameraPos.y + height / 2);
            
            // Draw chunks
            for (let [key, chunk] of chunkManager.chunks) {
                const baseX = chunk.x * chunkSize * tileSize - cameraPos.x;
                const baseY = chunk.y * chunkSize * tileSize - cameraPos.y;
                
                for (let x = 0; x < chunkSize; x++) {
                    for (let y = 0; y < chunkSize; y++) {
                        const px = baseX + x * tileSize;
                        const py = baseY + y * tileSize;
                        
                        if (px >= -tileSize && px < width && py >= -tileSize && py < height) {
                            ctx.fillStyle = chunk.tiles[x][y] ? '#4a7c3b' : '#2a4a3a';
                            ctx.fillRect(px, py, tileSize, tileSize);
                        }
                    }
                }
                
                // Draw chunk borders
                if (showChunkBorders) {
                    ctx.strokeStyle = '#ff5252';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(baseX, baseY, chunkSize * tileSize, chunkSize * tileSize);
                }
            }
            
            const info = document.getElementById('tilemapInfo');
            info.innerHTML = `<strong>Loaded Chunks:</strong> ${chunkManager.chunks.size}<br>
                              <strong>Load Radius:</strong> ${loadRadius}<br>
                              <strong>Camera:</strong> (${Math.floor(cameraPos.x)}, ${Math.floor(cameraPos.y)})<br>
                              <strong>Tip:</strong> Drag to move, watch chunks load/unload!`;
            
            requestAnimationFrame(updateTilemapDemo);
        }
        
        updateTilemapDemo();
        
        // ===================================
        // SOUND PROPAGATION DEMO
        // ===================================
        
        const soundCanvas = document.getElementById('soundDemo');
        const sdCtx = soundCanvas.getContext('2d');
        
        let soundWalls = [];
        let soundSources = [];
        let listenerPos = new Vector2D(450, 300);
        let showSoundWaves = true;
        
        function addSoundWall() {
            const x1 = Math.random() * soundCanvas.width;
            const y1 = Math.random() * soundCanvas.height;
            const angle = Math.random() * Math.PI * 2;
            const length = 100 + Math.random() * 100;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;
            soundWalls.push(new Wall(x1, y1, x2, y2));
        }
        
        function playSoundEffect() {
            const x = Math.random() * soundCanvas.width;
            const y = Math.random() * soundCanvas.height;
            soundSources.push({ pos: new Vector2D(x, y), time: 60 });
        }
        
        function toggleSoundVisualization() {
            showSoundWaves = !showSoundWaves;
        }
        
        soundCanvas.addEventListener('mousemove', (e) => {
            const rect = soundCanvas.getBoundingClientRect();
            listenerPos = new Vector2D(e.clientX - rect.left, e.clientY - rect.top);
        });
        
        // Add border walls
        soundWalls.push(new Wall(50, 50, 850, 50));
        soundWalls.push(new Wall(850, 50, 850, 550));
        soundWalls.push(new Wall(850, 550, 50, 550));
        soundWalls.push(new Wall(50, 550, 50, 50));
        addSoundWall();
        addSoundWall();
        
        function calculateSoundVolume(source, listener) {
            const dist = source.distance(listener);
            const rolloff = 200;
            let distAttenuation = 1 / (1 + dist / rolloff);
            
            // Count walls between
            let wallCount = 0;
            const dir = listener.subtract(source);
            for (let wall of soundWalls) {
                if (rayIntersectsWall(source, dir, wall)) {
                    wallCount++;
                }
            }
            
            const occlusion = Math.max(0, 1 - wallCount * 0.3);
            return distAttenuation * occlusion;
        }
        
        function updateSoundDemo() {
            const ctx = sdCtx;
            const width = soundCanvas.width;
            const height = soundCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            // Update sound sources
            for (let i = soundSources.length - 1; i >= 0; i--) {
                soundSources[i].time--;
                if (soundSources[i].time <= 0) {
                    soundSources.splice(i, 1);
                }
            }
            
            // Draw sound waves
            if (showSoundWaves) {
                for (let source of soundSources) {
                    const radius = (60 - source.time) * 10;
                    const volume = calculateSoundVolume(source.pos, listenerPos);
                    
                    ctx.strokeStyle = `rgba(79, 195, 247, ${Math.max(0, volume * 0.5)})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(source.pos.x, source.pos.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Draw walls
            for (let wall of soundWalls) {
                wall.draw(ctx);
            }
            
            // Draw sound sources
            for (let source of soundSources) {
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(source.pos.x, source.pos.y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw listener
            ctx.fillStyle = '#66bb6a';
            ctx.beginPath();
            ctx.arc(listenerPos.x, listenerPos.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Calculate total volume
            let totalVolume = 0;
            for (let source of soundSources) {
                totalVolume += calculateSoundVolume(source.pos, listenerPos);
            }
            
            const info = document.getElementById('soundInfo');
            info.innerHTML = `<strong>Active Sounds:</strong> ${soundSources.length}<br>
                              <strong>Total Volume:</strong> ${(totalVolume * 100).toFixed(0)}%<br>
                              <strong>Walls:</strong> ${soundWalls.length}<br>
                              <strong>Tip:</strong> Walls block and reduce sound!`;
            
            requestAnimationFrame(updateSoundDemo);
        }
        
        updateSoundDemo();
        
        // ===================================
        // NETWORK INTERPOLATION DEMO
        // ===================================
        
        const networkCanvas = document.getElementById('networkDemo');
        const nwCtx = networkCanvas.getContext('2d');
        
        let networkLatency = 100;
        let usePrediction = true;
        let useInterpolation = true;
        
        class NetworkPlayer {
            constructor(x, y, isLocal) {
                this.position = new Vector2D(x, y);
                this.velocity = new Vector2D(0, 0);
                this.isLocal = isLocal;
                this.predictedPos = new Vector2D(x, y);
                this.serverPos = new Vector2D(x, y);
                this.positionBuffer = [];
                this.speed = 3;
            }
            
            update(input) {
                if (this.isLocal && usePrediction) {
                    // Client-side prediction
                    if (input.up) this.predictedPos.y -= this.speed;
                    if (input.down) this.predictedPos.y += this.speed;
                    if (input.left) this.predictedPos.x -= this.speed;
                    if (input.right) this.predictedPos.x += this.speed;
                    
                    this.position = this.predictedPos.copy();
                } else if (!this.isLocal && useInterpolation && this.positionBuffer.length >= 2) {
                    // Interpolate between buffered positions
                    const from = this.positionBuffer[0];
                    const to = this.positionBuffer[1];
                    const t = Math.min(1, (Date.now() - from.time) / (to.time - from.time));
                    
                    this.position.x = from.pos.x + (to.pos.x - from.pos.x) * t;
                    this.position.y = from.pos.y + (to.pos.y - from.pos.y) * t;
                    
                    if (t >= 1) {
                        this.positionBuffer.shift();
                    }
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = this.isLocal ? '#66bb6a' : '#ff5252';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText(this.isLocal ? 'YOU' : 'OTHER', this.position.x - 15, this.position.y - 25);
            }
        }
        
        const localPlayer = new NetworkPlayer(200, 300, true);
        const remotePlayer = new NetworkPlayer(700, 300, false);
        
        const networkKeys = { up: false, down: false, left: false, right: false };
        
        window.addEventListener('keydown', (e) => {
            if (e.key === 'w') networkKeys.up = true;
            if (e.key === 's') networkKeys.down = true;
            if (e.key === 'a') networkKeys.left = true;
            if (e.key === 'd') networkKeys.right = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w') networkKeys.up = false;
            if (e.key === 's') networkKeys.down = false;
            if (e.key === 'a') networkKeys.left = false;
            if (e.key === 'd') networkKeys.right = false;
        });
        
        function adjustLatency(delta) {
            networkLatency = Math.max(0, Math.min(500, networkLatency + delta));
        }
        
        function togglePrediction() {
            usePrediction = !usePrediction;
        }
        
        function toggleInterpolation() {
            useInterpolation = !useInterpolation;
        }
        
        // Simulate network updates
        setInterval(() => {
            remotePlayer.positionBuffer.push({
                pos: new Vector2D(
                    remotePlayer.serverPos.x + (Math.random() - 0.5) * 100,
                    remotePlayer.serverPos.y + (Math.random() - 0.5) * 100
                ),
                time: Date.now()
            });
            
            if (remotePlayer.positionBuffer.length > 5) {
                remotePlayer.positionBuffer.shift();
            }
        }, 50 + networkLatency);
        
        function updateNetworkDemo() {
            const ctx = nwCtx;
            const width = networkCanvas.width;
            const height = networkCanvas.height;
            
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, width, height);
            
            localPlayer.update(networkKeys);
            remotePlayer.update({});
            
            localPlayer.draw(ctx);
            remotePlayer.draw(ctx);
            
            const info = document.getElementById('networkInfo');
            info.innerHTML = `<strong>Latency:</strong> ${networkLatency}ms<br>
                              <strong>Prediction:</strong> ${usePrediction ? 'ON' : 'OFF'}<br>
                              <strong>Interpolation:</strong> ${useInterpolation ? 'ON' : 'OFF'}<br>
                              <strong>Tip:</strong> Green = your smooth character with prediction!`;
            
            requestAnimationFrame(updateNetworkDemo);
        }
        
        updateNetworkDemo();
    

console.log('‚úÖ All game math demos loaded successfully!');
</script>
</body>
</html>