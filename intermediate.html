<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermediate - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
    <!-- Prism.js Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üéÆ Intermediate Game Math</h1>
        <p class="subtitle">Core systems - Physics, collision detection, and visual effects</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="beginner.html" class="nav-button">‚Üê Beginner</a>
            <a href="intermediate.html" class="nav-button active">Intermediate</a>
            <a href="advanced.html" class="nav-button">Advanced ‚Üí</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#lerp">Linear Interpolation (Lerp)</a></li>
                <li><a href="#physics">Physics Systems with Forces</a></li>
                <li><a href="#spaceship">Spaceship Controller with Gravity Wells</a></li>
                <li><a href="#spring">Spring Physics & Damping</a></li>
                <li><a href="#verlet">Verlet Physics & Constraints</a></li>
                <li><a href="#procedural-animation">Procedural Animation</a></li>
                <li><a href="#wave-simulation">Wave Simulation</a></li>
                <li><a href="#friction">Friction & Drag Systems</a></li>
                <li><a href="#collision">Collision Detection</a></li>
                <li><a href="#reflection">Bouncing & Reflection</a></li>
                <li><a href="#raycasting">Raycasting & Line of Sight</a></li>
                <li><a href="#particles">Particle Systems</a></li>
                <li><a href="#advanced-particles">Advanced Particle Effects</a></li>
            </ul>
        </div>

        <!-- LINEAR INTERPOLATION -->
        <div id="lerp" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üéØ Linear Interpolation (Lerp)</h2>

            <div class="concept-box">
                <h4>What is Lerp?</h4>
                <p>Lerp smoothly transitions between two values. It's the secret behind smooth camera movement, object animations, and color transitions!</p>
                <div class="formula">
                    result = start + (end - start) * t
                </div>
                <p>Where <code>t</code> is a value between 0 and 1:</p>
                <ul>
                    <li><strong>t = 0:</strong> Returns start value</li>
                    <li><strong>t = 0.5:</strong> Returns halfway between start and end</li>
                    <li><strong>t = 1:</strong> Returns end value</li>
                </ul>
            </div>

            <details data-demo-id="lerp" data-deps="vector2d,clearCanvas,drawGrid">
                <summary>üìù Click to see: Lerp Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Basic lerp function
function lerp(start, end, t) {
    return start + (end - start) * t;
}

// Vector lerp
Vector2D.prototype.lerp = function(target, t) {
    this.x += (target.x - this.x) * t;
    this.y += (target.y - this.y) * t;
    return this;
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Smooth Camera Follow:</h4>
                    <pre><code class="language-javascript">class Camera {
    constructor() {
        this.position = new Vector2D(0, 0);
    }

    follow(target, smoothing = 0.1) {
        // Smoothly move camera toward target
        this.position.lerp(target, smoothing);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Lerp in Action</h3>
            <div class="diagram">
                <canvas id="lerpDemo" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button id="btnSlowLerp">Slow (t=0.02)</button>
                <button id="btnMediumLerp">Medium (t=0.1)</button>
                <button id="btnFastLerp">Fast (t=0.3)</button>
                <button id="btnResetLerp">Reset</button>
            </div>
            <div id="lerpInfo" class="info-display">Click anywhere to set a new target</div>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> Smaller t values (0.01-0.05) create slower, smoother movement. Larger values (0.2-0.5) are snappier. Never use t >= 1 in lerp - it can cause overshooting!
            </div>
        </div>

        <!-- PHYSICS SYSTEMS -->
        <div id="physics" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>‚ö° Physics Systems with Forces</h2>

            <div class="concept-box">
                <h4>Basic Physics Principles</h4>
                <p>Game physics is based on Newton's laws:</p>
                <ul>
                    <li><strong>Position:</strong> Where the object is</li>
                    <li><strong>Velocity:</strong> How fast it's moving (and in what direction)</li>
                    <li><strong>Acceleration:</strong> How velocity changes over time</li>
                    <li><strong>Force:</strong> What causes acceleration (gravity, wind, etc.)</li>
                </ul>
                <div class="formula">
                    Force = Mass √ó Acceleration
                </div>
            </div>

            <details data-demo-id="physics" data-deps="vector2d,clearCanvas,randomFloat,clamp,drawVector">
                <summary>üìù Click to see: Physics Entity Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class PhysicsEntity {
    constructor(x, y, mass = 1) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.acceleration = new Vector2D(0, 0);
        this.mass = mass;
    }

    applyForce(force) {
        // F = ma, so a = F/m
        const f = force.copy().divide(this.mass);
        this.acceleration.add(f);
    }

    update() {
        // Update velocity based on acceleration
        this.velocity.add(this.acceleration);

        // Update position based on velocity
        this.position.add(this.velocity);

        // Reset acceleration (forces are applied each frame)
        this.acceleration.multiply(0);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Adding Gravity:</h4>
                    <pre><code class="language-javascript">const gravity = new Vector2D(0, 0.5);  // Downward force

function gameLoop() {
    entities.forEach(entity => {
        entity.applyForce(gravity);
        entity.update();
    });
}</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Physics Simulation</summary>
                <pre><code class="language-javascript">// ===================================
// PHYSICS SIMULATION - Complete Implementation
// ===================================

// Ball class with physics properties
class Ball {
    constructor(x, y, radius = 15) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(randomFloat(-2, 2), randomFloat(-2, 2));
        this.acceleration = new Vector2D(0, 0);
        this.mass = radius;  // Mass proportional to size
        this.radius = radius;
    }

    applyForce(force) {
        // F = ma, so a = F/m
        const f = force.copy().divide(this.mass);
        this.acceleration.add(f);
    }

    update() {
        this.velocity.add(this.acceleration);
        this.velocity.multiply(0.99);  // Air resistance
        this.position.add(this.velocity);
        this.acceleration.multiply(0);  // Reset forces each frame

        // Bounce off walls with energy loss
        if (this.position.x < this.radius ||
            this.position.x > canvas.width - this.radius) {
            this.velocity.x *= -0.8;
            this.position.x = clamp(this.position.x, this.radius,
                                    canvas.width - this.radius);
        }
        if (this.position.y < this.radius ||
            this.position.y > canvas.height - this.radius) {
            this.velocity.y *= -0.8;
            this.position.y = clamp(this.position.y, this.radius,
                                    canvas.height - this.radius);
        }
    }

    draw(ctx) {
        ctx.fillStyle = '#4fc3f7';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw velocity vector
        const end = new Vector2D(
            this.position.x + this.velocity.x * 5,
            this.position.y + this.velocity.y * 5
        );
        drawVector(ctx, this.position, end, '#ffa726', 2);
    }
}

// State variables
const balls = [];
let gravityEnabled = true;
let windEnabled = false;
const gravity = new Vector2D(0, 0.3);
const wind = new Vector2D(0.1, 0);

// Button event handlers
document.getElementById('btnAddBall').addEventListener('click', () => {
    const x = randomFloat(50, canvas.width - 50);
    const y = randomFloat(50, 200);
    balls.push(new Ball(x, y, randomFloat(10, 20)));
});

document.getElementById('btnToggleGravity').addEventListener('click', () => {
    gravityEnabled = !gravityEnabled;
});

document.getElementById('btnAddWind').addEventListener('click', () => {
    windEnabled = !windEnabled;
});

document.getElementById('btnResetPhysics').addEventListener('click', () => {
    balls.length = 0;  // Clear all balls
});

// Click to apply force to nearby balls
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const clickPos = new Vector2D(
        e.clientX - rect.left,
        e.clientY - rect.top
    );

    balls.forEach(ball => {
        const dist = ball.position.distance(clickPos);
        if (dist < 150) {
            // Apply force away from click point
            const force = ball.position.subtract(clickPos)
                               .normalize().multiply(10);
            ball.applyForce(force);
        }
    });
});

// Animation loop
function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    balls.forEach(ball => {
        if (gravityEnabled) ball.applyForce(gravity);
        if (windEnabled) ball.applyForce(wind);
        ball.update();
        ball.draw(ctx);
    });

    requestAnimationFrame(animate);
}

// Initialize with some balls
for (let i = 0; i < 3; i++) {
    balls.push(new Ball(randomFloat(100, canvas.width - 100), 100, 15));
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Physics Simulation</h3>
            <div class="diagram">
                <canvas id="physicsDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddBall">Add Ball</button>
                <button id="btnToggleGravity">Toggle Gravity</button>
                <button id="btnAddWind">Add Wind</button>
                <button id="btnResetPhysics">Reset</button>
            </div>
            <div id="physicsInfo" class="info-display">Click to apply force to nearby objects</div>
        </div>

        <!-- SPACESHIP CONTROLLER -->
        <div id="spaceship" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üöÄ Spaceship Controller with Gravity Wells</h2>

            <div class="concept-box">
                <h4>Thrust-Based Movement</h4>
                <p>Unlike direct position control, spaceships use thrust to accelerate. This creates realistic momentum and inertia:</p>
                <ul>
                    <li><strong>Thrust:</strong> Apply force in the direction the ship is facing</li>
                    <li><strong>Rotation:</strong> Turn the ship to change thrust direction</li>
                    <li><strong>Gravity Wells:</strong> Massive objects that pull the ship toward them</li>
                    <li><strong>Orbital Mechanics:</strong> Balance thrust and gravity to achieve orbit</li>
                </ul>
                <div class="formula">
                    Gravitational Force = G √ó (m‚ÇÅ √ó m‚ÇÇ) / distance¬≤
                </div>
            </div>

            <details data-demo-id="spaceship" data-deps="vector2d,clearCanvas,randomFloat,clamp,drawVector">
                <summary>üìù Click to see: Spaceship Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Spaceship {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.acceleration = new Vector2D(0, 0);

        this.angle = 0;  // Direction ship is facing
        this.rotation = 0;  // Angular velocity

        this.mass = 1;
        this.thrustPower = 0.15;
        this.rotationSpeed = 0.08;
    }

    applyForce(force) {
        // F = ma, so a = F/m
        const f = force.copy().divide(this.mass);
        this.acceleration.add(f);
    }

    thrust() {
        // Apply force in the direction ship is facing
        const thrustForce = new Vector2D(
            Math.cos(this.angle) * this.thrustPower,
            Math.sin(this.angle) * this.thrustPower
        );
        this.applyForce(thrustForce);
    }

    rotateLeft() {
        this.rotation = -this.rotationSpeed;
    }

    rotateRight() {
        this.rotation = this.rotationSpeed;
    }

    update() {
        // Update rotation
        this.angle += this.rotation;
        this.rotation *= 0.9;  // Damping

        // Update physics
        this.velocity.add(this.acceleration);
        this.position.add(this.velocity);

        // Reset acceleration
        this.acceleration.multiply(0);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Gravity Well Physics:</h4>
                    <pre><code class="language-javascript">class GravityWell {
    constructor(x, y, mass = 100) {
        this.position = new Vector2D(x, y);
        this.mass = mass;
        this.radius = Math.sqrt(mass) * 2;
    }

    attract(entity) {
        // Calculate direction to gravity well
        const force = this.position.copy().subtract(entity.position);
        const distance = clamp(force.length(), 5, 100);

        // Newton's law of gravitation: F = G √ó (m1 √ó m2) / r¬≤
        const G = 1;  // Gravitational constant (simplified)
        const strength = (G * this.mass * entity.mass) / (distance * distance);

        force.normalize().multiply(strength);
        entity.applyForce(force);
    }
}

// In game loop:
function update() {
    // Apply gravity from all wells
    gravityWells.forEach(well => {
        well.attract(spaceship);
    });

    spaceship.update();
}</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Spaceship with Gravity Wells</summary>
                <pre><code class="language-javascript">// ===================================
// SPACESHIP WITH GRAVITY WELLS - Complete Implementation
// ===================================

class Spaceship {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.acceleration = new Vector2D(0, 0);
        this.angle = -Math.PI / 2;  // Start pointing up
        this.rotation = 0;
        this.mass = 1;
        this.thrustPower = 0.15;
        this.rotationSpeed = 0.08;
        this.thrusting = false;
        this.size = 15;
    }

    applyForce(force) {
        const f = force.copy().divide(this.mass);
        this.acceleration.add(f);
    }

    thrust() {
        const thrustForce = new Vector2D(
            Math.cos(this.angle) * this.thrustPower,
            Math.sin(this.angle) * this.thrustPower
        );
        this.applyForce(thrustForce);
        this.thrusting = true;
    }

    rotateLeft() { this.rotation = -this.rotationSpeed; }
    rotateRight() { this.rotation = this.rotationSpeed; }

    update() {
        this.angle += this.rotation;
        this.rotation *= 0.85;  // Damping

        this.velocity.add(this.acceleration);

        // Speed limit
        const speed = this.velocity.length();
        if (speed > 10) {
            this.velocity.normalize().multiply(10);
        }

        this.position.add(this.velocity);
        this.acceleration.multiply(0);

        // Wrap around screen edges
        if (this.position.x < 0) this.position.x = canvas.width;
        if (this.position.x > canvas.width) this.position.x = 0;
        if (this.position.y < 0) this.position.y = canvas.height;
        if (this.position.y > canvas.height) this.position.y = 0;

        this.thrusting = false;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.angle);

        // Draw spaceship as triangle
        ctx.fillStyle = '#4fc3f7';
        ctx.strokeStyle = '#81d4fa';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.size, 0);
        ctx.lineTo(-this.size, -this.size * 0.7);
        ctx.lineTo(-this.size * 0.5, 0);
        ctx.lineTo(-this.size, this.size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw thrust flame when thrusting
        if (this.thrusting) {
            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.moveTo(-this.size * 0.5, -this.size * 0.4);
            ctx.lineTo(-this.size * 1.5, 0);
            ctx.lineTo(-this.size * 0.5, this.size * 0.4);
            ctx.closePath();
            ctx.fill();
        }

        ctx.restore();

        // Draw velocity vector
        const velEnd = new Vector2D(
            this.position.x + this.velocity.x * 10,
            this.position.y + this.velocity.y * 10
        );
        if (this.velocity.length() > 0.5) {
            drawVector(ctx, this.position, velEnd, '#66bb6a', 2);
        }
    }
}

class GravityWell {
    constructor(x, y, mass = 100) {
        this.position = new Vector2D(x, y);
        this.mass = mass;
        this.radius = Math.sqrt(mass) * 2;
    }

    attract(entity) {
        const force = this.position.copy().subtract(entity.position);
        const distance = clamp(force.length(), 10, 250);

        // Newton's law of gravitation
        const G = 1;
        const strength = (G * this.mass * entity.mass) / (distance * distance);

        force.normalize().multiply(strength);
        entity.applyForce(force);
    }

    draw(ctx) {
        // Draw gravity well
        ctx.fillStyle = '#9c27b0';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Draw gravity field rings
        ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 1; i <= 3; i++) {
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y,
                    this.radius + i * 30, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }
}

// State
let spaceship = new Spaceship(400, 300);
const gravityWells = [new GravityWell(400, 450, 150)];

// Keyboard controls
const keys = {};
window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

// Button controls (mousedown/mouseup for continuous thrust)
document.getElementById('btnSpaceshipThrust')
    .addEventListener('mousedown', () => keys['w'] = true);
document.getElementById('btnSpaceshipThrust')
    .addEventListener('mouseup', () => keys['w'] = false);
// ... similar for left/right buttons

// Click canvas to add gravity well
canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    gravityWells.push(new GravityWell(x, y, 120));
});

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    // Draw starfield background
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    for (let i = 0; i < 50; i++) {
        const x = (i * 137.5) % canvas.width;
        const y = (i * 217.3) % canvas.height;
        ctx.fillRect(x, y, 2, 2);
    }

    // Handle input
    if (keys['w'] || keys['arrowup']) spaceship.thrust();
    if (keys['a'] || keys['arrowleft']) spaceship.rotateLeft();
    if (keys['d'] || keys['arrowright']) spaceship.rotateRight();

    // Apply gravity from all wells
    gravityWells.forEach(well => {
        well.attract(spaceship);
        well.draw(ctx);
    });

    spaceship.update();
    spaceship.draw(ctx);

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Spaceship with Gravity Wells</h3>
            <div class="diagram">
                <canvas id="spaceshipDemo" width="800" height="600"></canvas>
            </div>
            <div class="controls">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 600px; margin: 0 auto;">
                    <button id="btnSpaceshipThrust">üî• Thrust (W)</button>
                    <button id="btnSpaceshipLeft">‚¨ÖÔ∏è Rotate Left (A)</button>
                    <button id="btnSpaceshipRight">‚û°Ô∏è Rotate Right (D)</button>
                    <button id="btnAddGravityWell">‚ûï Add Gravity Well</button>
                    <button id="btnRemoveGravityWell">‚ûñ Remove Gravity Well</button>
                    <button id="btnResetSpaceship">üîÑ Reset</button>
                </div>
            </div>
            <div id="spaceshipInfo" class="info-display">Use W/A/D or buttons to control the spaceship. Click to add gravity wells. Try to achieve orbit!</div>

            <div class="key-point">
                <strong>üí° Orbital Mechanics:</strong> To orbit a gravity well, you need the right speed and direction! Too slow = you'll crash. Too fast = you'll fly away. The perfect orbit is when centrifugal force (your velocity) balances gravitational pull. Try flying perpendicular to a gravity well at medium speed!
            </div>

            <div class="challenge-box">
                <h4>üèÜ Challenges:</h4>
                <ul>
                    <li><strong>Stable Orbit:</strong> Achieve a circular orbit around a single gravity well</li>
                    <li><strong>Figure-8:</strong> Navigate between two gravity wells in a figure-8 pattern</li>
                    <li><strong>Slingshot:</strong> Use a gravity well's pull to boost your speed (gravity assist maneuver)</li>
                    <li><strong>Landing:</strong> Slow down enough to gently touch a gravity well</li>
                </ul>
            </div>
        </div>

        <!-- SPRING PHYSICS -->
        <div id="spring" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üîÑ Spring Physics & Damping</h2>

            <div class="concept-box">
                <h4>What are Springs?</h4>
                <p>Springs create smooth, bouncy motion that feels natural and responsive. They're perfect for:</p>
                <ul>
                    <li>Camera following (smooth but snappy)</li>
                    <li>UI animations (buttons, menus)</li>
                    <li>Rope/chain physics</li>
                    <li>Elastic connections between objects</li>
                </ul>
                <p><strong>Hooke's Law:</strong> Force = -stiffness √ó displacement</p>
            </div>

            <details data-demo-id="spring" data-deps="vector2d,clearCanvas,randomFloat,clamp">
                <summary>üìù Click to see: Spring Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Spring {
    constructor(stiffness = 0.1, damping = 0.8) {
        this.position = new Vector2D(0, 0);
        this.velocity = new Vector2D(0, 0);
        this.target = new Vector2D(0, 0);

        this.stiffness = stiffness;  // How tight the spring is
        this.damping = damping;      // How much it slows down
    }

    update() {
        // Calculate spring force
        const displacement = this.target.subtract(this.position);
        const springForce = displacement.multiply(this.stiffness);

        // Apply force to velocity
        this.velocity.add(springForce);

        // Apply damping (friction)
        this.velocity.multiply(this.damping);

        // Update position
        this.position.add(this.velocity);
    }

    setTarget(x, y) {
        this.target.set(x, y);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Smooth Camera Follow</h4>
                    <pre><code class="language-javascript">class Camera {
    constructor() {
        this.spring = new Spring(0.08, 0.85);
    }

    follow(player) {
        // Set target to player position
        this.spring.setTarget(player.x, player.y);

        // Update spring physics
        this.spring.update();

        // Camera position is spring position
        this.x = this.spring.position.x;
        this.y = this.spring.position.y;
    }
}

// Higher stiffness = tighter follow (0.2)
// Lower damping = more bouncy (0.7)
// Lower stiffness = looser follow (0.05)
// Higher damping = less bouncy (0.95)</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Spring Launcher</summary>
                <pre><code class="language-javascript">// ===================================
// SPRING LAUNCHER - Complete Implementation
// ===================================

const anchorPos = new Vector2D(150, 400);
let stiffness = 0.15;  // Spring constant (k)

class Projectile {
    constructor(x, y, vx, vy) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(vx, vy);
        this.radius = 12;
        this.trail = [];
        this.alive = true;
    }

    update() {
        this.velocity.y += 0.3;  // Gravity
        this.position.add(this.velocity);

        // Trail for visual effect
        this.trail.push(this.position.copy());
        if (this.trail.length > 40) this.trail.shift();

        // Ground bounce
        if (this.position.y > canvas.height - this.radius) {
            this.position.y = canvas.height - this.radius;
            this.velocity.y *= -0.6;  // Bounce with energy loss
            this.velocity.x *= 0.9;   // Ground friction
        }
    }
}

let projectiles = [];
let isDragging = false;
let dragPos = anchorPos.copy();

canvas.addEventListener('mousedown', (e) => {
    const mousePos = getMousePos(e);
    if (mousePos.distance(anchorPos) < 100) {
        isDragging = true;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (isDragging) {
        dragPos = getMousePos(e);

        // Limit drag distance
        const displacement = dragPos.subtract(anchorPos);
        const maxDistance = 150;
        if (displacement.length() > maxDistance) {
            dragPos = anchorPos.copy().add(
                displacement.normalize().multiply(maxDistance)
            );
        }
    }
});

canvas.addEventListener('mouseup', () => {
    if (isDragging) {
        // Hooke's Law: F = -kx
        const displacement = anchorPos.subtract(dragPos);
        const launchForce = displacement.multiply(stiffness);

        projectiles.push(new Projectile(
            dragPos.x, dragPos.y,
            launchForce.x, launchForce.y
        ));

        isDragging = false;
        dragPos = anchorPos.copy();
    }
});

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    // Draw spring visualization while dragging
    if (isDragging) {
        const dist = dragPos.distance(anchorPos);
        const segments = 15;
        const springWidth = 20;

        ctx.strokeStyle = '#66bb6a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        // Draw zig-zag spring...
    }

    // Update and draw projectiles
    projectiles.forEach(p => {
        p.update();
        p.draw(ctx);
    });

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Spring Launcher</h3>
            <div class="diagram">
                <canvas id="springDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnTightSpring">Strong Spring (k=0.2)</button>
                <button id="btnLooseSpring">Weak Spring (k=0.08)</button>
                <button id="btnBouncySpring">Medium Spring (k=0.15)</button>
                <button id="btnStiffSpring">Very Strong (k=0.25)</button>
            </div>
            <div id="springInfo" class="info-display">Click and drag near the launcher to pull back the spring and launch projectiles at the targets!</div>

            <div class="key-point">
                <strong>üí° Understanding Spring Force:</strong> The launcher demonstrates Hooke's Law (F = -k √ó displacement). Higher stiffness (k) means stronger force for the same pull distance. Try different stiffness values to see how they affect launch power and trajectory!
            </div>
        </div>

        <!-- VERLET PHYSICS -->
        <div id="verlet" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üîó Verlet Physics & Constraints</h2>

            <div class="concept-box">
                <h4>What is Verlet Integration?</h4>
                <p>Verlet integration is a simple but powerful physics technique that's perfect for simulating ropes, chains, cloth, and soft bodies. Unlike traditional force-based physics, Verlet uses position and previous position to calculate velocity implicitly.</p>

                <p><strong>Why use Verlet?</strong></p>
                <ul>
                    <li><strong>Simple:</strong> No separate velocity variable needed!</li>
                    <li><strong>Stable:</strong> More resistant to numerical errors than Euler integration</li>
                    <li><strong>Constraint-friendly:</strong> Perfect for ropes, chains, ragdolls</li>
                    <li><strong>Energy-conserving:</strong> Creates more natural motion</li>
                </ul>

                <div class="formula">
                    velocity = current_position - previous_position<br>
                    new_position = current_position + velocity + acceleration
                </div>
            </div>

            <div class="concept-box">
                <h4>Verlet vs Traditional Physics</h4>
                <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <tr style="background: rgba(255,255,255,0.05);">
                        <th style="padding: 10px; text-align: left; border: 1px solid rgba(255,255,255,0.1);">Aspect</th>
                        <th style="padding: 10px; text-align: left; border: 1px solid rgba(255,255,255,0.1);">Euler (Force-based)</th>
                        <th style="padding: 10px; text-align: left; border: 1px solid rgba(255,255,255,0.1);">Verlet (Position-based)</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);"><strong>Velocity</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">Explicit variable</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">Implicit (derived from positions)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);"><strong>Best for</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">Rigid bodies, projectiles</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">Ropes, cloth, soft bodies</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);"><strong>Stability</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">Can be unstable at high speeds</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">More stable, energy-conserving</td>
                    </tr>
                </table>
            </div>

            <details data-demo-id="verlet" data-deps="vector2d,clearCanvas,drawGrid,randomFloat">
                <summary>üìù Click to see: Verlet Point Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class VerletPoint {
    constructor(x, y, pinned = false) {
        this.position = new Vector2D(x, y);
        this.oldPosition = new Vector2D(x, y);
        this.acceleration = new Vector2D(0, 0);
        this.pinned = pinned;  // Fixed points don't move
    }

    update(dt = 1) {
        if (this.pinned) return;

        // Calculate velocity implicitly
        const velocity = this.position.copy().subtract(this.oldPosition);

        // Save current position
        const temp = this.position.copy();

        // Verlet integration: new_pos = pos + velocity + acceleration
        this.position.add(velocity);
        this.position.add(this.acceleration.copy().multiply(dt * dt));

        // Store old position for next frame
        this.oldPosition = temp;

        // Reset acceleration
        this.acceleration.multiply(0);
    }

    applyForce(force) {
        this.acceleration.add(force);
    }

    constrain(bounds) {
        // Keep point within bounds (with bouncing)
        if (this.position.x < bounds.left) {
            this.position.x = bounds.left;
        }
        if (this.position.x > bounds.right) {
            this.position.x = bounds.right;
        }
        if (this.position.y > bounds.bottom) {
            this.position.y = bounds.bottom;
        }
        if (this.position.y < bounds.top) {
            this.position.y = bounds.top;
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üîó Constraints: The Magic of Verlet</h4>
                    <p>Constraints are what make Verlet physics special. After updating positions, we enforce constraints (like "these two points must stay exactly 50 pixels apart"). This creates rope, cloth, and rigid structures!</p>
                    <pre><code class="language-javascript">class Constraint {
    constructor(p1, p2, length = null) {
        this.p1 = p1;
        this.p2 = p2;
        // If no length specified, use current distance
        this.length = length || p1.position.distance(p2.position);
    }

    solve() {
        // Calculate current distance between points
        const diff = this.p2.position.copy().subtract(this.p1.position);
        const currentDistance = diff.length();

        // Calculate how much to correct
        const correction = (currentDistance - this.length) / currentDistance;

        // Move both points to satisfy constraint
        const correctionVector = diff.multiply(correction * 0.5);

        if (!this.p1.pinned) {
            this.p1.position.add(correctionVector);
        }

        if (!this.p2.pinned) {
            this.p2.position.subtract(correctionVector);
        }
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Complete Rope System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Rope {
    constructor(startX, startY, segments = 10, segmentLength = 20) {
        this.points = [];
        this.constraints = [];

        // Create points along the rope
        for (let i = 0; i <= segments; i++) {
            const x = startX;
            const y = startY + i * segmentLength;
            const pinned = (i === 0);  // Pin the first point

            this.points.push(new VerletPoint(x, y, pinned));
        }

        // Create constraints between adjacent points
        for (let i = 0; i < segments; i++) {
            const constraint = new Constraint(
                this.points[i],
                this.points[i + 1],
                segmentLength
            );
            this.constraints.push(constraint);
        }
    }

    update(gravity = new Vector2D(0, 0.5)) {
        // Apply forces to all points
        this.points.forEach(point => {
            point.applyForce(gravity);
        });

        // Update positions
        this.points.forEach(point => {
            point.update();
        });

        // Solve constraints multiple times for stability
        for (let i = 0; i < 3; i++) {
            this.constraints.forEach(constraint => {
                constraint.solve();
            });
        }
    }

    draw(ctx) {
        // Draw the rope as connected line segments
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.points[0].position.x, this.points[0].position.y);

        for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].position.x, this.points[i].position.y);
        }

        ctx.stroke();

        // Draw points
        this.points.forEach(point => {
            ctx.fillStyle = point.pinned ? '#ff5252' : '#42a5f5';
            ctx.beginPath();
            ctx.arc(point.position.x, point.position.y, 4, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Usage Example:</h4>
                    <pre><code class="language-javascript">// Create a rope hanging from the top
const rope = new Rope(400, 50, 15, 20);

function gameLoop() {
    // Update rope physics
    rope.update();

    // Draw rope
    rope.draw(ctx);

    requestAnimationFrame(gameLoop);
}

// Make the rope interactive!
canvas.addEventListener('mousemove', (e) => {
    const mousePos = new Vector2D(e.offsetX, e.offsetY);

    // Find closest point and apply force
    rope.points.forEach(point => {
        const dist = point.position.distance(mousePos);
        if (dist < 50) {
            const force = mousePos.subtract(point.position).multiply(0.02);
            point.applyForce(force);
        }
    });
});</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Verlet Physics Playground</summary>
                <pre><code class="language-javascript">// ===================================
// VERLET PHYSICS - Complete Implementation
// ===================================

// VerletPoint - A point that uses Verlet integration
class VerletPoint {
    constructor(x, y, pinned = false) {
        this.position = new Vector2D(x, y);
        this.oldPosition = new Vector2D(x, y);  // Previous position
        this.acceleration = new Vector2D(0, 0);
        this.pinned = pinned;  // Pinned points don't move
        this.radius = 5;
    }

    update(dt = 1) {
        if (this.pinned) return;

        // Velocity = current - previous (implicit)
        const velocity = this.position.copy().subtract(this.oldPosition);
        const temp = this.position.copy();

        // Verlet: new = current + velocity + acceleration
        this.position.add(velocity);
        this.position.add(this.acceleration.copy().multiply(dt * dt));

        this.oldPosition = temp;
        this.acceleration.multiply(0);  // Reset
    }

    applyForce(force) {
        this.acceleration.add(force);
    }

    constrain(bounds) {
        // Keep within canvas
        if (this.position.x < 0) this.position.x = 0;
        if (this.position.x > bounds.width) this.position.x = bounds.width;
        if (this.position.y < 0) this.position.y = 0;
        if (this.position.y > bounds.height) this.position.y = bounds.height;
    }
}

// Constraint - Keeps two points at fixed distance
class Constraint {
    constructor(p1, p2, length = null) {
        this.p1 = p1;
        this.p2 = p2;
        this.length = length || p1.position.distance(p2.position);
        this.active = true;
    }

    solve() {
        if (!this.active) return;

        const diff = this.p2.position.copy().subtract(this.p1.position);
        const currentDistance = diff.length();
        if (currentDistance === 0) return;

        // How much to correct
        const correction = (currentDistance - this.length) / currentDistance;
        const correctionVector = diff.copy().multiply(correction * 0.5);

        // Move both points toward each other
        if (!this.p1.pinned) this.p1.position.add(correctionVector);
        if (!this.p2.pinned) this.p2.position.add(correctionVector.multiply(-1));
    }
}

// Rope - Chain of connected points
class Rope {
    constructor(startX, startY, segments = 10, segmentLength = 20) {
        this.points = [];
        this.constraints = [];

        for (let i = 0; i <= segments; i++) {
            const pinned = (i === 0);  // Pin first point
            this.points.push(new VerletPoint(startX, startY + i * segmentLength, pinned));
        }

        for (let i = 0; i < segments; i++) {
            this.constraints.push(new Constraint(this.points[i], this.points[i + 1]));
        }
    }

    update(gravity, wind) {
        this.points.forEach(p => {
            p.applyForce(gravity);
            p.applyForce(wind);
            p.update();
            p.constrain({ width: canvas.width, height: canvas.height });
        });

        // Solve constraints multiple times for stability
        for (let i = 0; i < 3; i++) {
            this.constraints.forEach(c => c.solve());
        }
    }
}

// Cloth - 2D grid of connected points
class Cloth {
    constructor(startX, startY, cols, rows, spacing) {
        this.points = [];
        this.constraints = [];

        // Create grid
        for (let y = 0; y <= rows; y++) {
            this.points[y] = [];
            for (let x = 0; x <= cols; x++) {
                const pinned = (y === 0);  // Pin top row
                this.points[y][x] = new VerletPoint(
                    startX + x * spacing,
                    startY + y * spacing,
                    pinned
                );
            }
        }

        // Create constraints (horizontal, vertical, diagonal)
        for (let y = 0; y <= rows; y++) {
            for (let x = 0; x <= cols; x++) {
                if (x < cols) this.constraints.push(
                    new Constraint(this.points[y][x], this.points[y][x + 1]));
                if (y < rows) this.constraints.push(
                    new Constraint(this.points[y][x], this.points[y + 1][x]));
                // Diagonal for shear resistance
                if (x < cols && y < rows) {
                    this.constraints.push(
                        new Constraint(this.points[y][x], this.points[y + 1][x + 1]));
                    this.constraints.push(
                        new Constraint(this.points[y][x + 1], this.points[y + 1][x]));
                }
            }
        }
    }
}

// Ragdoll - Stick figure with joints
class Ragdoll {
    constructor(x, y, scale = 1) {
        this.points = {};
        this.constraints = [];
        const s = scale;

        // Create body parts
        this.points.head = new VerletPoint(x, y);
        this.points.neck = new VerletPoint(x, y + 20 * s);
        this.points.chest = new VerletPoint(x, y + 40 * s);
        this.points.waist = new VerletPoint(x, y + 70 * s);

        // Arms and legs...
        this.points.leftShoulder = new VerletPoint(x - 10 * s, y + 35 * s);
        this.points.leftHand = new VerletPoint(x - 35 * s, y + 75 * s);
        this.points.rightShoulder = new VerletPoint(x + 10 * s, y + 35 * s);
        this.points.rightHand = new VerletPoint(x + 35 * s, y + 75 * s);
        this.points.leftFoot = new VerletPoint(x - 12 * s, y + 135 * s);
        this.points.rightFoot = new VerletPoint(x + 12 * s, y + 135 * s);

        // Connect with constraints (spine, limbs, cross-body)
        this.addConstraint('head', 'neck');
        this.addConstraint('neck', 'chest');
        // ... more constraints for full skeleton
    }

    addConstraint(name1, name2) {
        this.constraints.push(new Constraint(this.points[name1], this.points[name2]));
    }
}

// State
let ropes = [new Rope(400, 50, 15, 20)];
let cloths = [];
let ragdolls = [];
const gravity = new Vector2D(0, 0.5);
let wind = new Vector2D(0, 0);
let cutMode = false;
let draggedPoint = null;

// Mouse dragging
canvas.addEventListener('mousedown', (e) => {
    const mousePos = getMousePos(e);
    if (cutMode) {
        // Find and cut nearby constraints
        allConstraints.forEach(c => {
            const midPoint = getMidpoint(c.p1.position, c.p2.position);
            if (mousePos.distance(midPoint) < 10) c.active = false;
        });
    } else {
        // Find nearest point to drag
        draggedPoint = findNearestPoint(mousePos, 20);
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (draggedPoint) {
        const mousePos = getMousePos(e);
        draggedPoint.position = mousePos.copy();
        draggedPoint.oldPosition = mousePos.copy();
    }
});

// Animation loop
function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    ropes.forEach(rope => { rope.update(gravity, wind); rope.draw(ctx); });
    cloths.forEach(cloth => { cloth.update(gravity, wind); cloth.draw(ctx); });
    ragdolls.forEach(ragdoll => { ragdoll.update(gravity, wind); ragdoll.draw(ctx); });

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Verlet Physics Playground</h3>
            <p style="text-align: center; color: #9e9e9e; margin-bottom: 20px;">
                Experiment with ropes, cloth, and ragdolls! Drag points, enable wind, and try cut mode to see how constraints work.
            </p>
            <div class="diagram">
                <canvas id="verletDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddRope">Add Rope</button>
                <button id="btnAddCloth">Create Cloth</button>
                <button id="btnAddRagdoll">Add Ragdoll</button>
                <button id="btnToggleWind">Toggle Wind</button>
                <button id="btnCutRope">Cut Mode</button>
                <button id="btnResetVerlet">Reset</button>
            </div>
            <div id="verletInfo" class="info-display">Drag points to interact! Try the ragdoll for realistic physics. In cut mode, click constraints to cut them.</div>

            <div class="key-point">
                <strong>üí° Constraint Iterations:</strong> Notice we solve constraints multiple times per frame (usually 3-5 iterations). More iterations = more rigid/accurate constraints, but slower. Fewer iterations = more stretchy/flexible, but faster. This is a key trade-off in Verlet physics!
            </div>

            <div class="challenge-box">
                <h4>üèÜ What You Can Try:</h4>
                <ul>
                    <li><strong>‚úì Rope:</strong> Already implemented! Add ropes and drag them around.</li>
                    <li><strong>‚úì Cloth:</strong> Already implemented! See how it deforms and flows.</li>
                    <li><strong>‚úì Ragdoll:</strong> Already implemented! Add ragdolls and watch them fall naturally.</li>
                    <li><strong>Experiment:</strong> Try cutting constraints in different places to see how structures collapse!</li>
                    <li><strong>Soft Body:</strong> Create a circle of points with constraints connecting to neighbors and center</li>
                    <li><strong>Bridge:</strong> Modify rope code to pin both ends instead of just the top</li>
                    <li><strong>Chain Links:</strong> Make each segment render as a circle instead of a line</li>
                </ul>
            </div>

            <div class="thinking-prompt">
                <h4>ü§î Common Use Cases:</h4>
                <ul>
                    <li><strong>Grappling Hooks:</strong> Rope that connects player to anchor point</li>
                    <li><strong>Hair/Tail Physics:</strong> Chain of points following character</li>
                    <li><strong>Cloth/Capes:</strong> 2D grid with collision detection</li>
                    <li><strong>Bridges/Chains:</strong> Pinned at both ends</li>
                    <li><strong>Soft Body Creatures:</strong> Circular/blob-like entities</li>
                </ul>
            </div>
        </div>

        <!-- PROCEDURAL ANIMATION -->
        <div id="procedural-animation" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üé¨ Procedural Animation</h2>

            <div class="concept-box">
                <h4>What is Procedural Animation?</h4>
                <p>Instead of using pre-made keyframe animations, procedural animation generates movement through code and math! This creates organic, dynamic animations that respond to the game state.</p>
                <p><strong>Common Uses:</strong></p>
                <ul>
                    <li><strong>Idle animations:</strong> Breathing, hovering, swaying</li>
                    <li><strong>Reactive movement:</strong> Tentacles, ropes, chains</li>
                    <li><strong>Natural motion:</strong> Combining sine/cosine waves</li>
                    <li><strong>Character effects:</strong> Head bobbing, leaning</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>Core Techniques</h4>
                <p><strong>1. Sine Waves for Rhythm:</strong></p>
                <div class="formula">
                    offset = sin(time √ó frequency) √ó amplitude
                </div>
                <p><strong>2. Following Chain (Delayed Movement):</strong></p>
                <div class="formula">
                    segment[i].position.lerp(segment[i-1].position, smoothing)
                </div>
                <p><strong>3. Combining Multiple Waves:</strong></p>
                <div class="formula">
                    y = sin(t) √ó amplitude1 + sin(t √ó 2 + offset) √ó amplitude2
                </div>
            </div>

            <details data-demo-id="procedural" data-deps="vector2d,clearCanvas,drawGrid,randomFloat">
                <summary>üìù Click to see: Procedural Animation Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Butterfly - Wing flapping with figure-8 flight pattern
class Butterfly {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.time = 0;
        this.wingPhase = 0;
    }

    update(dt) {
        this.time += dt;
        this.wingPhase += dt * 12; // Wing flapping speed

        // Figure-8 flight pattern using Lissajous curve
        this.position.x += Math.sin(this.time * 0.8) * 0.5;
        this.position.y += Math.sin(this.time * 1.6) * 0.3;
    }

    draw(ctx) {
        // Wing flapping animation
        const wingAngle = Math.sin(this.wingPhase) * 0.5;
        // Draw wings with rotating angles...
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üêü Fish - Swimming with tail wagging:</h4>
                    <pre><code class="language-javascript">class Fish {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.tailPhase = 0;
        this.targetAngle = 0;
        this.currentAngle = 0;
    }

    update(dt) {
        this.tailPhase += dt * 8;

        // Smoothly rotate toward target direction
        let angleDiff = this.targetAngle - this.currentAngle;
        this.currentAngle += angleDiff * dt * 2;

        // Move in current direction
        this.velocity.x = Math.cos(this.currentAngle) * speed * dt;
        this.velocity.y = Math.sin(this.currentAngle) * speed * dt;
        this.position.add(this.velocity);

        // Tail wagging for swimming effect
        const tailWag = Math.sin(this.tailPhase) * 0.4;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéê Jellyfish - Pulsing with tentacle chains:</h4>
                    <pre><code class="language-javascript">class Jellyfish {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.tentacles = []; // Array of segment chains
        this.pulsePhase = 0;
    }

    update(dt) {
        this.pulsePhase += dt * 4;

        // Pulsing propulsion - only push when contracting
        const pulse = Math.sin(this.pulsePhase);
        if (pulse > 0) {
            this.velocity.y -= pulse * 0.3;
        }

        // Update tentacles with chain following
        this.tentacles.forEach(segments => {
            for (let j = 1; j < segments.length; j++) {
                // Each segment follows previous with delay
                segments[j].lerp(segments[j - 1], 0.15);
            }
        });
    }
}</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Procedural Animation</summary>
                <pre><code class="language-javascript">// ===================================
// PROCEDURAL ANIMATION - Complete Implementation
// ===================================

// Butterfly - Figure-8 flight with wing flapping
class Butterfly {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.time = Math.random() * Math.PI * 2;
        this.speed = randomFloat(0.8, 1.5);
        this.wingPhase = 0;
    }

    update(dt) {
        this.time += dt * this.speed;
        this.wingPhase += dt * 12;  // Wing flap speed

        // Figure-8 flight (Lissajous curve)
        this.position.x += Math.sin(this.time * 0.8) * 0.5;
        this.position.y += Math.sin(this.time * 1.6) * 0.3;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);

        // Calculate direction from movement
        const angle = Math.atan2(
            Math.sin(this.time * 1.6), Math.sin(this.time * 0.8)
        );
        ctx.rotate(angle);

        // Wing flapping using sin
        const wingAngle = Math.sin(this.wingPhase) * 0.5;
        // Draw wings with rotating angles...
        ctx.restore();
    }
}

// Fish - Swimming with tail wag
class Fish {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.tailPhase = 0;
        this.currentAngle = 0;
        this.targetAngle = Math.random() * Math.PI * 2;
    }

    update(dt) {
        this.tailPhase += dt * 8;

        // Smooth rotation toward target
        let angleDiff = this.targetAngle - this.currentAngle;
        this.currentAngle += angleDiff * dt * 2;

        // Move in facing direction
        const speed = 50;
        this.position.x += Math.cos(this.currentAngle) * speed * dt;
        this.position.y += Math.sin(this.currentAngle) * speed * dt;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.currentAngle);

        // Body (ellipse)
        ctx.fillStyle = this.color;
        ctx.ellipse(0, 0, this.size, this.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tail wag using sin
        const tailWag = Math.sin(this.tailPhase) * 0.4;
        ctx.save();
        ctx.translate(-this.size, 0);
        ctx.rotate(tailWag);  // Rotation creates wag effect
        // Draw tail triangle...
        ctx.restore();
        ctx.restore();
    }
}

// Jellyfish - Pulsing with trailing tentacles
class Jellyfish {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.pulsePhase = 0;
        this.tentacles = [];  // Arrays of segment positions

        // Create tentacle chains
        for (let i = 0; i < 8; i++) {
            const segments = [];
            for (let j = 0; j < 6; j++) {
                segments.push(new Vector2D(x, y + j * 10));
            }
            this.tentacles.push(segments);
        }
    }

    update(dt) {
        this.pulsePhase += dt * 4;

        // Pulsing propulsion (only push when contracting)
        const pulse = Math.sin(this.pulsePhase);
        if (pulse > 0) {
            this.velocity.y -= pulse * 0.3;
        }

        this.position.add(this.velocity);
        this.velocity.multiply(0.98);  // Damping

        // Update tentacles - each segment follows previous
        this.tentacles.forEach(segments => {
            segments[0] = this.position.copy();
            for (let j = 1; j < segments.length; j++) {
                segments[j].lerp(segments[j - 1], 0.15);
            }
        });
    }
}

const creatures = [];

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    const dt = 1 / 60;
    creatures.forEach(c => {
        c.update(dt);
        c.draw(ctx);
    });

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Bringing Math to Life</h3>
            <p>Combine everything! Use curves for paths, noise for variation, and easing for natural motion. This creates dynamic, procedural animations that feel alive and unique every time.</p>
            <div class="diagram">
                <canvas id="proceduralDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddButterfly">ü¶ã Add Butterfly</button>
                <button id="btnAddFish">üêü Add Fish</button>
                <button id="btnAddJellyfish">üéê Add Jellyfish</button>
                <button id="btnClearCreatures">Clear All</button>
            </div>
            <div id="proceduralInfo" class="info-display">Watch the procedural animation magic! Click to add creatures.</div>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> Procedural animation shines when you need infinite variation or reactive behavior. Combine it with spring physics for even more organic results! Try using different frequencies and amplitudes to create unique movement patterns. Adding random phase offsets (starting positions in the sine wave) prevents entities from moving in perfect sync.
            </div>
        </div>

        <!-- WAVE SIMULATION -->
        <div id="wave-simulation" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üåä Wave Simulation</h2>

            <div class="concept-box">
                <h4>What are Waves?</h4>
                <p>Waves are oscillating disturbances that propagate through space. In games, wave simulation creates realistic water, cloth, flags, sound visualization, and force fields!</p>
                <p><strong>Key Properties:</strong></p>
                <ul>
                    <li><strong>Amplitude:</strong> Maximum displacement from rest position (wave height)</li>
                    <li><strong>Wavelength:</strong> Distance between wave peaks</li>
                    <li><strong>Frequency:</strong> How many oscillations per second</li>
                    <li><strong>Phase:</strong> Offset in time (creates wave motion)</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>Wave Equation</h4>
                <p><strong>Basic Sine Wave:</strong></p>
                <div class="formula">
                    y = amplitude √ó sin(x √ó frequency + phase)
                </div>
                <p><strong>Traveling Wave:</strong></p>
                <div class="formula">
                    y = amplitude √ó sin(x √ó frequency - time √ó speed)
                </div>
                <p>The <code>- time √ó speed</code> term makes the wave move! Positive speed moves right, negative moves left.</p>
            </div>

            <div class="concept-box">
                <h4>Types of Waves</h4>
                <p><strong>1. Standing Wave:</strong> Oscillates in place (guitar strings, flags)</p>
                <p><strong>2. Traveling Wave:</strong> Moves through space (water ripples, sound)</p>
                <p><strong>3. Interference:</strong> Multiple waves combining (ocean waves, force fields)</p>
            </div>

            <details data-demo-id="wave" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Wave Simulation Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// 1D Wave System - Perfect for water surfaces, ropes, flags
class Wave1D {
    constructor(points, length) {
        this.points = points;      // Number of points in the wave
        this.length = length;      // Physical length
        this.y = new Array(points).fill(0);       // Current positions
        this.velocity = new Array(points).fill(0); // Velocities
        this.damping = 0.99;   // Energy loss (0.95-0.99 typical)
        this.tension = 0.025;  // Wave propagation speed
    }

    update() {
        // Calculate forces based on neighbors
        for (let i = 1; i < this.points - 1; i++) {
            // Force from left and right neighbors
            const force = (this.y[i - 1] + this.y[i + 1]) / 2 - this.y[i];
            this.velocity[i] += force * this.tension;
        }

        // Apply velocities and damping
        for (let i = 0; i < this.points; i++) {
            this.y[i] += this.velocity[i];
            this.velocity[i] *= this.damping;
        }
    }

    disturb(index, force) {
        // Create a disturbance (like dropping a stone in water)
        if (index >= 0 && index < this.points) {
            this.velocity[index] += force;
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéµ Standing Wave Generator:</h4>
                    <pre><code class="language-javascript">// Great for visualizing sound, vibrations, energy fields
class StandingWave {
    constructor(amplitude, frequency, points) {
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.points = points;
        this.time = 0;
    }

    update(dt) {
        this.time += dt;
    }

    getY(x) {
        // Standing wave: oscillates in place
        return this.amplitude * Math.sin(x * this.frequency) * Math.cos(this.time * 3);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üåä Traveling Wave System:</h4>
                    <pre><code class="language-javascript">// Perfect for water, energy blasts, shockwaves
class TravelingWave {
    constructor(amplitude, wavelength, speed) {
        this.amplitude = amplitude;
        this.wavelength = wavelength;
        this.speed = speed;
        this.time = 0;
    }

    update(dt) {
        this.time += dt;
    }

    getY(x) {
        // Traveling wave: moves through space
        const frequency = (2 * Math.PI) / this.wavelength;
        return this.amplitude * Math.sin(x * frequency - this.time * this.speed);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí´ Wave Interference (Multiple Waves):</h4>
                    <pre><code class="language-javascript">// Combine multiple waves for complex effects
class WaveField {
    constructor() {
        this.sources = []; // Array of {x, y, amplitude, frequency, phase}
    }

    addSource(x, y, amplitude = 20, frequency = 0.1) {
        this.sources.push({ x, y, amplitude, frequency, phase: 0 });
    }

    update(dt) {
        // Advance phase of all sources
        this.sources.forEach(source => {
            source.phase += dt * 2;
        });
    }

    getHeight(x, y) {
        // Sum contributions from all wave sources
        let height = 0;
        this.sources.forEach(source => {
            const dx = x - source.x;
            const dy = y - source.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Circular wave spreading from source
            height += source.amplitude * Math.sin(distance * source.frequency - source.phase);
        });
        return height;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Wave Playground</h3>
            <p>Experiment with different wave types! Click to create disturbances in the physical simulation, or watch mathematical waves travel and interfere.</p>
            <div class="diagram">
                <canvas id="waveDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnPhysicalWave">üíß Physical Wave</button>
                <button id="btnStandingWave">üéµ Standing Wave</button>
                <button id="btnTravelingWave">üåä Traveling Wave</button>
                <button id="btnInterference">üí´ Wave Interference</button>
                <button id="btnResetWaves">Reset</button>
            </div>
            <div id="waveInfo" class="info-display">Click on Physical Wave mode to create ripples!</div>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> For realistic water, combine multiple waves with different frequencies! Add small, fast ripples on top of large, slow waves. Use interference patterns for force fields and energy effects. The physical simulation (spring-based) is great for interactive water, while mathematical waves are perfect for backgrounds and visual effects.
            </div>
        </div>

        <!-- FRICTION & DRAG -->
        <div id="friction" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üí® Friction & Drag Systems</h2>

            <div class="concept-box">
                <h4>Why Friction Matters</h4>
                <p>Without friction, objects would slide forever! Friction makes movement feel grounded and realistic.</p>
                <p><strong>Two types:</strong></p>
                <ul>
                    <li><strong>Linear Friction:</strong> Simple multiplier (velocity √ó 0.98)</li>
                    <li><strong>Drag Force:</strong> Proportional to velocity squared (more realistic)</li>
                </ul>
            </div>

            <details data-demo-id="friction" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Friction Implementations</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Simple Linear Friction
class LinearFriction {
    constructor(coefficient = 0.98) {
        this.coefficient = coefficient;  // 0.98 = 2% speed loss per frame
    }

    apply(entity) {
        entity.velocity.multiply(this.coefficient);

        // Stop if moving very slowly (prevent infinite drift)
        if (entity.velocity.length() < 0.01) {
            entity.velocity.multiply(0);
        }
    }
}

// Air/Fluid Drag (more realistic)
class DragForce {
    constructor(coefficient = 0.01) {
        this.coefficient = coefficient;
    }

    apply(entity) {
        // Drag = -coefficient √ó velocity¬≤
        const speed = entity.velocity.length();
        const dragMagnitude = this.coefficient * speed * speed;

        // Apply drag in opposite direction of movement
        const dragForce = entity.velocity.copy()
            .normalize()
            .multiply(-dragMagnitude);

        entity.applyForce(dragForce);
    }
}

// Ground Friction (only when touching ground)
class GroundFriction {
    constructor(coefficient = 0.15) {
        this.coefficient = coefficient;
    }

    apply(entity) {
        if (entity.onGround) {
            // Friction opposes horizontal movement
            const friction = -entity.velocity.x * this.coefficient;
            entity.velocity.x += friction;
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Ice vs Grass vs Mud</h4>
                    <pre><code class="language-javascript">// Different surfaces have different friction
const surfaces = {
    ice: new LinearFriction(0.99),    // Very slippery
    grass: new LinearFriction(0.92),  // Normal friction
    mud: new LinearFriction(0.80)    // High friction
};

function update(player, currentSurface) {
    // Apply appropriate friction
    surfaces[currentSurface].apply(player);

    player.position.add(player.velocity);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Friction Comparison</h3>
            <div class="diagram">
                <canvas id="frictionDemo" width="800" height="400"></canvas>
            </div>
            <div class="controls">
                <button id="btnNoFriction">No Friction</button>
                <button id="btnLowFriction">Low Friction (Ice)</button>
                <button id="btnMediumFriction">Medium Friction (Grass)</button>
                <button id="btnHighFriction">High Friction (Mud)</button>
            </div>
            <div id="frictionInfo" class="info-display">Click to launch objects and compare friction</div>
        </div>

        <!-- COLLISION DETECTION -->
        <div id="collision" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üí• Collision Detection</h2>

            <div class="concept-box">
                <h4>Types of Collision Detection</h4>
                <ul>
                    <li><strong>Circle vs Circle:</strong> Compare distance to sum of radii</li>
                    <li><strong>Rectangle vs Rectangle (AABB):</strong> Check overlap on both axes</li>
                    <li><strong>Circle vs Rectangle:</strong> Find closest point on rectangle to circle center</li>
                </ul>
            </div>

            <details data-demo-id="collision" data-deps="vector2d,clearCanvas,randomFloat,clamp">
                <summary>üìù Click to see: Collision Detection Functions</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Circle vs Circle
function circleVsCircle(c1, r1, c2, r2) {
    const distance = c1.distance(c2);
    return distance < r1 + r2;
}

// AABB (Axis-Aligned Bounding Box) - Rectangle vs Rectangle
function aabbVsAabb(pos1, w1, h1, pos2, w2, h2) {
    return pos1.x < pos2.x + w2 &&
           pos1.x + w1 > pos2.x &&
           pos1.y < pos2.y + h2 &&
           pos1.y + h1 > pos2.y;
}

// Circle vs Rectangle
function circleVsRect(circlePos, radius, rectPos, width, height) {
    // Find closest point on rectangle to circle
    const closestX = clamp(circlePos.x, rectPos.x, rectPos.x + width);
    const closestY = clamp(circlePos.y, rectPos.y, rectPos.y + height);

    const distX = circlePos.x - closestX;
    const distY = circlePos.y - closestY;

    return (distX * distX + distY * distY) < (radius * radius);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Collision Detection</h3>
            <div class="diagram">
                <canvas id="collisionDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddCircle">Add Circle</button>
                <button id="btnAddRect">Add Rectangle</button>
                <button id="btnClearCollision">Clear All</button>
            </div>
            <div id="collisionInfo" class="info-display">Drag objects around. They'll turn red when colliding!</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Collision Response</h4>
                <p>Try implementing these collision responses:</p>
                <ul>
                    <li>Make objects bounce off each other</li>
                    <li>Transfer momentum between colliding objects</li>
                    <li>Create "sticky" collisions that join objects together</li>
                </ul>
            </div>
        </div>

        <!-- BOUNCING & REFLECTION -->
        <div id="reflection" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>‚ö° Bouncing & Reflection</h2>

            <div class="concept-box">
                <h4>Making Things Bounce</h4>
                <p>Bouncing and reflection make physics feel satisfying! Essential for:</p>
                <ul>
                    <li>Balls bouncing off walls</li>
                    <li>Bullets ricocheting</li>
                    <li>Character wall-jumping</li>
                    <li>Pinball-style gameplay</li>
                </ul>
            </div>

            <details data-demo-id="reflection" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Reflection Implementations</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Simple Axis-Aligned Reflection (walls parallel to axes)
function bounceOffWalls(object, bounds, bounciness = 0.8) {
    // Right wall
    if (object.position.x + object.radius > bounds.right) {
        object.position.x = bounds.right - object.radius;
        object.velocity.x *= -bounciness;  // Reverse and reduce
    }

    // Left wall
    if (object.position.x - object.radius < bounds.left) {
        object.position.x = bounds.left + object.radius;
        object.velocity.x *= -bounciness;
    }

    // Bottom wall
    if (object.position.y + object.radius > bounds.bottom) {
        object.position.y = bounds.bottom - object.radius;
        object.velocity.y *= -bounciness;
    }

    // Top wall
    if (object.position.y - object.radius < bounds.top) {
        object.position.y = bounds.top + object.radius;
        object.velocity.y *= -bounciness;
    }
}

// Reflection Off Any Surface (using surface normal)
function reflect(velocity, surfaceNormal) {
    // Formula: v' = v - 2(v ¬∑ n)n
    // Where n is the surface normal (unit vector)
    const dotProduct = velocity.dot(surfaceNormal);
    const reflection = surfaceNormal
        .copy()
        .multiply(2 * dotProduct);

    return velocity.subtract(reflection);
}

// Circle Bouncing Off Circle
function bounceCircles(a, b, elasticity = 0.9) {
    // Get collision normal (from b to a)
    const normal = a.position.subtract(b.position).normalize();

    // Relative velocity
    const relativeVel = a.velocity.subtract(b.velocity);

    // Velocity along collision normal
    const speed = relativeVel.dot(normal);

    // Don't bounce if moving apart
    if (speed > 0) return;

    // Calculate impulse (considering mass)
    const impulse = (2 * speed) / (a.mass + b.mass);

    // Apply impulse to both objects
    a.velocity.subtract(normal.copy().multiply(impulse * b.mass * elasticity));
    b.velocity.add(normal.copy().multiply(impulse * a.mass * elasticity));

    // Separate objects to prevent overlap
    const overlap = (a.radius + b.radius) - a.position.distance(b.position);
    if (overlap > 0) {
        const separation = normal.copy().multiply(overlap / 2);
        a.position.add(separation);
        b.position.subtract(separation);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Breakout/Pong Ball</h4>
                    <pre><code class="language-javascript">class Ball {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(5, 5);
        this.radius = 10;
        this.bounciness = 1.0;  // Perfect bounce
    }

    update(bounds) {
        // Move ball
        this.position.add(this.velocity);

        // Bounce off walls
        bounceOffWalls(this, bounds, this.bounciness);
    }

    hitPaddle(paddle) {
        // Reflect based on where it hit the paddle
        const relativeHit = (this.position.x - paddle.x) / (paddle.width / 2);
        const angle = relativeHit * (Math.PI / 4);  // Max 45 degrees

        const speed = this.velocity.length();
        this.velocity.x = Math.sin(angle) * speed;
        this.velocity.y = -Math.abs(Math.cos(angle) * speed);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Bouncing Physics</h3>
            <div class="diagram">
                <canvas id="reflectionDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnPerfectBounce">Perfect Bounce (1.0)</button>
                <button id="btnNormalBounce">Normal Bounce (0.8)</button>
                <button id="btnDeadBounce">Dead Bounce (0.3)</button>
                <button id="btnCircleBounce">Circle Collisions</button>
            </div>
            <div id="reflectionInfo" class="info-display">Click to add bouncing balls</div>

            <div class="key-point">
                <strong>üí° Bounciness Values:</strong> 1.0 = perfect elastic collision (no energy loss), 0.5 = loses half the energy, 0.0 = no bounce (sticks to surface). Real materials: rubber ‚âà 0.8, wood ‚âà 0.5, clay ‚âà 0.1
            </div>
        </div>

        <!-- RAYCASTING -->
        <div id="raycasting" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üëÅÔ∏è Raycasting & Line of Sight</h2>

            <div class="concept-box">
                <h4>What is Raycasting?</h4>
                <p>Raycasting shoots an invisible line (ray) from a point in a direction to check what it hits. Used for:</p>
                <ul>
                    <li><strong>Line of sight:</strong> Can the enemy see the player?</li>
                    <li><strong>Shooting:</strong> What did the bullet hit?</li>
                    <li><strong>Mouse picking:</strong> What object did the user click?</li>
                    <li><strong>Pathfinding:</strong> Is there a wall in the way?</li>
                </ul>
            </div>

            <details data-demo-id="raycasting" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Ray Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Ray {
    constructor(origin, direction) {
        this.origin = origin.copy();
        this.direction = direction.copy().normalize();
    }

    // Check if ray intersects with a circle
    intersectsCircle(center, radius) {
        const oc = this.origin.subtract(center);
        const a = this.direction.dot(this.direction);
        const b = 2 * oc.dot(this.direction);
        const c = oc.dot(oc) - radius * radius;

        const discriminant = b * b - 4 * a * c;
        return discriminant >= 0;
    }

    // Get point along ray at distance t
    pointAt(t) {
        return new Vector2D(
            this.origin.x + this.direction.x * t,
            this.origin.y + this.direction.y * t
        );
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Raycasting</h3>
            <div class="diagram">
                <canvas id="raycastDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddObstacle">Add Obstacle</button>
                <button id="btnClearRaycast">Clear Obstacles</button>
            </div>
            <div id="raycastInfo" class="info-display">Move your mouse. Rays turn red when they hit objects!</div>
        </div>

        <!-- PARTICLE SYSTEMS -->
        <div id="particles" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>‚ú® Particle Systems</h2>

            <div class="concept-box">
                <h4>What are Particle Systems?</h4>
                <p>Particle systems create visual effects using many small objects (particles). Used for:</p>
                <ul>
                    <li>Explosions and fire</li>
                    <li>Smoke and steam</li>
                    <li>Rain and snow</li>
                    <li>Magic spells and trails</li>
                </ul>
            </div>

            <details data-demo-id="particles" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Particle System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Particle {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = Vector2D.random(randomFloat(1, 5));
        this.life = 1.0;
        this.decay = randomFloat(0.01, 0.03);
        this.size = randomFloat(2, 8);
    }

    update() {
        this.velocity.multiply(0.98);  // Friction
        this.position.add(this.velocity);
        this.life -= this.decay;
        return this.life > 0;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = '#ffa726';
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    emit(x, y, count = 20) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y));
        }
    }

    update() {
        this.particles = this.particles.filter(p => p.update());
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Particle Effects</h3>
            <div class="diagram">
                <canvas id="particleDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnExplosion">Explosion</button>
                <button id="btnFountain">Fountain</button>
                <button id="btnTrail">Trail Mode</button>
            </div>
            <div id="particleInfo" class="info-display">Click anywhere to create particles!</div>

            <div class="thinking-prompt">
                <h4>ü§î Think About It:</h4>
                <p>What happens if you create thousands of particles? How would you optimize the system to handle many effects at once?</p>
                <p><em>Hint: Check out the Expert guide's section on Object Pooling!</em></p>
            </div>
        </div>

        <!-- ADVANCED PARTICLE EFFECTS -->
        <div id="advanced-particles" class="section">
            <span class="level-indicator level-intermediate">INTERMEDIATE</span>
            <h2>üåü Advanced Particle Effects</h2>

            <div class="concept-box">
                <h4>Creating Specific Effects</h4>
                <p>Different particle behaviors create different visual effects. Let's build systems for common game effects!</p>
            </div>

            <h3>Effect Types</h3>

            <details data-demo-id="advancedParticles" data-deps="vector2d,clearCanvas">
                <summary>üìù Effect 1: Fire & Flames</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class FireParticle extends Particle {
    constructor(x, y) {
        super(x, y);

        // Fire rises and spreads
        this.velocity.y = -random(1, 3);  // Upward
        this.velocity.x = random(-0.5, 0.5);  // Slight spread

        this.size = random(4, 12);
        this.life = 1.0;
        this.decay = random(0.02, 0.04);

        // Color transitions: yellow ‚Üí orange ‚Üí red ‚Üí transparent
        this.colors = [
            { r: 255, g: 255, b: 100 },  // Bright yellow
            { r: 255, g: 150, b: 50 },   // Orange
            { r: 255, g: 50, b: 50 }     // Red
        ];
    }

    update() {
        this.life -= this.decay;

        // Accelerate upward (heat rises!)
        this.velocity.y -= 0.05;

        // Shrink as it burns out
        this.size *= 0.98;

        this.position.add(this.velocity);

        return this.life > 0;
    }

    draw(ctx) {
        // Interpolate color based on life
        const colorIndex = Math.floor((1 - this.life) * 2);
        const color = this.colors[Math.min(colorIndex, 2)];

        ctx.globalAlpha = this.life;
        ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y,
                 this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Effect 2: Smoke</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SmokeParticle extends Particle {
    constructor(x, y) {
        super(x, y);

        // Smoke drifts slowly upward
        this.velocity.y = -random(0.3, 0.8);
        this.velocity.x = random(-0.3, 0.3);

        this.size = random(8, 20);
        this.life = 1.0;
        this.decay = random(0.005, 0.015);  // Lasts longer

        // Swirl effect
        this.angle = random(0, Math.PI * 2);
        this.swirl = random(-0.02, 0.02);
    }

    update() {
        this.life -= this.decay;

        // Swirl motion
        this.angle += this.swirl;
        this.velocity.x += Math.cos(this.angle) * 0.05;

        // Expand as it dissipates
        this.size += 0.2;

        this.position.add(this.velocity);

        return this.life > 0;
    }

    draw(ctx) {
        // Gray smoke, fades with life
        const gray = Math.floor(100 + this.life * 100);
        ctx.globalAlpha = this.life * 0.4;  // Semi-transparent
        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y,
                 this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Effect 3: Sparkles/Magic</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SparkleParticle extends Particle {
    constructor(x, y) {
        super(x, y);

        // Sparkles burst outward
        const angle = random(0, Math.PI * 2);
        const speed = random(2, 5);
        this.velocity.x = Math.cos(angle) * speed;
        this.velocity.y = Math.sin(angle) * speed;

        this.size = random(2, 6);
        this.life = 1.0;
        this.decay = random(0.03, 0.06);

        // Random bright color
        this.hue = random(0, 360);

        // Twinkle effect
        this.twinkle = 0;
    }

    update() {
        this.life -= this.decay;

        // Slow down over time
        this.velocity.multiply(0.95);

        // Twinkle animation
        this.twinkle += 0.2;
        const scale = Math.abs(Math.sin(this.twinkle));

        this.currentSize = this.size * scale;

        this.position.add(this.velocity);

        return this.life > 0;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;

        // Draw as a star/cross shape
        const s = this.currentSize;
        ctx.beginPath();
        ctx.moveTo(this.position.x - s, this.position.y);
        ctx.lineTo(this.position.x + s, this.position.y);
        ctx.moveTo(this.position.x, this.position.y - s);
        ctx.lineTo(this.position.x, this.position.y + s);
        ctx.lineWidth = 2;
        ctx.strokeStyle = `hsl(${this.hue}, 100%, 90%)`;
        ctx.stroke();

        ctx.globalAlpha = 1;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Effect 4: Rain & Water</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class RainParticle extends Particle {
    constructor(x, y) {
        super(x, y);

        // Rain falls down with slight wind
        this.velocity.y = random(5, 10);
        this.velocity.x = random(-1, 1);  // Wind effect

        this.length = random(10, 20);
        this.life = 1.0;
        this.decay = 0;  // Doesn't fade until hitting ground
    }

    update(groundY = 600) {
        // Accelerate (gravity)
        this.velocity.y += 0.2;

        this.position.add(this.velocity);

        // Hit ground - create splash!
        if (this.position.y >= groundY) {
            this.createSplash();
            return false;  // Remove raindrop
        }

        return true;
    }

    draw(ctx) {
        ctx.strokeStyle = 'rgba(150, 150, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.position.x, this.position.y);
        ctx.lineTo(
            this.position.x - this.velocity.x * 0.3,
            this.position.y - this.length
        );
        ctx.stroke();
    }

    createSplash() {
        // Create small splash particles (handled by particle system)
        for (let i = 0; i < 5; i++) {
            const angle = random(-Math.PI, 0);  // Upward hemisphere
            const speed = random(1, 3);
            // Emit splash particles...
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Particle Effect Showcase</h3>
            <div class="diagram">
                <canvas id="advancedParticlesDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnFire">üî• Fire</button>
                <button id="btnSmoke">üí® Smoke</button>
                <button id="btnSparkles">‚ú® Sparkles</button>
                <button id="btnRain">üåßÔ∏è Rain</button>
                <button id="btnCombined">üéÜ Combined Effects</button>
                <button id="btnClearParticles">Clear All</button>
            </div>
            <div id="advancedParticlesInfo" class="info-display">Click to create different particle effects!</div>

            <div class="key-point">
                <strong>üí° Pro Tip:</strong> Combine multiple particle types for complex effects! A campfire = fire particles + smoke particles + occasional sparkles. An explosion = fast-moving sparkles + fire burst + smoke trail!
            </div>
        </div>

        <!-- Next Steps -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Great Progress!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You now understand core game systems! Ready for advanced techniques?
            </p>
            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <a href="beginner.html" class="nav-button">‚Üê Review Basics</a>
                <a href="advanced.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                    Continue to Advanced ‚Üí
                </a>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="intermediate-demos.js"></script>
</body>
</html>
