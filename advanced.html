<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
    <!-- Prism.js Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üéÆ Advanced Game Math</h1>
        <p class="subtitle">Complex behaviors - AI, curves, pathfinding, and advanced systems</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="intermediate.html" class="nav-button">‚Üê Intermediate</a>
            <a href="advanced.html" class="nav-button active">Advanced</a>
            <a href="expert.html" class="nav-button">Expert ‚Üí</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#steering">Steering Behaviors (AI Movement)</a></li>
                <li><a href="#quaternions">Quaternions: 3D Rotations</a></li>
                <li><a href="#bezier">B√©zier Curves & Splines</a></li>
                <li><a href="#pathfinding">A* Pathfinding</a></li>
                <li><a href="#flow-fields">Flow Fields (Crowd Movement)</a></li>
                <li><a href="#state-machines">State Machines</a></li>
                <li><a href="#behavior-trees">Behavior Trees (Advanced AI)</a></li>
                <li><a href="#ik">Inverse Kinematics</a></li>
                <li><a href="#shadows">Shadow Casting & Vision</a></li>
                <li><a href="#spatial-hash">Spatial Hashing (Optimization)</a></li>
            </ul>
        </div>

        <!-- STEERING BEHAVIORS -->
        <div id="steering" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>ü§ñ Steering Behaviors (AI Movement)</h2>

            <div class="concept-box">
                <h4>What are Steering Behaviors?</h4>
                <p>Steering behaviors make AI characters move realistically by combining simple forces. Instead of teleporting or moving in straight lines, they accelerate, turn smoothly, and avoid obstacles naturally.</p>
                <p><strong>Behavior Types:</strong></p>
                <ul>
                    <li><strong>Basic:</strong> Seek (move toward), Flee (move away), Arrive (slow down when close), Wander (explore randomly)</li>
                    <li><strong>Predictive:</strong> Pursue (chase future position), Evade (escape from future position)</li>
                    <li><strong>Avoidance:</strong> Obstacle Avoidance (steer around objects)</li>
                    <li><strong>Flocking:</strong> Separation (avoid crowding), Cohesion (stay together), Alignment (match direction)</li>
                </ul>
            </div>

            <details data-demo-id="steering" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Steering Behavior Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SteeringEntity {
    constructor(x, y) {
        this.position = new Vector2D(x, y);
        this.velocity = new Vector2D(0, 0);
        this.maxSpeed = 5;
        this.maxForce = 0.2;
    }

    // Seek: Move toward target
    seek(target) {
        const desired = target.subtract(this.position);
        desired.normalize().multiply(this.maxSpeed);

        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);

        return steer;
    }

    // Arrive: Slow down when close to target
    arrive(target, slowingRadius = 100) {
        const desired = target.subtract(this.position);
        const distance = desired.length();

        if (distance < slowingRadius) {
            // Scale speed based on distance
            const speed = map(distance, 0, slowingRadius, 0, this.maxSpeed);
            desired.normalize().multiply(speed);
        } else {
            desired.normalize().multiply(this.maxSpeed);
        }

        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);

        return steer;
    }

    // Flee: Move away from threat
    flee(threat) {
        const desired = this.position.subtract(threat);
        desired.normalize().multiply(this.maxSpeed);

        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);

        return steer;
    }

    applyForce(force) {
        this.velocity.add(force);
        this.velocity.limit(this.maxSpeed);
    }

    update() {
        this.position.add(this.velocity);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Steering Behaviors</h3>
            <div class="diagram">
                <canvas id="steeringDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSeek" class="active">Seek</button>
                <button id="btnArrive">Arrive</button>
                <button id="btnFlee">Flee</button>
                <button id="btnPursue">Pursue</button>
                <button id="btnEvade">Evade</button>
                <button id="btnWander">Wander</button>
                <button id="btnAvoid">Avoid Obstacles</button>
                <button id="btnFlock">Flock</button>
            </div>
            <div id="steeringInfo" class="info-display">Move your mouse to interact with 15 AI agents. Red obstacles block the way!</div>

            <div class="key-point">
                <strong>üí° Combining Behaviors:</strong> The real power comes from combining multiple behaviors! For example: Seek the player + Avoid obstacles + Separate from allies = Smart enemy movement!
            </div>
        </div>

        <!-- QUATERNIONS -->
        <div id="quaternions" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîÑ Quaternions: 3D Rotations</h2>

            <div class="concept-box">
                <h4>What are Quaternions?</h4>
                <p>Quaternions are a mathematical system for representing 3D rotations. While this guide focuses on 2D games, understanding quaternions is crucial when you move to 3D.</p>
                <p><strong>Why use Quaternions instead of Euler angles (pitch, yaw, roll)?</strong></p>
                <ul>
                    <li><strong>No Gimbal Lock:</strong> Euler angles can "freeze" when two axes align</li>
                    <li><strong>Smooth Interpolation:</strong> Rotating between orientations is smoother</li>
                    <li><strong>Efficient:</strong> Faster for combining multiple rotations</li>
                    <li><strong>Stable:</strong> No numerical drift over many rotations</li>
                </ul>
                <p>A quaternion has 4 components: <code>(x, y, z, w)</code> where w is the "real" part.</p>
            </div>

            <details data-demo-id="quaternion" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Quaternion Implementation (Simplified)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Quaternion {
    constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    // Create quaternion from axis-angle rotation
    static fromAxisAngle(axis, angle) {
        const halfAngle = angle / 2;
        const s = Math.sin(halfAngle);

        return new Quaternion(
            axis.x * s,
            axis.y * s,
            axis.z * s,
            Math.cos(halfAngle)
        );
    }

    // Create from Euler angles (in radians)
    static fromEuler(pitch, yaw, roll) {
        const cy = Math.cos(yaw * 0.5);
        const sy = Math.sin(yaw * 0.5);
        const cp = Math.cos(pitch * 0.5);
        const sp = Math.sin(pitch * 0.5);
        const cr = Math.cos(roll * 0.5);
        const sr = Math.sin(roll * 0.5);

        return new Quaternion(
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy,
            cr * cp * cy + sr * sp * sy
        );
    }

    // Multiply two quaternions (combine rotations)
    multiply(q) {
        return new Quaternion(
            this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
            this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
            this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w,
            this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z
        );
    }

    // Spherical linear interpolation (smooth rotation)
    static slerp(q1, q2, t) {
        let dot = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;

        // If negative dot, negate one quaternion
        if (dot < 0) {
            q2 = new Quaternion(-q2.x, -q2.y, -q2.z, -q2.w);
            dot = -dot;
        }

        // If very close, use linear interpolation
        if (dot > 0.9995) {
            return new Quaternion(
                lerp(q1.x, q2.x, t),
                lerp(q1.y, q2.y, t),
                lerp(q1.z, q2.z, t),
                lerp(q1.w, q2.w, t)
            ).normalize();
        }

        const theta = Math.acos(dot);
        const sinTheta = Math.sin(theta);

        const w1 = Math.sin((1 - t) * theta) / sinTheta;
        const w2 = Math.sin(t * theta) / sinTheta;

        return new Quaternion(
            q1.x * w1 + q2.x * w2,
            q1.y * w1 + q2.y * w2,
            q1.z * w1 + q2.z * w2,
            q1.w * w1 + q2.w * w2
        );
    }

    normalize() {
        const len = Math.sqrt(this.x * this.x + this.y * this.y +
                              this.z * this.z + this.w * this.w);
        this.x /= len;
        this.y /= len;
        this.z /= len;
        this.w /= len;
        return this;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Quaternion Rotation</h3>
            <div class="diagram">
                <canvas id="quaternionDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnRotateX">Rotate X-axis</button>
                <button id="btnRotateY">Rotate Y-axis</button>
                <button id="btnRotateZ">Rotate Z-axis</button>
                <button id="btnSlerp">Smooth Interpolation</button>
            </div>
            <div id="quaternionInfo" class="info-display">Watch smooth 3D rotation without gimbal lock</div>

            <div class="key-point">
                <strong>üí° When to use Quaternions:</strong> For 3D games, character animation, camera systems, or any time you need smooth, stable rotations in 3D space!
            </div>
        </div>

        <!-- B√âZIER CURVES -->
        <div id="bezier" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üìà B√©zier Curves & Splines</h2>

            <div class="concept-box">
                <h4>What are B√©zier Curves?</h4>
                <p>B√©zier curves create smooth, curved paths between points. They're used for:</p>
                <ul>
                    <li>Character movement paths</li>
                    <li>Camera tracks</li>
                    <li>Projectile arcs</li>
                    <li>UI animations</li>
                </ul>
                <p>A quadratic B√©zier curve has 3 points: start, control point, and end.</p>
            </div>

            <details data-demo-id="bezier" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: B√©zier Curve Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Quadratic Bezier: 3 points (start, control, end)
function quadraticBezier(p0, p1, p2, t) {
    const x = (1 - t) * (1 - t) * p0.x +
              2 * (1 - t) * t * p1.x +
              t * t * p2.x;

    const y = (1 - t) * (1 - t) * p0.y +
              2 * (1 - t) * t * p1.y +
              t * t * p2.y;

    return new Vector2D(x, y);
}

// Cubic Bezier: 4 points (start, control1, control2, end)
function cubicBezier(p0, p1, p2, p3, t) {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;
    const uuu = uu * u;
    const ttt = tt * t;

    const x = uuu * p0.x +
              3 * uu * t * p1.x +
              3 * u * tt * p2.x +
              ttt * p3.x;

    const y = uuu * p0.y +
              3 * uu * t * p1.y +
              3 * u * tt * p2.y +
              ttt * p3.y;

    return new Vector2D(x, y);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: B√©zier Curves</h3>
            <div class="diagram">
                <canvas id="bezierDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnQuadratic">Quadratic (3 points)</button>
                <button id="btnCubic">Cubic (4 points)</button>
                <button id="btnAnimate">Animate Path</button>
            </div>
            <div id="bezierInfo" class="info-display">Drag the control points to reshape the curve</div>
        </div>

        <!-- A* PATHFINDING -->
        <div id="pathfinding" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üó∫Ô∏è A* Pathfinding</h2>

            <div class="concept-box">
                <h4>What is A* Pathfinding?</h4>
                <p>A* (pronounced "A-star") finds the shortest path from start to goal, avoiding obstacles. It's used in:</p>
                <ul>
                    <li>Strategy games (RTS units finding paths)</li>
                    <li>RPGs (characters navigating to targets)</li>
                    <li>Tower defense (enemy pathing)</li>
                </ul>
                <p><strong>How it works:</strong></p>
                <ol>
                    <li>Start at the beginning node</li>
                    <li>Explore neighboring nodes</li>
                    <li>Pick the node with lowest cost (distance + estimated distance to goal)</li>
                    <li>Repeat until goal is reached</li>
                </ol>
                <div class="formula">
                    f(n) = g(n) + h(n)
                </div>
                <p>Where:</p>
                <ul>
                    <li><code>g(n)</code> = cost from start to current node</li>
                    <li><code>h(n)</code> = estimated cost from current to goal (heuristic)</li>
                    <li><code>f(n)</code> = total estimated cost</li>
                </ul>
            </div>

            <details data-demo-id="astar" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: A* Implementation (Simplified)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Node {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.g = 0;  // Cost from start
        this.h = 0;  // Heuristic (estimated cost to goal)
        this.f = 0;  // Total cost (g + h)
        this.parent = null;
    }
}

function astar(start, goal, grid) {
    const openSet = [start];
    const closedSet = [];

    while (openSet.length > 0) {
        // Find node with lowest f score
        let current = openSet[0];
        for (let i = 1; i < openSet.length; i++) {
            if (openSet[i].f < current.f) {
                current = openSet[i];
            }
        }

        // Found the goal!
        if (current === goal) {
            return reconstructPath(current);
        }

        // Move current from open to closed
        openSet.splice(openSet.indexOf(current), 1);
        closedSet.push(current);

        // Check all neighbors
        const neighbors = getNeighbors(current, grid);
        for (const neighbor of neighbors) {
            if (closedSet.includes(neighbor)) continue;

            const tempG = current.g + 1;  // Distance to neighbor

            if (!openSet.includes(neighbor)) {
                openSet.push(neighbor);
            } else if (tempG >= neighbor.g) {
                continue;  // Not a better path
            }

            neighbor.g = tempG;
            neighbor.h = heuristic(neighbor, goal);
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.parent = current;
        }
    }

    return [];  // No path found
}

function heuristic(a, b) {
    // Manhattan distance
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: A* Pathfinding</h3>
            <div class="diagram">
                <canvas id="astarDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSetStart">Set Start</button>
                <button id="btnSetGoal">Set Goal</button>
                <button id="btnAddWalls">Draw Walls</button>
                <button id="btnFindPath">Find Path</button>
                <button id="btnClearGrid">Clear Grid</button>
            </div>
            <div id="astarInfo" class="info-display">Click to place start/goal, drag to draw walls</div>

            <div class="thinking-prompt">
                <h4>ü§î Think About It:</h4>
                <p>A* is great for grid-based games. But what if your game doesn't use a grid? Try researching "navigation meshes" (navmeshes) for non-grid pathfinding!</p>
            </div>
        </div>

        <!-- FLOW FIELDS -->
        <div id="flow-fields" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üåä Flow Fields (Crowd Movement)</h2>

            <div class="concept-box">
                <h4>What are Flow Fields?</h4>
                <p>Flow fields enable hundreds or thousands of units to pathfind efficiently toward a goal. Instead of each unit calculating its own path, we create a "flow" map that shows every grid cell which direction to move.</p>
                <p><strong>Perfect for:</strong></p>
                <ul>
                    <li>RTS games with many units moving to same location</li>
                    <li>Tower defense with waves of enemies</li>
                    <li>Crowd simulations</li>
                    <li>Zombie hordes converging on player</li>
                </ul>
                <p><strong>How it works:</strong> Run pathfinding ONCE from the goal to create a vector field. Each unit simply follows the arrow in its current grid cell!</p>
            </div>

            <details data-demo-id="flowField" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Flow Field Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class FlowField {
    constructor(width, height, cellSize) {
        this.width = width;
        this.height = height;
        this.cellSize = cellSize;
        this.cols = Math.ceil(width / cellSize);
        this.rows = Math.ceil(height / cellSize);

        // Cost field: how difficult to traverse each cell
        this.costField = [];
        // Integration field: distance to goal
        this.integrationField = [];
        // Flow field: direction to move
        this.flowField = [];

        this.initializeFields();
    }

    initializeFields() {
        for (let y = 0; y < this.rows; y++) {
            this.costField[y] = [];
            this.integrationField[y] = [];
            this.flowField[y] = [];

            for (let x = 0; x < this.cols; x++) {
                this.costField[y][x] = 1;  // Default cost
                this.integrationField[y][x] = 65535;  // Max value
                this.flowField[y][x] = new Vector2D(0, 0);
            }
        }
    }

    setObstacle(x, y) {
        if (this.inBounds(x, y)) {
            this.costField[y][x] = 255;  // Impassable
        }
    }

    generateFlowField(goalX, goalY) {
        // Step 1: Create integration field (distance from goal)
        this.createIntegrationField(goalX, goalY);

        // Step 2: Create flow field (direction to move)
        this.createFlowField();
    }

    createIntegrationField(goalX, goalY) {
        // Reset integration field
        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                this.integrationField[y][x] = 65535;
            }
        }

        // Goal has distance 0
        this.integrationField[goalY][goalX] = 0;

        // Dijkstra's algorithm from goal
        const openList = [{x: goalX, y: goalY}];

        while (openList.length > 0) {
            const current = openList.shift();
            const neighbors = this.getNeighbors(current.x, current.y);

            for (const neighbor of neighbors) {
                const cost = this.costField[neighbor.y][neighbor.x];
                if (cost === 255) continue;  // Impassable

                const newCost = this.integrationField[current.y][current.x] + cost;

                if (newCost < this.integrationField[neighbor.y][neighbor.x]) {
                    this.integrationField[neighbor.y][neighbor.x] = newCost;
                    openList.push(neighbor);
                }
            }
        }
    }

    createFlowField() {
        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                if (this.costField[y][x] === 255) continue;

                // Find neighbor with lowest integration value
                let lowestCost = this.integrationField[y][x];
                let bestDirection = new Vector2D(0, 0);

                const neighbors = this.getNeighbors(x, y);
                for (const neighbor of neighbors) {
                    const cost = this.integrationField[neighbor.y][neighbor.x];
                    if (cost < lowestCost) {
                        lowestCost = cost;
                        bestDirection = new Vector2D(
                            neighbor.x - x,
                            neighbor.y - y
                        ).normalize();
                    }
                }

                this.flowField[y][x] = bestDirection;
            }
        }
    }

    getFlowDirection(worldX, worldY) {
        const x = Math.floor(worldX / this.cellSize);
        const y = Math.floor(worldY / this.cellSize);

        if (this.inBounds(x, y)) {
            return this.flowField[y][x];
        }

        return new Vector2D(0, 0);
    }

    getNeighbors(x, y) {
        const neighbors = [];
        const directions = [
            {x: 1, y: 0}, {x: -1, y: 0},
            {x: 0, y: 1}, {x: 0, y: -1}
        ];

        for (const dir of directions) {
            const nx = x + dir.x;
            const ny = y + dir.y;
            if (this.inBounds(nx, ny)) {
                neighbors.push({x: nx, y: ny});
            }
        }

        return neighbors;
    }

    inBounds(x, y) {
        return x >= 0 && x < this.cols && y >= 0 && y < this.rows;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using Flow Fields:</h4>
                    <pre><code class="language-javascript">// Create flow field
const flowField = new FlowField(800, 600, 20);

// Add obstacles
flowField.setObstacle(10, 10);
flowField.setObstacle(10, 11);

// Generate field toward goal
flowField.generateFlowField(30, 20);

// Each unit follows the flow
units.forEach(unit => {
    const direction = flowField.getFlowDirection(unit.x, unit.y);
    unit.velocity = direction.multiply(unit.maxSpeed);
    unit.update();
});</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Flow Field Visualization</h3>
            <div class="diagram">
                <canvas id="flowFieldDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSetGoalFlow">Set Goal</button>
                <button id="btnDrawObstacles">Draw Obstacles</button>
                <button id="btnSpawnUnits">Spawn 50 Units</button>
                <button id="btnClearFlowField">Clear All</button>
                <button id="btnToggleArrows">Toggle Arrows</button>
            </div>
            <div id="flowFieldInfo" class="info-display">Click to set goal, drag to draw obstacles, then spawn units</div>

            <div class="key-point">
                <strong>üí° Performance:</strong> Flow fields are calculated once per goal change. 1000 units following a flow field is just as fast as 10 units! Compare this to A* where each unit needs its own path.
            </div>
        </div>

        <!-- STATE MACHINES -->
        <div id="state-machines" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîÑ State Machines</h2>

            <div class="concept-box">
                <h4>What are State Machines?</h4>
                <p>State machines help manage complex behavior by breaking it into simple states. An entity can only be in one state at a time, and transitions between states based on conditions.</p>
                <p><strong>Example - Enemy AI States:</strong></p>
                <ul>
                    <li><strong>Patrol:</strong> Walk around until player is spotted</li>
                    <li><strong>Chase:</strong> Run toward player</li>
                    <li><strong>Attack:</strong> When close enough, attack</li>
                    <li><strong>Flee:</strong> If health is low, run away</li>
                </ul>
            </div>

            <details data-demo-id="state" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: State Machine Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class State {
    enter(entity) {}   // Called when entering this state
    update(entity) {}  // Called every frame
    exit(entity) {}    // Called when leaving this state
}

class PatrolState extends State {
    enter(entity) {
        entity.speed = 2;
        entity.color = '#66bb6a';
    }

    update(entity) {
        // Walk around randomly
        if (Math.random() < 0.02) {
            entity.direction = Vector2D.random(1);
        }

        // Check if player is nearby
        const distToPlayer = entity.position.distance(player.position);
        if (distToPlayer < 150) {
            entity.setState(new ChaseState());
        }
    }
}

class ChaseState extends State {
    enter(entity) {
        entity.speed = 4;
        entity.color = '#ffa726';
    }

    update(entity) {
        // Chase the player
        entity.direction = player.position.subtract(entity.position).normalize();

        const distToPlayer = entity.position.distance(player.position);

        // Close enough to attack?
        if (distToPlayer < 50) {
            entity.setState(new AttackState());
        }
        // Lost sight of player?
        else if (distToPlayer > 300) {
            entity.setState(new PatrolState());
        }
    }
}

class Entity {
    constructor() {
        this.currentState = new PatrolState();
        this.currentState.enter(this);
    }

    setState(newState) {
        this.currentState.exit(this);
        this.currentState = newState;
        this.currentState.enter(this);
    }

    update() {
        this.currentState.update(this);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: State Machine AI</h3>
            <div class="diagram">
                <canvas id="stateDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddEnemy">Add Enemy</button>
                <button id="btnResetStates">Reset</button>
            </div>
            <div id="stateInfo" class="info-display">Use WASD to move. Watch enemies change states!</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: More Complex States</h4>
                <p>Try adding these states:</p>
                <ul>
                    <li><strong>Investigate:</strong> When player was seen but lost, search the area</li>
                    <li><strong>Call for Help:</strong> Alert nearby allies when player is spotted</li>
                    <li><strong>Celebrate:</strong> Victory dance when player is defeated</li>
                </ul>
            </div>
        </div>

        <!-- BEHAVIOR TREES -->
        <div id="behavior-trees" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üå≥ Behavior Trees (Advanced AI)</h2>

            <div class="concept-box">
                <h4>What are Behavior Trees?</h4>
                <p>Behavior Trees are a more flexible alternative to State Machines for AI decision-making. They organize behaviors into a tree structure that's evaluated from top to bottom.</p>
                <p><strong>Why use Behavior Trees?</strong></p>
                <ul>
                    <li>More modular and reusable than state machines</li>
                    <li>Easier to visualize and debug</li>
                    <li>Can handle complex decision-making</li>
                    <li>Used in many AAA games (Halo, Sp</li>ore, etc.)</li>
                </ul>
                <p><strong>Node Types:</strong></p>
                <ul>
                    <li><strong>Composite Nodes:</strong> Have children, control flow
                        <ul>
                            <li><strong>Sequence:</strong> Run children until one fails (AND logic)</li>
                            <li><strong>Selector:</strong> Run children until one succeeds (OR logic)</li>
                        </ul>
                    </li>
                    <li><strong>Decorator Nodes:</strong> Modify behavior of child (Repeat, Invert, etc.)</li>
                    <li><strong>Leaf Nodes:</strong> Actions (Move, Attack) or Conditions (IsPlayerNear?)</li>
                </ul>
            </div>

            <details data-demo-id="behaviorTree" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Behavior Tree Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Base Node class
class BTNode {
    // Returns: SUCCESS, FAILURE, or RUNNING
    execute(agent) {
        return 'FAILURE';
    }
}

// Sequence: Runs children until one fails
class Sequence extends BTNode {
    constructor(...children) {
        super();
        this.children = children;
        this.currentChild = 0;
    }

    execute(agent) {
        while (this.currentChild < this.children.length) {
            const result = this.children[this.currentChild].execute(agent);

            if (result === 'FAILURE') {
                this.currentChild = 0;
                return 'FAILURE';
            }

            if (result === 'RUNNING') {
                return 'RUNNING';
            }

            this.currentChild++;
        }

        this.currentChild = 0;
        return 'SUCCESS';
    }
}

// Selector: Runs children until one succeeds
class Selector extends BTNode {
    constructor(...children) {
        super();
        this.children = children;
        this.currentChild = 0;
    }

    execute(agent) {
        while (this.currentChild < this.children.length) {
            const result = this.children[this.currentChild].execute(agent);

            if (result === 'SUCCESS') {
                this.currentChild = 0;
                return 'SUCCESS';
            }

            if (result === 'RUNNING') {
                return 'RUNNING';
            }

            this.currentChild++;
        }

        this.currentChild = 0;
        return 'FAILURE';
    }
}

// Condition Node: Checks a condition
class Condition extends BTNode {
    constructor(conditionFn) {
        super();
        this.conditionFn = conditionFn;
    }

    execute(agent) {
        return this.conditionFn(agent) ? 'SUCCESS' : 'FAILURE';
    }
}

// Action Node: Performs an action
class Action extends BTNode {
    constructor(actionFn) {
        super();
        this.actionFn = actionFn;
    }

    execute(agent) {
        return this.actionFn(agent);
    }
}

// Decorator: Inverts result
class Inverter extends BTNode {
    constructor(child) {
        super();
        this.child = child;
    }

    execute(agent) {
        const result = this.child.execute(agent);
        if (result === 'SUCCESS') return 'FAILURE';
        if (result === 'FAILURE') return 'SUCCESS';
        return result;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Enemy AI Behavior Tree</h4>
                    <pre><code class="language-javascript">// Build behavior tree for enemy
const enemyBehavior = new Selector(
    // Option 1: Attack if player is close
    new Sequence(
        new Condition(agent => agent.isPlayerNear()),
        new Action(agent => agent.attack())
    ),

    // Option 2: Chase if player is visible
    new Sequence(
        new Condition(agent => agent.canSeePlayer()),
        new Action(agent => agent.chasePlayer())
    ),

    // Option 3: Patrol if health is good
    new Sequence(
        new Condition(agent => agent.health > 50),
        new Action(agent => agent.patrol())
    ),

    // Option 4: Flee if health is low (fallback)
    new Action(agent => agent.flee())
);

// Run behavior tree each frame
function update() {
    enemies.forEach(enemy => {
        enemyBehavior.execute(enemy);
    });
}</code></pre>
                </div>

                <div class="thinking-prompt">
                    <h4>üß† How it works:</h4>
                    <p>The Selector tries each option from top to bottom:</p>
                    <ol>
                        <li>Try to attack (only if player is near)</li>
                        <li>If that fails, try to chase (only if player is visible)</li>
                        <li>If that fails, try to patrol (only if health is good)</li>
                        <li>If everything else fails, flee!</li>
                    </ol>
                    <p>This creates intelligent, prioritized decision-making!</p>
                </div>
            </details>

            <h3>Interactive Demo: Behavior Tree Visualization</h3>
            <div class="diagram">
                <canvas id="behaviorTreeDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSpawnEnemy">Spawn Enemy</button>
                <button id="btnToggleTree">Show Tree</button>
                <button id="btnStepBehavior">Step Through</button>
                <button id="btnResetBehavior">Reset</button>
            </div>
            <div id="behaviorTreeInfo" class="info-display">Use WASD to move. Watch enemies make decisions!</div>

            <div class="key-point">
                <strong>üí° Behavior Trees vs State Machines:</strong> Use State Machines for simple, well-defined states (like player movement). Use Behavior Trees for complex AI decision-making where you need priorities and fallbacks!
            </div>
        </div>

        <!-- INVERSE KINEMATICS -->
        <div id="ik" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>ü¶æ Inverse Kinematics</h2>

            <div class="concept-box">
                <h4>What is Inverse Kinematics (IK)?</h4>
                <p>IK is the technique of calculating joint angles needed to reach a target position. It's the opposite of Forward Kinematics (FK).</p>
                <ul>
                    <li><strong>Forward Kinematics:</strong> "Given these joint angles, where does the hand end up?"</li>
                    <li><strong>Inverse Kinematics:</strong> "To reach this position, what joint angles do I need?"</li>
                </ul>
                <p><strong>Common Uses:</strong></p>
                <ul>
                    <li>Character arms reaching for objects</li>
                    <li>Legs adapting to terrain</li>
                    <li>Robotic arm simulations</li>
                    <li>Procedural animation</li>
                </ul>
            </div>

            <details data-demo-id="ik" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Two-Joint IK Implementation (Arm/Leg)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class TwoJointIK {
    constructor(baseX, baseY, length1, length2) {
        this.base = new Vector2D(baseX, baseY);
        this.length1 = length1;  // Upper arm/leg length
        this.length2 = length2;  // Lower arm/leg length
        this.joint = new Vector2D(0, 0);
        this.end = new Vector2D(0, 0);
    }

    solve(targetX, targetY) {
        const target = new Vector2D(targetX, targetY);
        const toTarget = target.subtract(this.base);
        const distance = toTarget.length();

        // Maximum reach
        const maxReach = this.length1 + this.length2;

        // Target is out of reach - stretch toward it
        if (distance >= maxReach) {
            const direction = toTarget.normalize();
            this.joint = this.base.add(direction.multiply(this.length1));
            this.end = this.joint.add(direction.multiply(this.length2));
            return;
        }

        // Target is too close
        if (distance < Math.abs(this.length1 - this.length2)) {
            const direction = toTarget.normalize();
            this.joint = this.base.add(direction.multiply(this.length1));
            this.end = target;
            return;
        }

        // Use law of cosines to find angles
        const a = this.length1;
        const b = this.length2;
        const c = distance;

        // Angle at the base
        const angleToTarget = Math.atan2(toTarget.y, toTarget.x);
        const cosAngle1 = (a * a + c * c - b * b) / (2 * a * c);
        const angle1 = Math.acos(clamp(cosAngle1, -1, 1));

        // Calculate joint position
        const jointAngle = angleToTarget + angle1;
        this.joint.x = this.base.x + a * Math.cos(jointAngle);
        this.joint.y = this.base.y + a * Math.sin(jointAngle);

        // End effector is the target
        this.end = target.copy();
    }

    draw(ctx) {
        // Draw bones
        ctx.strokeStyle = '#42a5f5';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(this.base.x, this.base.y);
        ctx.lineTo(this.joint.x, this.joint.y);
        ctx.lineTo(this.end.x, this.end.y);
        ctx.stroke();

        // Draw joints
        [this.base, this.joint, this.end].forEach((joint, i) => {
            ctx.fillStyle = i === 2 ? '#f44336' : '#66bb6a';
            ctx.beginPath();
            ctx.arc(joint.x, joint.y, 10, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Inverse Kinematics</h3>
            <div class="diagram">
                <canvas id="ikDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddArm">Add Arm</button>
                <button id="btnToggleConstraints">Toggle Constraints</button>
                <button id="btnResetIK">Reset</button>
            </div>
            <div id="ikInfo" class="info-display">Move your mouse - watch the arms reach for it!</div>

            <div class="thinking-prompt">
                <h4>ü§î Think About It:</h4>
                <p>For more than 2 joints (like a full spine or tentacle), you'd use an iterative algorithm like FABRIK (Forward And Backward Reaching Inverse Kinematics). It's more complex but handles any number of joints!</p>
            </div>
        </div>

        <!-- SHADOW CASTING & VISION -->
        <div id="shadows" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üëÅÔ∏è Shadow Casting & Vision</h2>

            <div class="concept-box">
                <h4>What is Shadow Casting?</h4>
                <p>Shadow casting determines what areas are visible from a point of view and what's hidden in shadows. Essential for:</p>
                <ul>
                    <li>Stealth games (can enemies see the player?)</li>
                    <li>Fog of war in strategy games</li>
                    <li>Lighting and shadow systems</li>
                    <li>Line-of-sight for AI</li>
                </ul>
                <p><strong>Common Techniques:</strong></p>
                <ul>
                    <li><strong>Raycasting:</strong> Cast rays in all directions from light source</li>
                    <li><strong>Shadow Volumes:</strong> Project shapes away from light</li>
                    <li><strong>Visibility Polygons:</strong> Calculate the exact visible area</li>
                </ul>
            </div>

            <details data-demo-id="shadow" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Raycasting Shadow Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class ShadowCaster {
    constructor() {
        this.walls = [];  // Line segments that cast shadows
    }

    addWall(x1, y1, x2, y2) {
        this.walls.push({
            p1: new Vector2D(x1, y1),
            p2: new Vector2D(x2, y2)
        });
    }

    // Get all unique angles to cast rays toward
    getAngles(source) {
        const angles = [];

        for (const wall of this.walls) {
            // Add angles to each endpoint
            const angle1 = Math.atan2(wall.p1.y - source.y, wall.p1.x - source.x);
            const angle2 = Math.atan2(wall.p2.y - source.y, wall.p2.x - source.x);

            // Add small offsets to catch edges
            angles.push(angle1 - 0.0001, angle1, angle1 + 0.0001);
            angles.push(angle2 - 0.0001, angle2, angle2 + 0.0001);
        }

        return angles;
    }

    // Cast a ray and find closest intersection
    castRay(source, angle, maxDistance = 1000) {
        const direction = new Vector2D(
            Math.cos(angle),
            Math.sin(angle)
        );

        const rayEnd = source.add(direction.multiply(maxDistance));

        let closestIntersection = rayEnd;
        let closestDistance = maxDistance;

        for (const wall of this.walls) {
            const intersection = lineIntersection(
                source, rayEnd,
                wall.p1, wall.p2
            );

            if (intersection) {
                const dist = source.distance(intersection);
                if (dist < closestDistance) {
                    closestDistance = dist;
                    closestIntersection = intersection;
                }
            }
        }

        return closestIntersection;
    }

    // Calculate visible polygon
    getVisibleArea(source) {
        const angles = this.getAngles(source);
        const intersections = [];

        for (const angle of angles) {
            const point = this.castRay(source, angle);
            intersections.push({
                point: point,
                angle: Math.atan2(point.y - source.y, point.x - source.x)
            });
        }

        // Sort by angle
        intersections.sort((a, b) => a.angle - b.angle);

        return intersections.map(i => i.point);
    }

    draw(ctx, source) {
        const visibleArea = this.getVisibleArea(source);

        // Draw visible area
        ctx.fillStyle = 'rgba(255, 255, 100, 0.3)';
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        visibleArea.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.fill();

        // Draw light source
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        ctx.arc(source.x, source.y, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Shadow Casting</h3>
            <div class="diagram">
                <canvas id="shadowDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddObstacle">Add Obstacle</button>
                <button id="btnClearObstacles">Clear Obstacles</button>
                <button id="btnToggleRays">Toggle Rays</button>
            </div>
            <div id="shadowInfo" class="info-display">Move your mouse to cast light and shadows</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Field of View</h4>
                <p>Modify the shadow caster to only show a limited field of view (like 90 degrees). This is great for stealth games where enemies have cone-shaped vision!</p>
            </div>
        </div>

        <!-- SPATIAL HASHING -->
        <div id="spatial-hash" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîç Spatial Hashing (Optimization)</h2>

            <div class="concept-box">
                <h4>What is Spatial Hashing?</h4>
                <p>Spatial hashing is a technique to quickly find nearby objects without checking every object. It's simpler than QuadTrees but extremely effective for many scenarios!</p>
                <p><strong>How it works:</strong> Divide the world into a grid. Each object goes into one or more grid cells. To find nearby objects, only check the cells near you!</p>
                <p><strong>Perfect for:</strong></p>
                <ul>
                    <li>Collision detection in large worlds</li>
                    <li>Finding nearby enemies/items</li>
                    <li>Multiplayer games with many players</li>
                    <li>Bullet-to-enemy collision checking</li>
                </ul>
            </div>

            <details data-demo-id="spatialHash" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Spatial Hash Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SpatialHash {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.cells = new Map();  // Hash map of cell coordinates to objects
    }

    // Convert world position to cell key
    getKey(x, y) {
        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);
        return `${cellX},${cellY}`;
    }

    // Insert object into hash
    insert(object) {
        const key = this.getKey(object.position.x, object.position.y);

        if (!this.cells.has(key)) {
            this.cells.set(key, []);
        }

        this.cells.get(key).push(object);
        object.cellKey = key;  // Store for removal
    }

    // Remove object from hash
    remove(object) {
        if (!object.cellKey) return;

        const cell = this.cells.get(object.cellKey);
        if (cell) {
            const index = cell.indexOf(object);
            if (index !== -1) {
                cell.splice(index, 1);
            }
        }

        object.cellKey = null;
    }

    // Update object position (remove from old cell, add to new)
    update(object) {
        const newKey = this.getKey(object.position.x, object.position.y);

        // Only update if cell changed
        if (object.cellKey !== newKey) {
            this.remove(object);
            this.insert(object);
        }
    }

    // Get all objects in nearby cells
    getNearby(x, y, range = 1) {
        const nearby = [];
        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);

        // Check surrounding cells
        for (let dx = -range; dx <= range; dx++) {
            for (let dy = -range; dy <= range; dy++) {
                const key = `${cellX + dx},${cellY + dy}`;
                const cell = this.cells.get(key);

                if (cell) {
                    nearby.push(...cell);
                }
            }
        }

        return nearby;
    }

    // Get objects in a rectangular area
    queryRect(x, y, width, height) {
        const objects = new Set();

        const startX = Math.floor(x / this.cellSize);
        const startY = Math.floor(y / this.cellSize);
        const endX = Math.ceil((x + width) / this.cellSize);
        const endY = Math.ceil((y + height) / this.cellSize);

        for (let cx = startX; cx <= endX; cx++) {
            for (let cy = startY; cy <= endY; cy++) {
                const key = `${cx},${cy}`;
                const cell = this.cells.get(key);

                if (cell) {
                    cell.forEach(obj => objects.add(obj));
                }
            }
        }

        return Array.from(objects);
    }

    // Clear all objects
    clear() {
        this.cells.clear();
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using Spatial Hash for Collision Detection:</h4>
                    <pre><code class="language-javascript">// Create spatial hash with 50px cells
const spatialHash = new SpatialHash(50);

// Insert all game objects
gameObjects.forEach(obj => spatialHash.insert(obj));

// Each frame: update objects and check collisions
function update() {
    gameObjects.forEach(obj => {
        // Move object
        obj.update();

        // Update its cell in the hash
        spatialHash.update(obj);

        // Check collisions only with nearby objects
        const nearby = spatialHash.getNearby(
            obj.position.x,
            obj.position.y,
            1  // Check 1 cell in each direction
        );

        nearby.forEach(other => {
            if (obj !== other && obj.collidesWith(other)) {
                handleCollision(obj, other);
            }
        });
    });
}

// Example: Find all enemies near player
const nearbyEnemies = spatialHash
    .getNearby(player.x, player.y, 2)
    .filter(obj => obj.type === 'enemy');</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Spatial Hash Visualization</h3>
            <div class="diagram">
                <canvas id="spatialHashDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAdd100">Add 100 Objects</button>
                <button id="btnToggleGrid">Toggle Grid</button>
                <button id="btnShowNearby">Show Nearby Query</button>
                <button id="btnClearHash">Clear All</button>
            </div>
            <div id="spatialHashInfo" class="info-display">Move mouse to query nearby objects. Watch collision checks!</div>

            <div class="key-point">
                <strong>üí° Performance Comparison:</strong>
                <ul>
                    <li><strong>Brute Force:</strong> 1000 objects = 1,000,000 checks</li>
                    <li><strong>Spatial Hash:</strong> 1000 objects = ~5,000 checks (200x faster!)</li>
                    <li><strong>Cell Size Tip:</strong> Make cells about 2x the size of your largest object for best performance</li>
                </ul>
            </div>
        </div>

        <!-- Next Steps -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Excellent Work!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You've mastered advanced techniques! Ready for expert-level optimization?
            </p>
            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <a href="intermediate.html" class="nav-button">‚Üê Review Core Systems</a>
                <a href="expert.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                    Continue to Expert ‚Üí
                </a>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="advanced-demos.js"></script>
</body>
</html>
