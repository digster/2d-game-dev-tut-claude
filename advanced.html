<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üéÆ Advanced Game Math</h1>
        <p class="subtitle">Complex behaviors - AI, curves, pathfinding, and advanced systems</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="intermediate.html" class="nav-button">‚Üê Intermediate</a>
            <a href="advanced.html" class="nav-button active">Advanced</a>
            <a href="expert.html" class="nav-button">Expert ‚Üí</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#steering">Steering Behaviors (AI Movement)</a></li>
                <li><a href="#quaternions">Quaternions: 3D Rotations</a></li>
                <li><a href="#bezier">B√©zier Curves & Splines</a></li>
                <li><a href="#pathfinding">A* Pathfinding</a></li>
                <li><a href="#flow-fields">Flow Fields (Crowd Movement)</a></li>
                <li><a href="#state-machines">State Machines</a></li>
                <li><a href="#behavior-trees">Behavior Trees (Advanced AI)</a></li>
                <li><a href="#ik">Inverse Kinematics</a></li>
                <li><a href="#shadows">Shadow Casting & Vision</a></li>
                <li><a href="#spatial-hash">Spatial Hashing (Optimization)</a></li>
            </ul>
        </div>

        <!-- STEERING BEHAVIORS -->
        <div id="steering" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>ü§ñ Steering Behaviors (AI Movement)</h2>

            <div class="concept-box">
                <h4>What are Steering Behaviors?</h4>
                <p>Steering behaviors make AI characters move realistically by combining simple forces. Instead of teleporting or moving in straight lines, they accelerate, turn smoothly, and avoid obstacles naturally.</p>
                <p><strong>Behavior Types:</strong></p>
                <ul>
                    <li><strong>Basic:</strong> Seek (move toward), Flee (move away), Arrive (slow down when close), Wander (explore randomly)</li>
                    <li><strong>Predictive:</strong> Pursue (chase future position), Evade (escape from future position)</li>
                    <li><strong>Avoidance:</strong> Obstacle Avoidance (steer around objects)</li>
                    <li><strong>Flocking:</strong> Separation (avoid crowding), Cohesion (stay together), Alignment (match direction)</li>
                </ul>
            </div>

            <details data-demo-id="steering" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Steering Behavior Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">SteeringEntity</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.maxSpeed = <span class="number">5</span>;
        <span class="keyword">this</span>.maxForce = <span class="number">0.2</span>;
    }

    <span class="comment">// Seek: Move toward target</span>
    <span class="function">seek</span>(target) {
        <span class="keyword">const</span> desired = target.<span class="function">subtract</span>(<span class="keyword">this</span>.position);
        desired.<span class="function">normalize</span>().<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);

        <span class="keyword">const</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);

        <span class="keyword">return</span> steer;
    }

    <span class="comment">// Arrive: Slow down when close to target</span>
    <span class="function">arrive</span>(target, slowingRadius = <span class="number">100</span>) {
        <span class="keyword">const</span> desired = target.<span class="function">subtract</span>(<span class="keyword">this</span>.position);
        <span class="keyword">const</span> distance = desired.<span class="function">length</span>();

        <span class="keyword">if</span> (distance < slowingRadius) {
            <span class="comment">// Scale speed based on distance</span>
            <span class="keyword">const</span> speed = <span class="function">map</span>(distance, <span class="number">0</span>, slowingRadius, <span class="number">0</span>, <span class="keyword">this</span>.maxSpeed);
            desired.<span class="function">normalize</span>().<span class="function">multiply</span>(speed);
        } <span class="keyword">else</span> {
            desired.<span class="function">normalize</span>().<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);
        }

        <span class="keyword">const</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);

        <span class="keyword">return</span> steer;
    }

    <span class="comment">// Flee: Move away from threat</span>
    <span class="function">flee</span>(threat) {
        <span class="keyword">const</span> desired = <span class="keyword">this</span>.position.<span class="function">subtract</span>(threat);
        desired.<span class="function">normalize</span>().<span class="function">multiply</span>(<span class="keyword">this</span>.maxSpeed);

        <span class="keyword">const</span> steer = desired.<span class="function">subtract</span>(<span class="keyword">this</span>.velocity);
        steer.<span class="function">limit</span>(<span class="keyword">this</span>.maxForce);

        <span class="keyword">return</span> steer;
    }

    <span class="function">applyForce</span>(force) {
        <span class="keyword">this</span>.velocity.<span class="function">add</span>(force);
        <span class="keyword">this</span>.velocity.<span class="function">limit</span>(<span class="keyword">this</span>.maxSpeed);
    }

    <span class="function">update</span>() {
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Steering Behaviors</h3>
            <div class="diagram">
                <canvas id="steeringDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSeek" class="active">Seek</button>
                <button id="btnArrive">Arrive</button>
                <button id="btnFlee">Flee</button>
                <button id="btnPursue">Pursue</button>
                <button id="btnEvade">Evade</button>
                <button id="btnWander">Wander</button>
                <button id="btnAvoid">Avoid Obstacles</button>
                <button id="btnFlock">Flock</button>
            </div>
            <div id="steeringInfo" class="info-display">Move your mouse to interact with 15 AI agents. Red obstacles block the way!</div>

            <div class="key-point">
                <strong>üí° Combining Behaviors:</strong> The real power comes from combining multiple behaviors! For example: Seek the player + Avoid obstacles + Separate from allies = Smart enemy movement!
            </div>
        </div>

        <!-- QUATERNIONS -->
        <div id="quaternions" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîÑ Quaternions: 3D Rotations</h2>

            <div class="concept-box">
                <h4>What are Quaternions?</h4>
                <p>Quaternions are a mathematical system for representing 3D rotations. While this guide focuses on 2D games, understanding quaternions is crucial when you move to 3D.</p>
                <p><strong>Why use Quaternions instead of Euler angles (pitch, yaw, roll)?</strong></p>
                <ul>
                    <li><strong>No Gimbal Lock:</strong> Euler angles can "freeze" when two axes align</li>
                    <li><strong>Smooth Interpolation:</strong> Rotating between orientations is smoother</li>
                    <li><strong>Efficient:</strong> Faster for combining multiple rotations</li>
                    <li><strong>Stable:</strong> No numerical drift over many rotations</li>
                </ul>
                <p>A quaternion has 4 components: <code>(x, y, z, w)</code> where w is the "real" part.</p>
            </div>

            <details data-demo-id="quaternion" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Quaternion Implementation (Simplified)</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">Quaternion</span> {
    <span class="keyword">constructor</span>(x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>, w = <span class="number">1</span>) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
        <span class="keyword">this</span>.z = z;
        <span class="keyword">this</span>.w = w;
    }

    <span class="comment">// Create quaternion from axis-angle rotation</span>
    <span class="keyword">static</span> <span class="function">fromAxisAngle</span>(axis, angle) {
        <span class="keyword">const</span> halfAngle = angle / <span class="number">2</span>;
        <span class="keyword">const</span> s = Math.<span class="function">sin</span>(halfAngle);

        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            axis.x * s,
            axis.y * s,
            axis.z * s,
            Math.<span class="function">cos</span>(halfAngle)
        );
    }

    <span class="comment">// Create from Euler angles (in radians)</span>
    <span class="keyword">static</span> <span class="function">fromEuler</span>(pitch, yaw, roll) {
        <span class="keyword">const</span> cy = Math.<span class="function">cos</span>(yaw * <span class="number">0.5</span>);
        <span class="keyword">const</span> sy = Math.<span class="function">sin</span>(yaw * <span class="number">0.5</span>);
        <span class="keyword">const</span> cp = Math.<span class="function">cos</span>(pitch * <span class="number">0.5</span>);
        <span class="keyword">const</span> sp = Math.<span class="function">sin</span>(pitch * <span class="number">0.5</span>);
        <span class="keyword">const</span> cr = Math.<span class="function">cos</span>(roll * <span class="number">0.5</span>);
        <span class="keyword">const</span> sr = Math.<span class="function">sin</span>(roll * <span class="number">0.5</span>);

        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy,
            cr * cp * cy + sr * sp * sy
        );
    }

    <span class="comment">// Multiply two quaternions (combine rotations)</span>
    <span class="function">multiply</span>(q) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            <span class="keyword">this</span>.w * q.x + <span class="keyword">this</span>.x * q.w + <span class="keyword">this</span>.y * q.z - <span class="keyword">this</span>.z * q.y,
            <span class="keyword">this</span>.w * q.y - <span class="keyword">this</span>.x * q.z + <span class="keyword">this</span>.y * q.w + <span class="keyword">this</span>.z * q.x,
            <span class="keyword">this</span>.w * q.z + <span class="keyword">this</span>.x * q.y - <span class="keyword">this</span>.y * q.x + <span class="keyword">this</span>.z * q.w,
            <span class="keyword">this</span>.w * q.w - <span class="keyword">this</span>.x * q.x - <span class="keyword">this</span>.y * q.y - <span class="keyword">this</span>.z * q.z
        );
    }

    <span class="comment">// Spherical linear interpolation (smooth rotation)</span>
    <span class="keyword">static</span> <span class="function">slerp</span>(q1, q2, t) {
        <span class="keyword">let</span> dot = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;

        <span class="comment">// If negative dot, negate one quaternion</span>
        <span class="keyword">if</span> (dot < <span class="number">0</span>) {
            q2 = <span class="keyword">new</span> <span class="function">Quaternion</span>(-q2.x, -q2.y, -q2.z, -q2.w);
            dot = -dot;
        }

        <span class="comment">// If very close, use linear interpolation</span>
        <span class="keyword">if</span> (dot > <span class="number">0.9995</span>) {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
                <span class="function">lerp</span>(q1.x, q2.x, t),
                <span class="function">lerp</span>(q1.y, q2.y, t),
                <span class="function">lerp</span>(q1.z, q2.z, t),
                <span class="function">lerp</span>(q1.w, q2.w, t)
            ).<span class="function">normalize</span>();
        }

        <span class="keyword">const</span> theta = Math.<span class="function">acos</span>(dot);
        <span class="keyword">const</span> sinTheta = Math.<span class="function">sin</span>(theta);

        <span class="keyword">const</span> w1 = Math.<span class="function">sin</span>((<span class="number">1</span> - t) * theta) / sinTheta;
        <span class="keyword">const</span> w2 = Math.<span class="function">sin</span>(t * theta) / sinTheta;

        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Quaternion</span>(
            q1.x * w1 + q2.x * w2,
            q1.y * w1 + q2.y * w2,
            q1.z * w1 + q2.z * w2,
            q1.w * w1 + q2.w * w2
        );
    }

    <span class="function">normalize</span>() {
        <span class="keyword">const</span> len = Math.<span class="function">sqrt</span>(<span class="keyword">this</span>.x * <span class="keyword">this</span>.x + <span class="keyword">this</span>.y * <span class="keyword">this</span>.y +
                              <span class="keyword">this</span>.z * <span class="keyword">this</span>.z + <span class="keyword">this</span>.w * <span class="keyword">this</span>.w);
        <span class="keyword">this</span>.x /= len;
        <span class="keyword">this</span>.y /= len;
        <span class="keyword">this</span>.z /= len;
        <span class="keyword">this</span>.w /= len;
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Quaternion Rotation</h3>
            <div class="diagram">
                <canvas id="quaternionDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnRotateX">Rotate X-axis</button>
                <button id="btnRotateY">Rotate Y-axis</button>
                <button id="btnRotateZ">Rotate Z-axis</button>
                <button id="btnSlerp">Smooth Interpolation</button>
            </div>
            <div id="quaternionInfo" class="info-display">Watch smooth 3D rotation without gimbal lock</div>

            <div class="key-point">
                <strong>üí° When to use Quaternions:</strong> For 3D games, character animation, camera systems, or any time you need smooth, stable rotations in 3D space!
            </div>
        </div>

        <!-- B√âZIER CURVES -->
        <div id="bezier" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üìà B√©zier Curves & Splines</h2>

            <div class="concept-box">
                <h4>What are B√©zier Curves?</h4>
                <p>B√©zier curves create smooth, curved paths between points. They're used for:</p>
                <ul>
                    <li>Character movement paths</li>
                    <li>Camera tracks</li>
                    <li>Projectile arcs</li>
                    <li>UI animations</li>
                </ul>
                <p>A quadratic B√©zier curve has 3 points: start, control point, and end.</p>
            </div>

            <details data-demo-id="bezier" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: B√©zier Curve Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Quadratic B√©zier: 3 points (start, control, end)</span>
<span class="keyword">function</span> <span class="function">quadraticBezier</span>(p0, p1, p2, t) {
    <span class="keyword">const</span> x = (<span class="number">1</span> - t) * (<span class="number">1</span> - t) * p0.x +
              <span class="number">2</span> * (<span class="number">1</span> - t) * t * p1.x +
              t * t * p2.x;

    <span class="keyword">const</span> y = (<span class="number">1</span> - t) * (<span class="number">1</span> - t) * p0.y +
              <span class="number">2</span> * (<span class="number">1</span> - t) * t * p1.y +
              t * t * p2.y;

    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
}

<span class="comment">// Cubic B√©zier: 4 points (start, control1, control2, end)</span>
<span class="keyword">function</span> <span class="function">cubicBezier</span>(p0, p1, p2, p3, t) {
    <span class="keyword">const</span> u = <span class="number">1</span> - t;
    <span class="keyword">const</span> tt = t * t;
    <span class="keyword">const</span> uu = u * u;
    <span class="keyword">const</span> uuu = uu * u;
    <span class="keyword">const</span> ttt = tt * t;

    <span class="keyword">const</span> x = uuu * p0.x +
              <span class="number">3</span> * uu * t * p1.x +
              <span class="number">3</span> * u * tt * p2.x +
              ttt * p3.x;

    <span class="keyword">const</span> y = uuu * p0.y +
              <span class="number">3</span> * uu * t * p1.y +
              <span class="number">3</span> * u * tt * p2.y +
              ttt * p3.y;

    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: B√©zier Curves</h3>
            <div class="diagram">
                <canvas id="bezierDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnQuadratic">Quadratic (3 points)</button>
                <button id="btnCubic">Cubic (4 points)</button>
                <button id="btnAnimate">Animate Path</button>
            </div>
            <div id="bezierInfo" class="info-display">Drag the control points to reshape the curve</div>
        </div>

        <!-- A* PATHFINDING -->
        <div id="pathfinding" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üó∫Ô∏è A* Pathfinding</h2>

            <div class="concept-box">
                <h4>What is A* Pathfinding?</h4>
                <p>A* (pronounced "A-star") finds the shortest path from start to goal, avoiding obstacles. It's used in:</p>
                <ul>
                    <li>Strategy games (RTS units finding paths)</li>
                    <li>RPGs (characters navigating to targets)</li>
                    <li>Tower defense (enemy pathing)</li>
                </ul>
                <p><strong>How it works:</strong></p>
                <ol>
                    <li>Start at the beginning node</li>
                    <li>Explore neighboring nodes</li>
                    <li>Pick the node with lowest cost (distance + estimated distance to goal)</li>
                    <li>Repeat until goal is reached</li>
                </ol>
                <div class="formula">
                    f(n) = g(n) + h(n)
                </div>
                <p>Where:</p>
                <ul>
                    <li><code>g(n)</code> = cost from start to current node</li>
                    <li><code>h(n)</code> = estimated cost from current to goal (heuristic)</li>
                    <li><code>f(n)</code> = total estimated cost</li>
                </ul>
            </div>

            <details data-demo-id="astar" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: A* Implementation (Simplified)</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">Node</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
        <span class="keyword">this</span>.g = <span class="number">0</span>;  <span class="comment">// Cost from start</span>
        <span class="keyword">this</span>.h = <span class="number">0</span>;  <span class="comment">// Heuristic (estimated cost to goal)</span>
        <span class="keyword">this</span>.f = <span class="number">0</span>;  <span class="comment">// Total cost (g + h)</span>
        <span class="keyword">this</span>.parent = <span class="keyword">null</span>;
    }
}

<span class="keyword">function</span> <span class="function">astar</span>(start, goal, grid) {
    <span class="keyword">const</span> openSet = [start];
    <span class="keyword">const</span> closedSet = [];

    <span class="keyword">while</span> (openSet.length > <span class="number">0</span>) {
        <span class="comment">// Find node with lowest f score</span>
        <span class="keyword">let</span> current = openSet[<span class="number">0</span>];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i < openSet.length; i++) {
            <span class="keyword">if</span> (openSet[i].f < current.f) {
                current = openSet[i];
            }
        }

        <span class="comment">// Found the goal!</span>
        <span class="keyword">if</span> (current === goal) {
            <span class="keyword">return</span> <span class="function">reconstructPath</span>(current);
        }

        <span class="comment">// Move current from open to closed</span>
        openSet.<span class="function">splice</span>(openSet.<span class="function">indexOf</span>(current), <span class="number">1</span>);
        closedSet.<span class="function">push</span>(current);

        <span class="comment">// Check all neighbors</span>
        <span class="keyword">const</span> neighbors = <span class="function">getNeighbors</span>(current, grid);
        <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> neighbors) {
            <span class="keyword">if</span> (closedSet.<span class="function">includes</span>(neighbor)) <span class="keyword">continue</span>;

            <span class="keyword">const</span> tempG = current.g + <span class="number">1</span>;  <span class="comment">// Distance to neighbor</span>

            <span class="keyword">if</span> (!openSet.<span class="function">includes</span>(neighbor)) {
                openSet.<span class="function">push</span>(neighbor);
            } <span class="keyword">else</span> <span class="keyword">if</span> (tempG >= neighbor.g) {
                <span class="keyword">continue</span>;  <span class="comment">// Not a better path</span>
            }

            neighbor.g = tempG;
            neighbor.h = <span class="function">heuristic</span>(neighbor, goal);
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.parent = current;
        }
    }

    <span class="keyword">return</span> [];  <span class="comment">// No path found</span>
}

<span class="keyword">function</span> <span class="function">heuristic</span>(a, b) {
    <span class="comment">// Manhattan distance</span>
    <span class="keyword">return</span> Math.<span class="function">abs</span>(a.x - b.x) + Math.<span class="function">abs</span>(a.y - b.y);
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: A* Pathfinding</h3>
            <div class="diagram">
                <canvas id="astarDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSetStart">Set Start</button>
                <button id="btnSetGoal">Set Goal</button>
                <button id="btnAddWalls">Draw Walls</button>
                <button id="btnFindPath">Find Path</button>
                <button id="btnClearGrid">Clear Grid</button>
            </div>
            <div id="astarInfo" class="info-display">Click to place start/goal, drag to draw walls</div>

            <div class="thinking-prompt">
                <h4>ü§î Think About It:</h4>
                <p>A* is great for grid-based games. But what if your game doesn't use a grid? Try researching "navigation meshes" (navmeshes) for non-grid pathfinding!</p>
            </div>
        </div>

        <!-- FLOW FIELDS -->
        <div id="flow-fields" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üåä Flow Fields (Crowd Movement)</h2>

            <div class="concept-box">
                <h4>What are Flow Fields?</h4>
                <p>Flow fields enable hundreds or thousands of units to pathfind efficiently toward a goal. Instead of each unit calculating its own path, we create a "flow" map that shows every grid cell which direction to move.</p>
                <p><strong>Perfect for:</strong></p>
                <ul>
                    <li>RTS games with many units moving to same location</li>
                    <li>Tower defense with waves of enemies</li>
                    <li>Crowd simulations</li>
                    <li>Zombie hordes converging on player</li>
                </ul>
                <p><strong>How it works:</strong> Run pathfinding ONCE from the goal to create a vector field. Each unit simply follows the arrow in its current grid cell!</p>
            </div>

            <details data-demo-id="flowField" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Flow Field Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">FlowField</span> {
    <span class="keyword">constructor</span>(width, height, cellSize) {
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
        <span class="keyword">this</span>.cellSize = cellSize;
        <span class="keyword">this</span>.cols = Math.<span class="function">ceil</span>(width / cellSize);
        <span class="keyword">this</span>.rows = Math.<span class="function">ceil</span>(height / cellSize);

        <span class="comment">// Cost field: how difficult to traverse each cell</span>
        <span class="keyword">this</span>.costField = [];
        <span class="comment">// Integration field: distance to goal</span>
        <span class="keyword">this</span>.integrationField = [];
        <span class="comment">// Flow field: direction to move</span>
        <span class="keyword">this</span>.flowField = [];

        <span class="keyword">this</span>.<span class="function">initializeFields</span>();
    }

    <span class="function">initializeFields</span>() {
        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y < <span class="keyword">this</span>.rows; y++) {
            <span class="keyword">this</span>.costField[y] = [];
            <span class="keyword">this</span>.integrationField[y] = [];
            <span class="keyword">this</span>.flowField[y] = [];

            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x < <span class="keyword">this</span>.cols; x++) {
                <span class="keyword">this</span>.costField[y][x] = <span class="number">1</span>;  <span class="comment">// Default cost</span>
                <span class="keyword">this</span>.integrationField[y][x] = <span class="number">65535</span>;  <span class="comment">// Max value</span>
                <span class="keyword">this</span>.flowField[y][x] = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
            }
        }
    }

    <span class="function">setObstacle</span>(x, y) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.<span class="function">inBounds</span>(x, y)) {
            <span class="keyword">this</span>.costField[y][x] = <span class="number">255</span>;  <span class="comment">// Impassable</span>
        }
    }

    <span class="function">generateFlowField</span>(goalX, goalY) {
        <span class="comment">// Step 1: Create integration field (distance from goal)</span>
        <span class="keyword">this</span>.<span class="function">createIntegrationField</span>(goalX, goalY);

        <span class="comment">// Step 2: Create flow field (direction to move)</span>
        <span class="keyword">this</span>.<span class="function">createFlowField</span>();
    }

    <span class="function">createIntegrationField</span>(goalX, goalY) {
        <span class="comment">// Reset integration field</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y < <span class="keyword">this</span>.rows; y++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x < <span class="keyword">this</span>.cols; x++) {
                <span class="keyword">this</span>.integrationField[y][x] = <span class="number">65535</span>;
            }
        }

        <span class="comment">// Goal has distance 0</span>
        <span class="keyword">this</span>.integrationField[goalY][goalX] = <span class="number">0</span>;

        <span class="comment">// Dijkstra's algorithm from goal</span>
        <span class="keyword">const</span> openList = [{x: goalX, y: goalY}];

        <span class="keyword">while</span> (openList.length > <span class="number">0</span>) {
            <span class="keyword">const</span> current = openList.<span class="function">shift</span>();
            <span class="keyword">const</span> neighbors = <span class="keyword">this</span>.<span class="function">getNeighbors</span>(current.x, current.y);

            <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> neighbors) {
                <span class="keyword">const</span> cost = <span class="keyword">this</span>.costField[neighbor.y][neighbor.x];
                <span class="keyword">if</span> (cost === <span class="number">255</span>) <span class="keyword">continue</span>;  <span class="comment">// Impassable</span>

                <span class="keyword">const</span> newCost = <span class="keyword">this</span>.integrationField[current.y][current.x] + cost;

                <span class="keyword">if</span> (newCost < <span class="keyword">this</span>.integrationField[neighbor.y][neighbor.x]) {
                    <span class="keyword">this</span>.integrationField[neighbor.y][neighbor.x] = newCost;
                    openList.<span class="function">push</span>(neighbor);
                }
            }
        }
    }

    <span class="function">createFlowField</span>() {
        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y < <span class="keyword">this</span>.rows; y++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x < <span class="keyword">this</span>.cols; x++) {
                <span class="keyword">if</span> (<span class="keyword">this</span>.costField[y][x] === <span class="number">255</span>) <span class="keyword">continue</span>;

                <span class="comment">// Find neighbor with lowest integration value</span>
                <span class="keyword">let</span> lowestCost = <span class="keyword">this</span>.integrationField[y][x];
                <span class="keyword">let</span> bestDirection = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);

                <span class="keyword">const</span> neighbors = <span class="keyword">this</span>.<span class="function">getNeighbors</span>(x, y);
                <span class="keyword">for</span> (<span class="keyword">const</span> neighbor <span class="keyword">of</span> neighbors) {
                    <span class="keyword">const</span> cost = <span class="keyword">this</span>.integrationField[neighbor.y][neighbor.x];
                    <span class="keyword">if</span> (cost < lowestCost) {
                        lowestCost = cost;
                        bestDirection = <span class="keyword">new</span> <span class="function">Vector2D</span>(
                            neighbor.x - x,
                            neighbor.y - y
                        ).<span class="function">normalize</span>();
                    }
                }

                <span class="keyword">this</span>.flowField[y][x] = bestDirection;
            }
        }
    }

    <span class="function">getFlowDirection</span>(worldX, worldY) {
        <span class="keyword">const</span> x = Math.<span class="function">floor</span>(worldX / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> y = Math.<span class="function">floor</span>(worldY / <span class="keyword">this</span>.cellSize);

        <span class="keyword">if</span> (<span class="keyword">this</span>.<span class="function">inBounds</span>(x, y)) {
            <span class="keyword">return</span> <span class="keyword">this</span>.flowField[y][x];
        }

        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
    }

    <span class="function">getNeighbors</span>(x, y) {
        <span class="keyword">const</span> neighbors = [];
        <span class="keyword">const</span> directions = [
            {x: <span class="number">1</span>, y: <span class="number">0</span>}, {x: -<span class="number">1</span>, y: <span class="number">0</span>},
            {x: <span class="number">0</span>, y: <span class="number">1</span>}, {x: <span class="number">0</span>, y: -<span class="number">1</span>}
        ];

        <span class="keyword">for</span> (<span class="keyword">const</span> dir <span class="keyword">of</span> directions) {
            <span class="keyword">const</span> nx = x + dir.x;
            <span class="keyword">const</span> ny = y + dir.y;
            <span class="keyword">if</span> (<span class="keyword">this</span>.<span class="function">inBounds</span>(nx, ny)) {
                neighbors.<span class="function">push</span>({x: nx, y: ny});
            }
        }

        <span class="keyword">return</span> neighbors;
    }

    <span class="function">inBounds</span>(x, y) {
        <span class="keyword">return</span> x >= <span class="number">0</span> && x < <span class="keyword">this</span>.cols && y >= <span class="number">0</span> && y < <span class="keyword">this</span>.rows;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using Flow Fields:</h4>
                    <pre><code><span class="comment">// Create flow field</span>
<span class="keyword">const</span> flowField = <span class="keyword">new</span> <span class="function">FlowField</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="number">20</span>);

<span class="comment">// Add obstacles</span>
flowField.<span class="function">setObstacle</span>(<span class="number">10</span>, <span class="number">10</span>);
flowField.<span class="function">setObstacle</span>(<span class="number">10</span>, <span class="number">11</span>);

<span class="comment">// Generate field toward goal</span>
flowField.<span class="function">generateFlowField</span>(<span class="number">30</span>, <span class="number">20</span>);

<span class="comment">// Each unit follows the flow</span>
units.<span class="function">forEach</span>(unit => {
    <span class="keyword">const</span> direction = flowField.<span class="function">getFlowDirection</span>(unit.x, unit.y);
    unit.velocity = direction.<span class="function">multiply</span>(unit.maxSpeed);
    unit.<span class="function">update</span>();
});</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Flow Field Visualization</h3>
            <div class="diagram">
                <canvas id="flowFieldDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSetGoalFlow">Set Goal</button>
                <button id="btnDrawObstacles">Draw Obstacles</button>
                <button id="btnSpawnUnits">Spawn 50 Units</button>
                <button id="btnClearFlowField">Clear All</button>
                <button id="btnToggleArrows">Toggle Arrows</button>
            </div>
            <div id="flowFieldInfo" class="info-display">Click to set goal, drag to draw obstacles, then spawn units</div>

            <div class="key-point">
                <strong>üí° Performance:</strong> Flow fields are calculated once per goal change. 1000 units following a flow field is just as fast as 10 units! Compare this to A* where each unit needs its own path.
            </div>
        </div>

        <!-- STATE MACHINES -->
        <div id="state-machines" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîÑ State Machines</h2>

            <div class="concept-box">
                <h4>What are State Machines?</h4>
                <p>State machines help manage complex behavior by breaking it into simple states. An entity can only be in one state at a time, and transitions between states based on conditions.</p>
                <p><strong>Example - Enemy AI States:</strong></p>
                <ul>
                    <li><strong>Patrol:</strong> Walk around until player is spotted</li>
                    <li><strong>Chase:</strong> Run toward player</li>
                    <li><strong>Attack:</strong> When close enough, attack</li>
                    <li><strong>Flee:</strong> If health is low, run away</li>
                </ul>
            </div>

            <details data-demo-id="state" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: State Machine Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">State</span> {
    <span class="function">enter</span>(entity) {}   <span class="comment">// Called when entering this state</span>
    <span class="function">update</span>(entity) {}  <span class="comment">// Called every frame</span>
    <span class="function">exit</span>(entity) {}    <span class="comment">// Called when leaving this state</span>
}

<span class="keyword">class</span> <span class="function">PatrolState</span> <span class="keyword">extends</span> <span class="function">State</span> {
    <span class="function">enter</span>(entity) {
        entity.speed = <span class="number">2</span>;
        entity.color = <span class="string">'#66bb6a'</span>;
    }

    <span class="function">update</span>(entity) {
        <span class="comment">// Walk around randomly</span>
        <span class="keyword">if</span> (Math.<span class="function">random</span>() < <span class="number">0.02</span>) {
            entity.direction = Vector2D.<span class="function">random</span>(<span class="number">1</span>);
        }

        <span class="comment">// Check if player is nearby</span>
        <span class="keyword">const</span> distToPlayer = entity.position.<span class="function">distance</span>(player.position);
        <span class="keyword">if</span> (distToPlayer < <span class="number">150</span>) {
            entity.<span class="function">setState</span>(<span class="keyword">new</span> <span class="function">ChaseState</span>());
        }
    }
}

<span class="keyword">class</span> <span class="function">ChaseState</span> <span class="keyword">extends</span> <span class="function">State</span> {
    <span class="function">enter</span>(entity) {
        entity.speed = <span class="number">4</span>;
        entity.color = <span class="string">'#ffa726'</span>;
    }

    <span class="function">update</span>(entity) {
        <span class="comment">// Chase the player</span>
        entity.direction = player.position.<span class="function">subtract</span>(entity.position).<span class="function">normalize</span>();

        <span class="keyword">const</span> distToPlayer = entity.position.<span class="function">distance</span>(player.position);

        <span class="comment">// Close enough to attack?</span>
        <span class="keyword">if</span> (distToPlayer < <span class="number">50</span>) {
            entity.<span class="function">setState</span>(<span class="keyword">new</span> <span class="function">AttackState</span>());
        }
        <span class="comment">// Lost sight of player?</span>
        <span class="keyword">else</span> <span class="keyword">if</span> (distToPlayer > <span class="number">300</span>) {
            entity.<span class="function">setState</span>(<span class="keyword">new</span> <span class="function">PatrolState</span>());
        }
    }
}

<span class="keyword">class</span> <span class="function">Entity</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.currentState = <span class="keyword">new</span> <span class="function">PatrolState</span>();
        <span class="keyword">this</span>.currentState.<span class="function">enter</span>(<span class="keyword">this</span>);
    }

    <span class="function">setState</span>(newState) {
        <span class="keyword">this</span>.currentState.<span class="function">exit</span>(<span class="keyword">this</span>);
        <span class="keyword">this</span>.currentState = newState;
        <span class="keyword">this</span>.currentState.<span class="function">enter</span>(<span class="keyword">this</span>);
    }

    <span class="function">update</span>() {
        <span class="keyword">this</span>.currentState.<span class="function">update</span>(<span class="keyword">this</span>);
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: State Machine AI</h3>
            <div class="diagram">
                <canvas id="stateDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddEnemy">Add Enemy</button>
                <button id="btnResetStates">Reset</button>
            </div>
            <div id="stateInfo" class="info-display">Use WASD to move. Watch enemies change states!</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: More Complex States</h4>
                <p>Try adding these states:</p>
                <ul>
                    <li><strong>Investigate:</strong> When player was seen but lost, search the area</li>
                    <li><strong>Call for Help:</strong> Alert nearby allies when player is spotted</li>
                    <li><strong>Celebrate:</strong> Victory dance when player is defeated</li>
                </ul>
            </div>
        </div>

        <!-- BEHAVIOR TREES -->
        <div id="behavior-trees" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üå≥ Behavior Trees (Advanced AI)</h2>

            <div class="concept-box">
                <h4>What are Behavior Trees?</h4>
                <p>Behavior Trees are a more flexible alternative to State Machines for AI decision-making. They organize behaviors into a tree structure that's evaluated from top to bottom.</p>
                <p><strong>Why use Behavior Trees?</strong></p>
                <ul>
                    <li>More modular and reusable than state machines</li>
                    <li>Easier to visualize and debug</li>
                    <li>Can handle complex decision-making</li>
                    <li>Used in many AAA games (Halo, Sp</li>ore, etc.)</li>
                </ul>
                <p><strong>Node Types:</strong></p>
                <ul>
                    <li><strong>Composite Nodes:</strong> Have children, control flow
                        <ul>
                            <li><strong>Sequence:</strong> Run children until one fails (AND logic)</li>
                            <li><strong>Selector:</strong> Run children until one succeeds (OR logic)</li>
                        </ul>
                    </li>
                    <li><strong>Decorator Nodes:</strong> Modify behavior of child (Repeat, Invert, etc.)</li>
                    <li><strong>Leaf Nodes:</strong> Actions (Move, Attack) or Conditions (IsPlayerNear?)</li>
                </ul>
            </div>

            <details data-demo-id="behaviorTree" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Behavior Tree Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Base Node class</span>
<span class="keyword">class</span> <span class="function">BTNode</span> {
    <span class="comment">// Returns: SUCCESS, FAILURE, or RUNNING</span>
    <span class="function">execute</span>(agent) {
        <span class="keyword">return</span> <span class="string">'FAILURE'</span>;
    }
}

<span class="comment">// Sequence: Runs children until one fails</span>
<span class="keyword">class</span> <span class="function">Sequence</span> <span class="keyword">extends</span> <span class="function">BTNode</span> {
    <span class="keyword">constructor</span>(...children) {
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.children = children;
        <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
    }

    <span class="function">execute</span>(agent) {
        <span class="keyword">while</span> (<span class="keyword">this</span>.currentChild < <span class="keyword">this</span>.children.length) {
            <span class="keyword">const</span> result = <span class="keyword">this</span>.children[<span class="keyword">this</span>.currentChild].<span class="function">execute</span>(agent);

            <span class="keyword">if</span> (result === <span class="string">'FAILURE'</span>) {
                <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
                <span class="keyword">return</span> <span class="string">'FAILURE'</span>;
            }

            <span class="keyword">if</span> (result === <span class="string">'RUNNING'</span>) {
                <span class="keyword">return</span> <span class="string">'RUNNING'</span>;
            }

            <span class="keyword">this</span>.currentChild++;
        }

        <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
        <span class="keyword">return</span> <span class="string">'SUCCESS'</span>;
    }
}

<span class="comment">// Selector: Runs children until one succeeds</span>
<span class="keyword">class</span> <span class="function">Selector</span> <span class="keyword">extends</span> <span class="function">BTNode</span> {
    <span class="keyword">constructor</span>(...children) {
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.children = children;
        <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
    }

    <span class="function">execute</span>(agent) {
        <span class="keyword">while</span> (<span class="keyword">this</span>.currentChild < <span class="keyword">this</span>.children.length) {
            <span class="keyword">const</span> result = <span class="keyword">this</span>.children[<span class="keyword">this</span>.currentChild].<span class="function">execute</span>(agent);

            <span class="keyword">if</span> (result === <span class="string">'SUCCESS'</span>) {
                <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
                <span class="keyword">return</span> <span class="string">'SUCCESS'</span>;
            }

            <span class="keyword">if</span> (result === <span class="string">'RUNNING'</span>) {
                <span class="keyword">return</span> <span class="string">'RUNNING'</span>;
            }

            <span class="keyword">this</span>.currentChild++;
        }

        <span class="keyword">this</span>.currentChild = <span class="number">0</span>;
        <span class="keyword">return</span> <span class="string">'FAILURE'</span>;
    }
}

<span class="comment">// Condition Node: Checks a condition</span>
<span class="keyword">class</span> <span class="function">Condition</span> <span class="keyword">extends</span> <span class="function">BTNode</span> {
    <span class="keyword">constructor</span>(conditionFn) {
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.conditionFn = conditionFn;
    }

    <span class="function">execute</span>(agent) {
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">conditionFn</span>(agent) ? <span class="string">'SUCCESS'</span> : <span class="string">'FAILURE'</span>;
    }
}

<span class="comment">// Action Node: Performs an action</span>
<span class="keyword">class</span> <span class="function">Action</span> <span class="keyword">extends</span> <span class="function">BTNode</span> {
    <span class="keyword">constructor</span>(actionFn) {
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.actionFn = actionFn;
    }

    <span class="function">execute</span>(agent) {
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">actionFn</span>(agent);
    }
}

<span class="comment">// Decorator: Inverts result</span>
<span class="keyword">class</span> <span class="function">Inverter</span> <span class="keyword">extends</span> <span class="function">BTNode</span> {
    <span class="keyword">constructor</span>(child) {
        <span class="keyword">super</span>();
        <span class="keyword">this</span>.child = child;
    }

    <span class="function">execute</span>(agent) {
        <span class="keyword">const</span> result = <span class="keyword">this</span>.child.<span class="function">execute</span>(agent);
        <span class="keyword">if</span> (result === <span class="string">'SUCCESS'</span>) <span class="keyword">return</span> <span class="string">'FAILURE'</span>;
        <span class="keyword">if</span> (result === <span class="string">'FAILURE'</span>) <span class="keyword">return</span> <span class="string">'SUCCESS'</span>;
        <span class="keyword">return</span> result;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Enemy AI Behavior Tree</h4>
                    <pre><code><span class="comment">// Build behavior tree for enemy</span>
<span class="keyword">const</span> enemyBehavior = <span class="keyword">new</span> <span class="function">Selector</span>(
    <span class="comment">// Option 1: Attack if player is close</span>
    <span class="keyword">new</span> <span class="function">Sequence</span>(
        <span class="keyword">new</span> <span class="function">Condition</span>(agent => agent.<span class="function">isPlayerNear</span>()),
        <span class="keyword">new</span> <span class="function">Action</span>(agent => agent.<span class="function">attack</span>())
    ),

    <span class="comment">// Option 2: Chase if player is visible</span>
    <span class="keyword">new</span> <span class="function">Sequence</span>(
        <span class="keyword">new</span> <span class="function">Condition</span>(agent => agent.<span class="function">canSeePlayer</span>()),
        <span class="keyword">new</span> <span class="function">Action</span>(agent => agent.<span class="function">chasePlayer</span>())
    ),

    <span class="comment">// Option 3: Patrol if health is good</span>
    <span class="keyword">new</span> <span class="function">Sequence</span>(
        <span class="keyword">new</span> <span class="function">Condition</span>(agent => agent.health > <span class="number">50</span>),
        <span class="keyword">new</span> <span class="function">Action</span>(agent => agent.<span class="function">patrol</span>())
    ),

    <span class="comment">// Option 4: Flee if health is low (fallback)</span>
    <span class="keyword">new</span> <span class="function">Action</span>(agent => agent.<span class="function">flee</span>())
);

<span class="comment">// Run behavior tree each frame</span>
<span class="keyword">function</span> <span class="function">update</span>() {
    enemies.<span class="function">forEach</span>(enemy => {
        enemyBehavior.<span class="function">execute</span>(enemy);
    });
}</code></pre>
                </div>

                <div class="thinking-prompt">
                    <h4>üß† How it works:</h4>
                    <p>The Selector tries each option from top to bottom:</p>
                    <ol>
                        <li>Try to attack (only if player is near)</li>
                        <li>If that fails, try to chase (only if player is visible)</li>
                        <li>If that fails, try to patrol (only if health is good)</li>
                        <li>If everything else fails, flee!</li>
                    </ol>
                    <p>This creates intelligent, prioritized decision-making!</p>
                </div>
            </details>

            <h3>Interactive Demo: Behavior Tree Visualization</h3>
            <div class="diagram">
                <canvas id="behaviorTreeDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSpawnEnemy">Spawn Enemy</button>
                <button id="btnToggleTree">Show Tree</button>
                <button id="btnStepBehavior">Step Through</button>
                <button id="btnResetBehavior">Reset</button>
            </div>
            <div id="behaviorTreeInfo" class="info-display">Use WASD to move. Watch enemies make decisions!</div>

            <div class="key-point">
                <strong>üí° Behavior Trees vs State Machines:</strong> Use State Machines for simple, well-defined states (like player movement). Use Behavior Trees for complex AI decision-making where you need priorities and fallbacks!
            </div>
        </div>

        <!-- INVERSE KINEMATICS -->
        <div id="ik" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>ü¶æ Inverse Kinematics</h2>

            <div class="concept-box">
                <h4>What is Inverse Kinematics (IK)?</h4>
                <p>IK is the technique of calculating joint angles needed to reach a target position. It's the opposite of Forward Kinematics (FK).</p>
                <ul>
                    <li><strong>Forward Kinematics:</strong> "Given these joint angles, where does the hand end up?"</li>
                    <li><strong>Inverse Kinematics:</strong> "To reach this position, what joint angles do I need?"</li>
                </ul>
                <p><strong>Common Uses:</strong></p>
                <ul>
                    <li>Character arms reaching for objects</li>
                    <li>Legs adapting to terrain</li>
                    <li>Robotic arm simulations</li>
                    <li>Procedural animation</li>
                </ul>
            </div>

            <details data-demo-id="ik" data-deps="vector2d,clearCanvas">
                <summary>üìù Click to see: Two-Joint IK Implementation (Arm/Leg)</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">TwoJointIK</span> {
    <span class="keyword">constructor</span>(baseX, baseY, length1, length2) {
        <span class="keyword">this</span>.base = <span class="keyword">new</span> <span class="function">Vector2D</span>(baseX, baseY);
        <span class="keyword">this</span>.length1 = length1;  <span class="comment">// Upper arm/leg length</span>
        <span class="keyword">this</span>.length2 = length2;  <span class="comment">// Lower arm/leg length</span>
        <span class="keyword">this</span>.joint = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.end = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
    }

    <span class="function">solve</span>(targetX, targetY) {
        <span class="keyword">const</span> target = <span class="keyword">new</span> <span class="function">Vector2D</span>(targetX, targetY);
        <span class="keyword">const</span> toTarget = target.<span class="function">subtract</span>(<span class="keyword">this</span>.base);
        <span class="keyword">const</span> distance = toTarget.<span class="function">length</span>();

        <span class="comment">// Maximum reach</span>
        <span class="keyword">const</span> maxReach = <span class="keyword">this</span>.length1 + <span class="keyword">this</span>.length2;

        <span class="comment">// Target is out of reach - stretch toward it</span>
        <span class="keyword">if</span> (distance >= maxReach) {
            <span class="keyword">const</span> direction = toTarget.<span class="function">normalize</span>();
            <span class="keyword">this</span>.joint = <span class="keyword">this</span>.base.<span class="function">add</span>(direction.<span class="function">multiply</span>(<span class="keyword">this</span>.length1));
            <span class="keyword">this</span>.end = <span class="keyword">this</span>.joint.<span class="function">add</span>(direction.<span class="function">multiply</span>(<span class="keyword">this</span>.length2));
            <span class="keyword">return</span>;
        }

        <span class="comment">// Target is too close</span>
        <span class="keyword">if</span> (distance < Math.<span class="function">abs</span>(<span class="keyword">this</span>.length1 - <span class="keyword">this</span>.length2)) {
            <span class="keyword">const</span> direction = toTarget.<span class="function">normalize</span>();
            <span class="keyword">this</span>.joint = <span class="keyword">this</span>.base.<span class="function">add</span>(direction.<span class="function">multiply</span>(<span class="keyword">this</span>.length1));
            <span class="keyword">this</span>.end = target;
            <span class="keyword">return</span>;
        }

        <span class="comment">// Use law of cosines to find angles</span>
        <span class="keyword">const</span> a = <span class="keyword">this</span>.length1;
        <span class="keyword">const</span> b = <span class="keyword">this</span>.length2;
        <span class="keyword">const</span> c = distance;

        <span class="comment">// Angle at the base</span>
        <span class="keyword">const</span> angleToTarget = Math.<span class="function">atan2</span>(toTarget.y, toTarget.x);
        <span class="keyword">const</span> cosAngle1 = (a * a + c * c - b * b) / (<span class="number">2</span> * a * c);
        <span class="keyword">const</span> angle1 = Math.<span class="function">acos</span>(<span class="function">clamp</span>(cosAngle1, -<span class="number">1</span>, <span class="number">1</span>));

        <span class="comment">// Calculate joint position</span>
        <span class="keyword">const</span> jointAngle = angleToTarget + angle1;
        <span class="keyword">this</span>.joint.x = <span class="keyword">this</span>.base.x + a * Math.<span class="function">cos</span>(jointAngle);
        <span class="keyword">this</span>.joint.y = <span class="keyword">this</span>.base.y + a * Math.<span class="function">sin</span>(jointAngle);

        <span class="comment">// End effector is the target</span>
        <span class="keyword">this</span>.end = target.<span class="function">copy</span>();
    }

    <span class="function">draw</span>(ctx) {
        <span class="comment">// Draw bones</span>
        ctx.strokeStyle = <span class="string">'#42a5f5'</span>;
        ctx.lineWidth = <span class="number">8</span>;
        ctx.beginPath();
        ctx.<span class="function">moveTo</span>(<span class="keyword">this</span>.base.x, <span class="keyword">this</span>.base.y);
        ctx.<span class="function">lineTo</span>(<span class="keyword">this</span>.joint.x, <span class="keyword">this</span>.joint.y);
        ctx.<span class="function">lineTo</span>(<span class="keyword">this</span>.end.x, <span class="keyword">this</span>.end.y);
        ctx.<span class="function">stroke</span>();

        <span class="comment">// Draw joints</span>
        [<span class="keyword">this</span>.base, <span class="keyword">this</span>.joint, <span class="keyword">this</span>.end].<span class="function">forEach</span>((joint, i) => {
            ctx.fillStyle = i === <span class="number">2</span> ? <span class="string">'#f44336'</span> : <span class="string">'#66bb6a'</span>;
            ctx.beginPath();
            ctx.<span class="function">arc</span>(joint.x, joint.y, <span class="number">10</span>, <span class="number">0</span>, Math.PI * <span class="number">2</span>);
            ctx.<span class="function">fill</span>();
        });
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Inverse Kinematics</h3>
            <div class="diagram">
                <canvas id="ikDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddArm">Add Arm</button>
                <button id="btnToggleConstraints">Toggle Constraints</button>
                <button id="btnResetIK">Reset</button>
            </div>
            <div id="ikInfo" class="info-display">Move your mouse - watch the arms reach for it!</div>

            <div class="thinking-prompt">
                <h4>ü§î Think About It:</h4>
                <p>For more than 2 joints (like a full spine or tentacle), you'd use an iterative algorithm like FABRIK (Forward And Backward Reaching Inverse Kinematics). It's more complex but handles any number of joints!</p>
            </div>
        </div>

        <!-- SHADOW CASTING & VISION -->
        <div id="shadows" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üëÅÔ∏è Shadow Casting & Vision</h2>

            <div class="concept-box">
                <h4>What is Shadow Casting?</h4>
                <p>Shadow casting determines what areas are visible from a point of view and what's hidden in shadows. Essential for:</p>
                <ul>
                    <li>Stealth games (can enemies see the player?)</li>
                    <li>Fog of war in strategy games</li>
                    <li>Lighting and shadow systems</li>
                    <li>Line-of-sight for AI</li>
                </ul>
                <p><strong>Common Techniques:</strong></p>
                <ul>
                    <li><strong>Raycasting:</strong> Cast rays in all directions from light source</li>
                    <li><strong>Shadow Volumes:</strong> Project shapes away from light</li>
                    <li><strong>Visibility Polygons:</strong> Calculate the exact visible area</li>
                </ul>
            </div>

            <details data-demo-id="shadow" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Raycasting Shadow Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">ShadowCaster</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.walls = [];  <span class="comment">// Line segments that cast shadows</span>
    }

    <span class="function">addWall</span>(x1, y1, x2, y2) {
        <span class="keyword">this</span>.walls.<span class="function">push</span>({
            p1: <span class="keyword">new</span> <span class="function">Vector2D</span>(x1, y1),
            p2: <span class="keyword">new</span> <span class="function">Vector2D</span>(x2, y2)
        });
    }

    <span class="comment">// Get all unique angles to cast rays toward</span>
    <span class="function">getAngles</span>(source) {
        <span class="keyword">const</span> angles = [];

        <span class="keyword">for</span> (<span class="keyword">const</span> wall <span class="keyword">of</span> <span class="keyword">this</span>.walls) {
            <span class="comment">// Add angles to each endpoint</span>
            <span class="keyword">const</span> angle1 = Math.<span class="function">atan2</span>(wall.p1.y - source.y, wall.p1.x - source.x);
            <span class="keyword">const</span> angle2 = Math.<span class="function">atan2</span>(wall.p2.y - source.y, wall.p2.x - source.x);

            <span class="comment">// Add small offsets to catch edges</span>
            angles.<span class="function">push</span>(angle1 - <span class="number">0.0001</span>, angle1, angle1 + <span class="number">0.0001</span>);
            angles.<span class="function">push</span>(angle2 - <span class="number">0.0001</span>, angle2, angle2 + <span class="number">0.0001</span>);
        }

        <span class="keyword">return</span> angles;
    }

    <span class="comment">// Cast a ray and find closest intersection</span>
    <span class="function">castRay</span>(source, angle, maxDistance = <span class="number">1000</span>) {
        <span class="keyword">const</span> direction = <span class="keyword">new</span> <span class="function">Vector2D</span>(
            Math.<span class="function">cos</span>(angle),
            Math.<span class="function">sin</span>(angle)
        );

        <span class="keyword">const</span> rayEnd = source.<span class="function">add</span>(direction.<span class="function">multiply</span>(maxDistance));

        <span class="keyword">let</span> closestIntersection = rayEnd;
        <span class="keyword">let</span> closestDistance = maxDistance;

        <span class="keyword">for</span> (<span class="keyword">const</span> wall <span class="keyword">of</span> <span class="keyword">this</span>.walls) {
            <span class="keyword">const</span> intersection = <span class="function">lineIntersection</span>(
                source, rayEnd,
                wall.p1, wall.p2
            );

            <span class="keyword">if</span> (intersection) {
                <span class="keyword">const</span> dist = source.<span class="function">distance</span>(intersection);
                <span class="keyword">if</span> (dist < closestDistance) {
                    closestDistance = dist;
                    closestIntersection = intersection;
                }
            }
        }

        <span class="keyword">return</span> closestIntersection;
    }

    <span class="comment">// Calculate visible polygon</span>
    <span class="function">getVisibleArea</span>(source) {
        <span class="keyword">const</span> angles = <span class="keyword">this</span>.<span class="function">getAngles</span>(source);
        <span class="keyword">const</span> intersections = [];

        <span class="keyword">for</span> (<span class="keyword">const</span> angle <span class="keyword">of</span> angles) {
            <span class="keyword">const</span> point = <span class="keyword">this</span>.<span class="function">castRay</span>(source, angle);
            intersections.<span class="function">push</span>({
                point: point,
                angle: Math.<span class="function">atan2</span>(point.y - source.y, point.x - source.x)
            });
        }

        <span class="comment">// Sort by angle</span>
        intersections.<span class="function">sort</span>((a, b) => a.angle - b.angle);

        <span class="keyword">return</span> intersections.<span class="function">map</span>(i => i.point);
    }

    <span class="function">draw</span>(ctx, source) {
        <span class="keyword">const</span> visibleArea = <span class="keyword">this</span>.<span class="function">getVisibleArea</span>(source);

        <span class="comment">// Draw visible area</span>
        ctx.fillStyle = <span class="string">'rgba(255, 255, 100, 0.3)'</span>;
        ctx.beginPath();
        ctx.<span class="function">moveTo</span>(source.x, source.y);
        visibleArea.<span class="function">forEach</span>(p => ctx.<span class="function">lineTo</span>(p.x, p.y));
        ctx.<span class="function">closePath</span>();
        ctx.<span class="function">fill</span>();

        <span class="comment">// Draw light source</span>
        ctx.fillStyle = <span class="string">'#ffeb3b'</span>;
        ctx.beginPath();
        ctx.<span class="function">arc</span>(source.x, source.y, <span class="number">8</span>, <span class="number">0</span>, Math.PI * <span class="number">2</span>);
        ctx.<span class="function">fill</span>();
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Shadow Casting</h3>
            <div class="diagram">
                <canvas id="shadowDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddObstacle">Add Obstacle</button>
                <button id="btnClearObstacles">Clear Obstacles</button>
                <button id="btnToggleRays">Toggle Rays</button>
            </div>
            <div id="shadowInfo" class="info-display">Move your mouse to cast light and shadows</div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Field of View</h4>
                <p>Modify the shadow caster to only show a limited field of view (like 90 degrees). This is great for stealth games where enemies have cone-shaped vision!</p>
            </div>
        </div>

        <!-- SPATIAL HASHING -->
        <div id="spatial-hash" class="section">
            <span class="level-indicator level-advanced">ADVANCED</span>
            <h2>üîç Spatial Hashing (Optimization)</h2>

            <div class="concept-box">
                <h4>What is Spatial Hashing?</h4>
                <p>Spatial hashing is a technique to quickly find nearby objects without checking every object. It's simpler than QuadTrees but extremely effective for many scenarios!</p>
                <p><strong>How it works:</strong> Divide the world into a grid. Each object goes into one or more grid cells. To find nearby objects, only check the cells near you!</p>
                <p><strong>Perfect for:</strong></p>
                <ul>
                    <li>Collision detection in large worlds</li>
                    <li>Finding nearby enemies/items</li>
                    <li>Multiplayer games with many players</li>
                    <li>Bullet-to-enemy collision checking</li>
                </ul>
            </div>

            <details data-demo-id="spatialHash" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Spatial Hash Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">SpatialHash</span> {
    <span class="keyword">constructor</span>(cellSize) {
        <span class="keyword">this</span>.cellSize = cellSize;
        <span class="keyword">this</span>.cells = <span class="keyword">new</span> <span class="function">Map</span>();  <span class="comment">// Hash map of cell coordinates to objects</span>
    }

    <span class="comment">// Convert world position to cell key</span>
    <span class="function">getKey</span>(x, y) {
        <span class="keyword">const</span> cellX = Math.<span class="function">floor</span>(x / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> cellY = Math.<span class="function">floor</span>(y / <span class="keyword">this</span>.cellSize);
        <span class="keyword">return</span> `${cellX},${cellY}`;
    }

    <span class="comment">// Insert object into hash</span>
    <span class="function">insert</span>(object) {
        <span class="keyword">const</span> key = <span class="keyword">this</span>.<span class="function">getKey</span>(object.position.x, object.position.y);

        <span class="keyword">if</span> (!<span class="keyword">this</span>.cells.<span class="function">has</span>(key)) {
            <span class="keyword">this</span>.cells.<span class="function">set</span>(key, []);
        }

        <span class="keyword">this</span>.cells.<span class="function">get</span>(key).<span class="function">push</span>(object);
        object.cellKey = key;  <span class="comment">// Store for removal</span>
    }

    <span class="comment">// Remove object from hash</span>
    <span class="function">remove</span>(object) {
        <span class="keyword">if</span> (!object.cellKey) <span class="keyword">return</span>;

        <span class="keyword">const</span> cell = <span class="keyword">this</span>.cells.<span class="function">get</span>(object.cellKey);
        <span class="keyword">if</span> (cell) {
            <span class="keyword">const</span> index = cell.<span class="function">indexOf</span>(object);
            <span class="keyword">if</span> (index !== -<span class="number">1</span>) {
                cell.<span class="function">splice</span>(index, <span class="number">1</span>);
            }
        }

        object.cellKey = <span class="keyword">null</span>;
    }

    <span class="comment">// Update object position (remove from old cell, add to new)</span>
    <span class="function">update</span>(object) {
        <span class="keyword">const</span> newKey = <span class="keyword">this</span>.<span class="function">getKey</span>(object.position.x, object.position.y);

        <span class="comment">// Only update if cell changed</span>
        <span class="keyword">if</span> (object.cellKey !== newKey) {
            <span class="keyword">this</span>.<span class="function">remove</span>(object);
            <span class="keyword">this</span>.<span class="function">insert</span>(object);
        }
    }

    <span class="comment">// Get all objects in nearby cells</span>
    <span class="function">getNearby</span>(x, y, range = <span class="number">1</span>) {
        <span class="keyword">const</span> nearby = [];
        <span class="keyword">const</span> cellX = Math.<span class="function">floor</span>(x / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> cellY = Math.<span class="function">floor</span>(y / <span class="keyword">this</span>.cellSize);

        <span class="comment">// Check surrounding cells</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> dx = -range; dx <= range; dx++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> dy = -range; dy <= range; dy++) {
                <span class="keyword">const</span> key = `${cellX + dx},${cellY + dy}`;
                <span class="keyword">const</span> cell = <span class="keyword">this</span>.cells.<span class="function">get</span>(key);

                <span class="keyword">if</span> (cell) {
                    nearby.<span class="function">push</span>(...cell);
                }
            }
        }

        <span class="keyword">return</span> nearby;
    }

    <span class="comment">// Get objects in a rectangular area</span>
    <span class="function">queryRect</span>(x, y, width, height) {
        <span class="keyword">const</span> objects = <span class="keyword">new</span> <span class="function">Set</span>();

        <span class="keyword">const</span> startX = Math.<span class="function">floor</span>(x / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> startY = Math.<span class="function">floor</span>(y / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> endX = Math.<span class="function">ceil</span>((x + width) / <span class="keyword">this</span>.cellSize);
        <span class="keyword">const</span> endY = Math.<span class="function">ceil</span>((y + height) / <span class="keyword">this</span>.cellSize);

        <span class="keyword">for</span> (<span class="keyword">let</span> cx = startX; cx <= endX; cx++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> cy = startY; cy <= endY; cy++) {
                <span class="keyword">const</span> key = `${cx},${cy}`;
                <span class="keyword">const</span> cell = <span class="keyword">this</span>.cells.<span class="function">get</span>(key);

                <span class="keyword">if</span> (cell) {
                    cell.<span class="function">forEach</span>(obj => objects.<span class="function">add</span>(obj));
                }
            }
        }

        <span class="keyword">return</span> Array.<span class="function">from</span>(objects);
    }

    <span class="comment">// Clear all objects</span>
    <span class="function">clear</span>() {
        <span class="keyword">this</span>.cells.<span class="function">clear</span>();
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using Spatial Hash for Collision Detection:</h4>
                    <pre><code><span class="comment">// Create spatial hash with 50px cells</span>
<span class="keyword">const</span> spatialHash = <span class="keyword">new</span> <span class="function">SpatialHash</span>(<span class="number">50</span>);

<span class="comment">// Insert all game objects</span>
gameObjects.<span class="function">forEach</span>(obj => spatialHash.<span class="function">insert</span>(obj));

<span class="comment">// Each frame: update objects and check collisions</span>
<span class="keyword">function</span> <span class="function">update</span>() {
    gameObjects.<span class="function">forEach</span>(obj => {
        <span class="comment">// Move object</span>
        obj.<span class="function">update</span>();

        <span class="comment">// Update its cell in the hash</span>
        spatialHash.<span class="function">update</span>(obj);

        <span class="comment">// Check collisions only with nearby objects</span>
        <span class="keyword">const</span> nearby = spatialHash.<span class="function">getNearby</span>(
            obj.position.x,
            obj.position.y,
            <span class="number">1</span>  <span class="comment">// Check 1 cell in each direction</span>
        );

        nearby.<span class="function">forEach</span>(other => {
            <span class="keyword">if</span> (obj !== other && obj.<span class="function">collidesWith</span>(other)) {
                <span class="function">handleCollision</span>(obj, other);
            }
        });
    });
}

<span class="comment">// Example: Find all enemies near player</span>
<span class="keyword">const</span> nearbyEnemies = spatialHash
    .<span class="function">getNearby</span>(player.x, player.y, <span class="number">2</span>)
    .<span class="function">filter</span>(obj => obj.type === <span class="string">'enemy'</span>);</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Spatial Hash Visualization</h3>
            <div class="diagram">
                <canvas id="spatialHashDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAdd100">Add 100 Objects</button>
                <button id="btnToggleGrid">Toggle Grid</button>
                <button id="btnShowNearby">Show Nearby Query</button>
                <button id="btnClearHash">Clear All</button>
            </div>
            <div id="spatialHashInfo" class="info-display">Move mouse to query nearby objects. Watch collision checks!</div>

            <div class="key-point">
                <strong>üí° Performance Comparison:</strong>
                <ul>
                    <li><strong>Brute Force:</strong> 1000 objects = 1,000,000 checks</li>
                    <li><strong>Spatial Hash:</strong> 1000 objects = ~5,000 checks (200x faster!)</li>
                    <li><strong>Cell Size Tip:</strong> Make cells about 2x the size of your largest object for best performance</li>
                </ul>
            </div>
        </div>

        <!-- Next Steps -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Excellent Work!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You've mastered advanced techniques! Ready for expert-level optimization?
            </p>
            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <a href="intermediate.html" class="nav-button">‚Üê Review Core Systems</a>
                <a href="expert.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                    Continue to Expert ‚Üí
                </a>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="advanced-demos.js"></script>
</body>
</html>
