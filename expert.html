<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expert - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
    <!-- Prism.js Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üéÆ Expert Game Math</h1>
        <p class="subtitle">Optimization & Advanced Systems - Performance, procedural generation, and complex features</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="advanced.html" class="nav-button">‚Üê Advanced</a>
            <a href="expert.html" class="nav-button active">Expert</a>
            <a href="index.html" class="nav-button">Home</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#spatial">Spatial Partitioning & QuadTree</a></li>
                <li><a href="#pooling">Object Pooling</a></li>
                <li><a href="#procgen">Procedural Generation</a></li>
                <li><a href="#noise">Perlin Noise & Terrain Generation</a></li>
                <li><a href="#tilemap">Tilemap Systems</a></li>
                <li><a href="#ecs">Entity Component System (ECS)</a></li>
                <li><a href="#sound">Sound Propagation</a></li>
                <li><a href="#network">Network Interpolation</a></li>
                <li><a href="#delta-time">Delta Time & Fixed Timestep</a></li>
            </ul>
        </div>

        <!-- SPATIAL PARTITIONING & QUADTREE -->
        <div id="spatial" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üå≥ Spatial Partitioning & QuadTree</h2>

            <div class="concept-box">
                <h4>The Problem: Collision Detection is Slow!</h4>
                <p>Imagine you have 1000 objects in your game. To check collisions between all of them, you'd need to check every pair:</p>
                <div class="formula">
                    1000 √ó 1000 = 1,000,000 checks per frame!
                </div>
                <p>At 60 FPS, that's 60 million checks per second. Your game would crawl to a halt!</p>

                <h4>The Solution: Spatial Partitioning</h4>
                <p>Instead of checking every object against every other object, divide space into regions. Only check objects that are in the same region!</p>
                <p><strong>QuadTree</strong> recursively divides 2D space into four quadrants. Each quadrant can be further divided if it contains too many objects.</p>
            </div>

            <details data-demo-id="quadtree" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: QuadTree Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class QuadTree {
    constructor(boundary, capacity = 4) {
        this.boundary = boundary;  // Rectangle defining this quad
        this.capacity = capacity;  // Max objects before subdividing
        this.objects = [];
        this.divided = false;
    }

    subdivide() {
        const x = this.boundary.x;
        const y = this.boundary.y;
        const w = this.boundary.width / 2;
        const h = this.boundary.height / 2;

        this.northeast = new QuadTree({x: x + w, y: y, width: w, height: h}, this.capacity);
        this.northwest = new QuadTree({x: x, y: y, width: w, height: h}, this.capacity);
        this.southeast = new QuadTree({x: x + w, y: y + h, width: w, height: h}, this.capacity);
        this.southwest = new QuadTree({x: x, y: y + h, width: w, height: h}, this.capacity);

        this.divided = true;
    }

    insert(object) {
        // Check if object is in this boundary
        if (!this.contains(object)) {
            return false;
        }

        // If there's room, add it here
        if (this.objects.length < this.capacity) {
            this.objects.push(object);
            return true;
        }

        // Otherwise, subdivide and add to child
        if (!this.divided) {
            this.subdivide();
        }

        return this.northeast.insert(object) ||
               this.northwest.insert(object) ||
               this.southeast.insert(object) ||
               this.southwest.insert(object);
    }

    query(range, found = []) {
        // Check if range intersects this quad's boundary
        if (!this.intersects(range)) {
            return found;
        }

        // Check objects in this quad
        for (const obj of this.objects) {
            if (rangeContains(range, obj)) {
                found.push(obj);
            }
        }

        // Recursively search children
        if (this.divided) {
            this.northeast.query(range, found);
            this.northwest.query(range, found);
            this.southeast.query(range, found);
            this.southwest.query(range, found);
        }

        return found;
    }

    contains(object) {
        return object.x >= this.boundary.x &&
               object.x < this.boundary.x + this.boundary.width &&
               object.y >= this.boundary.y &&
               object.y < this.boundary.y + this.boundary.height;
    }

    intersects(range) {
        return !(this.boundary.x > range.x + range.width ||
                 this.boundary.x + this.boundary.width < range.x ||
                 this.boundary.y > range.y + range.height ||
                 this.boundary.y + this.boundary.height < range.y);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using QuadTree for Collision Detection:</h4>
                    <pre><code class="language-javascript">// Create quadtree
const boundary = {x: 0, y: 0, width: 800, height: 600};
const quadtree = new QuadTree(boundary);

// Insert all objects
objects.forEach(obj => quadtree.insert(obj));

// For each object, only check nearby objects
objects.forEach(obj => {
    const range = {
        x: obj.x - obj.radius * 2,
        y: obj.y - obj.radius * 2,
        width: obj.radius * 4,
        height: obj.radius * 4
    };

    const nearby = quadtree.query(range);
    nearby.forEach(other => {
        if (obj !== other && obj.collidesWith(other)) {
            handleCollision(obj, other);
        }
    });
});</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: QuadTree Visualization</summary>
                <pre><code class="language-javascript">// ===================================
// QUADTREE - Complete Implementation
// ===================================

class QuadTree {
    constructor(boundary, capacity = 4) {
        this.boundary = boundary;  // { x, y, width, height }
        this.capacity = capacity;   // Max objects before subdividing
        this.objects = [];
        this.divided = false;
    }

    subdivide() {
        const { x, y, width, height } = this.boundary;
        const w = width / 2, h = height / 2;

        this.northeast = new QuadTree({x: x + w, y, width: w, height: h}, this.capacity);
        this.northwest = new QuadTree({x, y, width: w, height: h}, this.capacity);
        this.southeast = new QuadTree({x: x + w, y: y + h, width: w, height: h}, this.capacity);
        this.southwest = new QuadTree({x, y: y + h, width: w, height: h}, this.capacity);
        this.divided = true;
    }

    insert(point) {
        if (!this.contains(point)) return false;

        if (this.objects.length < this.capacity) {
            this.objects.push(point);
            return true;
        }

        if (!this.divided) this.subdivide();

        return this.northeast.insert(point) || this.northwest.insert(point) ||
               this.southeast.insert(point) || this.southwest.insert(point);
    }

    contains(point) {
        return point.x >= this.boundary.x &&
               point.x < this.boundary.x + this.boundary.width &&
               point.y >= this.boundary.y &&
               point.y < this.boundary.y + this.boundary.height;
    }

    // Query: Find all points within a range
    query(range, found = []) {
        if (!this.intersects(range)) return found;

        for (const point of this.objects) {
            if (this.rangeContains(range, point)) {
                found.push(point);
            }
        }

        if (this.divided) {
            this.northeast.query(range, found);
            this.northwest.query(range, found);
            this.southeast.query(range, found);
            this.southwest.query(range, found);
        }
        return found;
    }

    intersects(range) {
        return !(this.boundary.x > range.x + range.width ||
                 this.boundary.x + this.boundary.width < range.x ||
                 this.boundary.y > range.y + range.height ||
                 this.boundary.y + this.boundary.height < range.y);
    }

    draw(ctx) {
        ctx.strokeStyle = '#2a2f4a';
        ctx.strokeRect(this.boundary.x, this.boundary.y,
                       this.boundary.width, this.boundary.height);
        if (this.divided) {
            this.northeast.draw(ctx);
            this.northwest.draw(ctx);
            this.southeast.draw(ctx);
            this.southwest.draw(ctx);
        }
    }
}

// Usage
const points = [];
let mousePos = new Vector2D(400, 300);
let showTree = true;

// Add points on button click
document.getElementById('btnAddMany').addEventListener('click', () => {
    for (let i = 0; i < 100; i++) {
        points.push(new Vector2D(randomFloat(0, canvas.width), randomFloat(0, canvas.height)));
    }
});

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    // Rebuild tree each frame (for moving objects)
    const boundary = {x: 0, y: 0, width: canvas.width, height: canvas.height};
    const quadtree = new QuadTree(boundary);
    points.forEach(p => quadtree.insert(p));

    if (showTree) quadtree.draw(ctx);

    // Query area around mouse
    const queryRange = {
        x: mousePos.x - 75, y: mousePos.y - 75, width: 150, height: 150
    };
    const found = quadtree.query(queryRange);

    // Draw query range
    ctx.strokeStyle = '#4fc3f7';
    ctx.strokeRect(queryRange.x, queryRange.y, queryRange.width, queryRange.height);

    // Draw points (highlight found ones)
    points.forEach(p => {
        ctx.fillStyle = found.includes(p) ? '#ffa726' : '#66bb6a';
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
    });

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: QuadTree Visualization</h3>
            <div class="diagram">
                <canvas id="quadtreeDemo" width="800" height="600"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddMany">Add 100 Objects</button>
                <button id="btnToggleTree">Toggle Tree Visualization</button>
                <button id="btnClearQuad">Clear All</button>
            </div>
            <div id="quadInfo" class="info-display">Move mouse to query nearby objects</div>

            <div class="key-point">
                <strong>üí° Performance Impact:</strong> With QuadTree, 1000 objects might only require ~5,000 checks instead of 1,000,000! That's a 200x speedup!
            </div>
        </div>

        <!-- OBJECT POOLING -->
        <div id="pooling" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>‚ôªÔ∏è Object Pooling</h2>

            <div class="concept-box">
                <h4>The Problem: Creating Objects is Slow</h4>
                <p>In games with lots of bullets, particles, or enemies, constantly creating and destroying objects causes:</p>
                <ul>
                    <li>Memory allocation overhead</li>
                    <li>Garbage collection pauses (frame drops!)</li>
                    <li>Slower performance</li>
                </ul>

                <h4>The Solution: Object Pooling</h4>
                <p>Instead of creating/destroying objects, reuse them! Create a "pool" of objects at startup, then activate/deactivate them as needed.</p>
            </div>

            <details data-demo-id="pooling" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Object Pool Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;  // Function to create new objects
        this.resetFn = resetFn;    // Function to reset objects for reuse
        this.pool = [];
        this.active = [];

        // Pre-create objects
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }

    get(...args) {
        let object;

        if (this.pool.length > 0) {
            // Reuse from pool
            object = this.pool.pop();
        } else {
            // Pool is empty, create new
            object = this.createFn();
        }

        // Reset and activate
        this.resetFn(object, ...args);
        this.active.push(object);

        return object;
    }

    release(object) {
        // Remove from active
        const index = this.active.indexOf(object);
        if (index !== -1) {
            this.active.splice(index, 1);
        }

        // Return to pool
        this.pool.push(object);
    }

    update() {
        // Update all active objects
        for (let i = this.active.length - 1; i >= 0; i--) {
            const obj = this.active[i];

            // Update returns false when object should be released
            if (!obj.update()) {
                this.release(obj);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Bullet Pool</h4>
                    <pre><code class="language-javascript">// Create bullet pool
const bulletPool = new ObjectPool(
    // Create function
    () => ({
        position: new Vector2D(0, 0),
        velocity: new Vector2D(0, 0),
        active: false,
        update() {
            this.position.add(this.velocity);
            // Return false if out of bounds
            return this.position.x >= 0 && this.position.x <= 800;
        }
    }),
    // Reset function
    (bullet, x, y, vx, vy) => {
        bullet.position.set(x, y);
        bullet.velocity.set(vx, vy);
        bullet.active = true;
    }
);

// Spawn a bullet (no garbage creation!)
const bullet = bulletPool.get(playerX, playerY, 10, 0);

// Update all active bullets
bulletPool.update();</code></pre>
                </div>
            </details>

            <details class="code-block">
                <summary>üìñ Complete Code: Object Pooling</summary>
                <pre><code class="language-javascript">// ===================================
// OBJECT POOLING - Complete Implementation
// ===================================

class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;    // Function to create new objects
        this.resetFn = resetFn;      // Function to reset objects for reuse
        this.pool = [];              // Available (inactive) objects
        this.active = [];            // Currently in-use objects

        // Pre-populate pool
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.createFn());
        }
    }

    // Get object from pool (or create if empty)
    get(...args) {
        let object;
        if (this.pool.length > 0) {
            object = this.pool.pop();  // Reuse existing
        } else {
            object = this.createFn();  // Create new if needed
        }

        this.resetFn(object, ...args);  // Initialize for use
        this.active.push(object);
        return object;
    }

    // Return object to pool
    release(object) {
        const index = this.active.indexOf(object);
        if (index !== -1) {
            this.active.splice(index, 1);
        }
        this.pool.push(object);  // Ready for reuse
    }

    // Update all active objects, release dead ones
    update() {
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (!this.active[i].update()) {
                this.release(this.active[i]);
            }
        }
    }
}

// Usage: Particle pool
const particlePool = new ObjectPool(
    // Create function
    () => ({
        position: new Vector2D(0, 0),
        velocity: new Vector2D(0, 0),
        life: 1.0,
        update() {
            this.position.add(this.velocity);
            this.life -= 0.01;
            return this.life > 0;  // Return false when dead
        }
    }),
    // Reset function
    (particle, x, y) => {
        particle.position.set(x, y);
        particle.velocity = Vector2D.random(randomFloat(2, 5));
        particle.life = 1.0;
    }
);

// Spawn particles on click
canvas.addEventListener('click', (e) => {
    for (let i = 0; i < 10; i++) {
        particlePool.get(e.clientX, e.clientY);
    }
});

function animate() {
    clearCanvas(ctx, canvas.width, canvas.height);

    particlePool.update();

    particlePool.active.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = '#4fc3f7';
        ctx.arc(p.position.x, p.position.y, 6, 0, Math.PI * 2);
        ctx.fill();
    });

    ctx.globalAlpha = 1;
    info.textContent = `Active: ${particlePool.active.length} | Pool: ${particlePool.pool.length}`;

    requestAnimationFrame(animate);
}

animate();</code></pre>
            </details>

            <h3>Interactive Demo: Object Pooling</h3>
            <div class="diagram">
                <canvas id="poolingDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnWithPool">With Pooling</button>
                <button id="btnWithoutPool">Without Pooling</button>
                <button id="btnSpawnMany">Spawn 100 Objects</button>
            </div>
            <div id="poolInfo" class="info-display">Compare performance with and without object pooling</div>
        </div>

        <!-- PROCEDURAL GENERATION -->
        <div id="procgen" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üé≤ Procedural Generation</h2>

            <div class="concept-box">
                <h4>What is Procedural Generation?</h4>
                <p>Creating game content algorithmically instead of manually. Used for:</p>
                <ul>
                    <li>Terrain and landscapes</li>
                    <li>Dungeons and levels</li>
                    <li>Trees and vegetation</li>
                    <li>Textures and patterns</li>
                </ul>
                <p><strong>Perlin Noise</strong> creates smooth, natural-looking randomness - perfect for terrain!</p>
            </div>

            <details data-demo-id="noise" data-deps="clearCanvas">
                <summary>üìù Click to see: Simple Noise Function</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Simplified Perlin-like noise
class NoiseGenerator {
    constructor(seed = 0) {
        this.seed = seed;
    }

    // Simple hash function for pseudo-random values
    hash(x, y) {
        let h = this.seed + x * 374761393 + y * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return (h ^ (h >> 16)) / 2147483648 + 0.5;
    }

    // Smooth interpolation
    smoothstep(t) {
        return t * t * (3 - 2 * t);
    }

    // 2D noise function
    noise(x, y) {
        const xi = Math.floor(x);
        const yi = Math.floor(y);
        const xf = x - xi;
        const yf = y - yi;

        // Get corner values
        const n00 = this.hash(xi, yi);
        const n10 = this.hash(xi + 1, yi);
        const n01 = this.hash(xi, yi + 1);
        const n11 = this.hash(xi + 1, yi + 1);

        // Smooth interpolation
        const sx = this.smoothstep(xf);
        const sy = this.smoothstep(yf);

        const nx0 = lerp(n00, n10, sx);
        const nx1 = lerp(n01, n11, sx);

        return lerp(nx0, nx1, sy);
    }

    // Multi-octave noise (more detail)
    fractalNoise(x, y, octaves = 4) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1;
        let maxValue = 0;

        for (let i = 0; i < octaves; i++) {
            value += this.noise(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= 0.5;
            frequency *= 2;
        }

        return value / maxValue;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Procedural Terrain</h3>
            <div class="diagram">
                <canvas id="procgenDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnNewSeed">New Random Seed</button>
                <button id="btnTerrain">Generate Terrain</button>
                <button id="btnClouds">Generate Clouds</button>
                <button id="btnMarble">Generate Marble</button>
            </div>
            <div id="procgenInfo" class="info-display">Watch procedural generation create natural patterns</div>
        </div>

        <!-- PERLIN NOISE & TERRAIN GENERATION -->
        <div id="noise" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üèîÔ∏è Perlin Noise & Terrain Generation</h2>

            <div class="concept-box">
                <h4>What is Perlin Noise?</h4>
                <p>Perlin Noise creates smooth, natural-looking randomness. Unlike pure random values that jump erratically, Perlin Noise produces coherent, organic patterns perfect for:</p>
                <ul>
                    <li>Terrain height maps (mountains, valleys)</li>
                    <li>Cloud patterns</li>
                    <li>Wood/marble textures</li>
                    <li>Ocean waves</li>
                </ul>
            </div>

            <details data-demo-id="procgen" data-deps="clearCanvas">
                <summary>üìù Click to see: Perlin Noise Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class PerlinNoise {
    constructor() {
        // Permutation table (256 values, repeated)
        this.p = [];
        for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(Math.random() * 256);
        }
        // Duplicate for overflow
        this.p = this.p.concat(this.p);
    }

    fade(t) {
        // Smoothstep: 6t^5 - 15t^4 + 10t^3
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    lerp(a, b, t) {
        return a + t * (b - a);
    }

    grad(hash, x, y) {
        // Convert hash to gradient vector
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }

    noise(x, y) {
        // Find grid cell
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;

        // Relative position within cell
        x -= Math.floor(x);
        y -= Math.floor(y);

        // Fade curves
        const u = this.fade(x);
        const v = this.fade(y);

        // Hash coordinates of 4 cube corners
        const a = this.p[X] + Y;
        const aa = this.p[a];
        const ab = this.p[a + 1];
        const b = this.p[X + 1] + Y;
        const ba = this.p[b];
        const bb = this.p[b + 1];

        // Blend results from 4 corners
        return this.lerp(
            this.lerp(this.grad(aa, x, y), this.grad(ba, x - 1, y), u),
            this.lerp(this.grad(ab, x, y - 1), this.grad(bb, x - 1, y - 1), u),
            v
        );
    }

    // Octave noise - combine multiple frequencies
    octaveNoise(x, y, octaves = 4, persistence = 0.5) {
        let total = 0;
        let frequency = 1;
        let amplitude = 1;
        let maxValue = 0;

        for (let i = 0; i < octaves; i++) {
            total += this.noise(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= 2;
        }

        return total / maxValue;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Terrain Generation Example:</h4>
                    <pre><code class="language-javascript">class TerrainGenerator {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.noise = new PerlinNoise();
        this.heightmap = [];
    }

    generate(scale = 0.05) {
        for (let y = 0; y < this.height; y++) {
            this.heightmap[y] = [];
            for (let x = 0; x < this.width; x++) {
                // Get noise value (0-1)
                const value = this.noise.octaveNoise(
                    x * scale,
                    y * scale,
                    4,      // 4 octaves
                    0.5     // persistence
                );

                // Normalize to 0-1 range
                this.heightmap[y][x] = (value + 1) / 2;
            }
        }
    }

    getTileType(x, y) {
        const height = this.heightmap[y][x];

        // Map height to terrain types
        if (height < 0.3) return 'water';
        if (height < 0.4) return 'sand';
        if (height < 0.7) return 'grass';
        if (height < 0.9) return 'mountain';
        return 'snow';
    }

    getColor(tileType) {
        const colors = {
            water: '#4A90E2',
            sand: '#F5DEB3',
            grass: '#7EC850',
            mountain: '#8B7355',
            snow: '#FFFFFF'
        };
        return colors[tileType];
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Terrain Generation</h3>
            <div class="diagram">
                <canvas id="noiseDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnNewSeed">New Seed</button>
                <button id="btnIncreaseScale">Zoom Out</button>
                <button id="btnDecreaseScale">Zoom In</button>
                <button id="btnToggleHeight">Toggle Heightmap</button>
                <button id="btnToggleContours">Toggle Contours</button>
            </div>
            <div id="noiseInfo" class="info-display">Click to generate new terrain!</div>

            <div class="key-point">
                <strong>üí° Octaves Explained:</strong>
                <ul>
                    <li><strong>1 Octave:</strong> Smooth, rolling hills</li>
                    <li><strong>4 Octaves:</strong> Realistic terrain with detail</li>
                    <li><strong>8 Octaves:</strong> Highly detailed, rocky landscapes</li>
                </ul>
                More octaves = more detail, but slower generation!
            </div>
        </div>

        <!-- TILEMAP SYSTEMS -->
        <div id="tilemap" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üó∫Ô∏è Tilemap Systems</h2>

            <div class="concept-box">
                <h4>What are Tilemaps?</h4>
                <p>Tilemaps divide the game world into a grid of tiles. Each tile can be a different type (grass, wall, water, etc.). Benefits:</p>
                <ul>
                    <li>Memory efficient (reuse tile graphics)</li>
                    <li>Easy level editing</li>
                    <li>Simple collision detection</li>
                    <li>Fast rendering (only draw visible tiles)</li>
                </ul>
            </div>

            <details data-demo-id="tilemap" data-deps="clearCanvas">
                <summary>üìù Click to see: Tilemap Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class Tilemap {
    constructor(width, height, tileSize) {
        this.width = width;
        this.height = height;
        this.tileSize = tileSize;
        this.tiles = [];

        // Initialize empty map
        for (let y = 0; y < height; y++) {
            this.tiles[y] = [];
            for (let x = 0; x < width; x++) {
                this.tiles[y][x] = 0;  // 0 = empty
            }
        }
    }

    setTile(x, y, type) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            this.tiles[y][x] = type;
        }
    }

    getTile(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.tiles[y][x];
        }
        return -1;  // Out of bounds
    }

    // Convert world position to tile coordinates
    worldToTile(worldX, worldY) {
        return {
            x: Math.floor(worldX / this.tileSize),
            y: Math.floor(worldY / this.tileSize)
        };
    }

    // Check if tile is solid (for collision)
    isSolid(x, y) {
        const tile = this.getTile(x, y);
        return tile === 1;  // 1 = wall
    }

    render(ctx, camera) {
        // Only render visible tiles
        const startX = Math.max(0, Math.floor(camera.x / this.tileSize));
        const startY = Math.max(0, Math.floor(camera.y / this.tileSize));
        const endX = Math.min(this.width, startX + camera.width / this.tileSize + 1);
        const endY = Math.min(this.height, startY + camera.height / this.tileSize + 1);

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                const tile = this.tiles[y][x];
                if (tile !== 0) {
                    this.renderTile(ctx, x, y, tile, camera);
                }
            }
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Tilemap Editor</h3>
            <div class="diagram">
                <canvas id="tilemapDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnGrass">Paint Grass</button>
                <button id="btnWall">Paint Wall</button>
                <button id="btnWater">Paint Water</button>
                <button id="btnErase">Erase</button>
                <button id="btnClearTilemap">Clear Map</button>
            </div>
            <div id="tilemapInfo" class="info-display">Click and drag to paint tiles</div>
        </div>

        <!-- ENTITY COMPONENT SYSTEM (ECS) -->
        <div id="ecs" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üß© Entity Component System (ECS)</h2>

            <div class="concept-box">
                <h4>What is ECS?</h4>
                <p>ECS is a design pattern that separates data (Components) from logic (Systems) and objects (Entities). It's used in many modern game engines for performance and flexibility.</p>
                <p><strong>The Three Parts:</strong></p>
                <ul>
                    <li><strong>Entity:</strong> Just an ID - a bag to hold components</li>
                    <li><strong>Component:</strong> Pure data (Position, Velocity, Health, etc.)</li>
                    <li><strong>System:</strong> Logic that operates on entities with specific components</li>
                </ul>
                <p><strong>Why ECS?</strong></p>
                <ul>
                    <li>Better performance (cache-friendly data layout)</li>
                    <li>More flexible than inheritance</li>
                    <li>Easy to add/remove behaviors</li>
                    <li>Used in Unity DOTS, Bevy, Flecs, etc.</li>
                </ul>
            </div>

            <details data-demo-id="ecs" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: ECS Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Components are pure data
class Position {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class Velocity {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class Renderable {
    constructor(sprite, color) {
        this.sprite = sprite;
        this.color = color;
    }
}

class Health {
    constructor(max) {
        this.current = max;
        this.max = max;
    }
}

// Entity is just an ID with components
class Entity {
    static nextId = 0;

    constructor() {
        this.id = Entity.nextId++;
        this.components = new Map();
    }

    addComponent(component) {
        this.components.set(component.constructor, component);
        return this;  // For chaining
    }

    getComponent(componentClass) {
        return this.components.get(componentClass);
    }

    hasComponent(componentClass) {
        return this.components.has(componentClass);
    }

    removeComponent(componentClass) {
        this.components.delete(componentClass);
    }
}

// World manages all entities
class World {
    constructor() {
        this.entities = [];
        this.systems = [];
    }

    createEntity() {
        const entity = new Entity();
        this.entities.push(entity);
        return entity;
    }

    removeEntity(entity) {
        const index = this.entities.indexOf(entity);
        if (index !== -1) {
            this.entities.splice(index, 1);
        }
    }

    addSystem(system) {
        this.systems.push(system);
    }

    update(deltaTime) {
        for (const system of this.systems) {
            system.update(this.entities, deltaTime);
        }
    }

    // Query entities with specific components
    query(...componentClasses) {
        return this.entities.filter(entity =>
            componentClasses.every(comp => entity.hasComponent(comp))
        );
    }
}

// Systems contain the logic
class MovementSystem {
    update(entities, deltaTime) {
        // Process only entities with Position and Velocity
        for (const entity of entities) {
            if (!entity.hasComponent(Position) ||
                !entity.hasComponent(Velocity)) {
                continue;
            }

            const pos = entity.getComponent(Position);
            const vel = entity.getComponent(Velocity);

            pos.x += vel.x * deltaTime;
            pos.y += vel.y * deltaTime;
        }
    }
}

class RenderSystem {
    constructor(ctx) {
        this.ctx = ctx;
    }

    update(entities) {
        for (const entity of entities) {
            if (!entity.hasComponent(Position) ||
                !entity.hasComponent(Renderable)) {
                continue;
            }

            const pos = entity.getComponent(Position);
            const rend = entity.getComponent(Renderable);

            this.ctx.fillStyle = rend.color;
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using ECS:</h4>
                    <pre><code class="language-javascript">// Create world
const world = new World();

// Add systems
world.addSystem(new MovementSystem());
world.addSystem(new RenderSystem(ctx));

// Create a moving, visible entity (like a player)
world.createEntity()
    .addComponent(new Position(100, 100))
    .addComponent(new Velocity(2, 1))
    .addComponent(new Renderable('circle', 'blue'))
    .addComponent(new Health(100));

// Create a static, visible entity (like a tree)
world.createEntity()
    .addComponent(new Position(300, 200))
    .addComponent(new Renderable('tree', 'green'));
    // No Velocity = doesn't move!

// Game loop
function update(deltaTime) {
    world.update(deltaTime);
}

// Query examples
const movingThings = world.query(Position, Velocity);
const damageable = world.query(Health);</code></pre>
                </div>

                <div class="thinking-prompt">
                    <h4>üß† ECS vs Traditional OOP:</h4>
                    <p><strong>Traditional (Inheritance):</strong></p>
                    <pre><code class="language-javascript">class Enemy extends GameObject {
    // What if we want a moving tree?
    // Or a static enemy?
    // Inheritance is rigid!
}</code></pre>
                    <p><strong>ECS (Composition):</strong></p>
                    <pre><code class="language-javascript">// Mix and match components freely!
// Tree that moves? Add Velocity
// Enemy that's frozen? Remove Velocity
entity.addComponent(new Frozen(5));</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: ECS in Action</h3>
            <div class="diagram">
                <canvas id="ecsDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSpawnMoving">Spawn Moving Entity</button>
                <button id="btnSpawnStatic">Spawn Static Entity</button>
                <button id="btnAddVelocity">Add Velocity to All</button>
                <button id="btnRemoveVelocity">Remove Velocity from All</button>
                <button id="btnClearECS">Clear All</button>
            </div>
            <div id="ecsInfo" class="info-display">Watch how adding/removing components changes behavior!</div>

            <div class="key-point">
                <strong>üí° Performance Tip:</strong> Real ECS implementations store components in contiguous arrays (Structure of Arrays) for CPU cache efficiency. This demo uses Object-Oriented ECS for clarity, but production engines use data-oriented design!
            </div>
        </div>

        <!-- SOUND PROPAGATION -->
        <div id="sound" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üîä Sound Propagation</h2>

            <div class="concept-box">
                <h4>What is Sound Propagation?</h4>
                <p>Sound propagation simulates how audio changes based on distance, obstacles, and environment. This creates immersive audio experiences in games.</p>
                <p><strong>Key Concepts:</strong></p>
                <ul>
                    <li><strong>Distance Attenuation:</strong> Sound gets quieter with distance</li>
                    <li><strong>Occlusion:</strong> Walls block or muffle sound</li>
                    <li><strong>Reverb:</strong> Echoes in enclosed spaces</li>
                    <li><strong>Doppler Effect:</strong> Pitch changes based on relative velocity</li>
                    <li><strong>3D Positioning:</strong> Panning based on direction</li>
                </ul>
            </div>

            <details data-demo-id="sound" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Sound Propagation System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SoundSource {
    constructor(x, y, maxDistance = 500) {
        this.position = new Vector2D(x, y);
        this.maxDistance = maxDistance;
        this.baseVolume = 1.0;
    }

    // Calculate volume based on distance
    calculateVolume(listenerPos) {
        const distance = this.position.distance(listenerPos);

        if (distance >= this.maxDistance) {
            return 0;
        }

        // Linear falloff (can also use inverse square law)
        const attenuation = 1 - (distance / this.maxDistance);

        return this.baseVolume * attenuation;
    }

    // Calculate stereo panning (-1 = left, 0 = center, 1 = right)
    calculatePanning(listenerPos, listenerForward) {
        const toSound = this.position.subtract(listenerPos);
        const right = new Vector2D(-listenerForward.y, listenerForward.x);

        // Dot product with right vector
        const pan = toSound.normalize().dot(right);

        return clamp(pan, -1, 1);
    }

    // Check if sound is occluded by obstacles
    calculateOcclusion(listenerPos, obstacles) {
        let occlusionFactor = 1.0;

        for (const obstacle of obstacles) {
            // Cast ray from listener to sound source
            const intersection = lineIntersectsRect(
                listenerPos,
                this.position,
                obstacle
            );

            if (intersection) {
                // Sound is muffled by obstacle
                occlusionFactor *= 0.3;  // 70% reduction
            }
        }

        return occlusionFactor;
    }
}

class AudioManager {
    constructor() {
        this.listener = {
            position: new Vector2D(0, 0),
            forward: new Vector2D(0, -1)  // Facing up
        };
        this.sources = [];
        this.obstacles = [];
    }

    addSource(x, y, audioElement) {
        const source = new SoundSource(x, y);
        source.audio = audioElement;
        this.sources.push(source);
        return source;
    }

    update() {
        for (const source of this.sources) {
            // Calculate volume with distance and occlusion
            let volume = source.calculateVolume(this.listener.position);
            const occlusion = source.calculateOcclusion(
                this.listener.position,
                this.obstacles
            );
            volume *= occlusion;

            // Calculate panning
            const pan = source.calculatePanning(
                this.listener.position,
                this.listener.forward
            );

            // Apply to Web Audio API (if available)
            if (source.audio) {
                source.audio.volume = volume;
                // For stereo panning, you'd use a StereoPannerNode
            }
        }
    }

    // Doppler effect (pitch shift based on velocity)
    calculateDopplerShift(sourcePos, sourceVel, listenerPos, listenerVel) {
        const speedOfSound = 343;  // m/s (or arbitrary game units)

        const toListener = listenerPos.subtract(sourcePos).normalize();

        // Velocity components toward each other
        const sourceSpeed = sourceVel.dot(toListener);
        const listenerSpeed = listenerVel.dot(toListener);

        // Doppler formula
        const pitchShift = (speedOfSound + listenerSpeed) /
                           (speedOfSound - sourceSpeed);

        return clamp(pitchShift, 0.5, 2.0);  // Limit to reasonable range
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Sound Propagation</h3>
            <div class="diagram">
                <canvas id="soundDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddSoundSource">Add Sound Source</button>
                <button id="btnAddWall">Add Wall</button>
                <button id="btnToggleSound">Enable Sound</button>
                <button id="btnClearSound">Clear All</button>
            </div>
            <div id="soundInfo" class="info-display">Click "Enable Sound" to hear audio! Use WASD to move the listener (blue circle).</div>

            <div class="key-point">
                <strong>üí° Web Audio API:</strong> For real games, use the Web Audio API with AudioContext, PannerNode for 3D positioning, and GainNode for volume control. It provides hardware-accelerated spatial audio!
            </div>
        </div>

        <!-- NETWORK INTERPOLATION -->
        <div id="network" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåê Network Interpolation</h2>

            <div class="concept-box">
                <h4>What is Network Interpolation?</h4>
                <p>In multiplayer games, network updates arrive irregularly (lag, packet loss). Interpolation smoothly animates between network updates to create fluid motion.</p>
                <p><strong>Core Techniques:</strong></p>
                <ul>
                    <li><strong>Client-Side Prediction:</strong> Predict local player movement immediately</li>
                    <li><strong>Server Reconciliation:</strong> Correct predictions when server disagrees</li>
                    <li><strong>Entity Interpolation:</strong> Smooth other players' movement</li>
                    <li><strong>Lag Compensation:</strong> Account for network delay in hit detection</li>
                </ul>
            </div>

            <details data-demo-id="network" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Network Interpolation System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class NetworkEntity {
    constructor(id) {
        this.id = id;
        this.position = new Vector2D(0, 0);
        this.renderPosition = new Vector2D(0, 0);

        // Buffer of recent server updates
        this.positionBuffer = [];
        this.interpolationDelay = 100;  // ms behind server
    }

    // Receive position update from server
    receiveServerUpdate(position, timestamp) {
        this.positionBuffer.push({
            position: position.copy(),
            timestamp: timestamp
        });

        // Keep only last 1 second of updates
        const cutoff = timestamp - 1000;
        this.positionBuffer = this.positionBuffer.filter(
            update => update.timestamp > cutoff
        );
    }

    // Interpolate position based on buffered updates
    updateInterpolation(currentTime) {
        // Render time is slightly behind server
        const renderTime = currentTime - this.interpolationDelay;

        // Find two updates to interpolate between
        let target = null;
        let previous = null;

        for (let i = 0; i < this.positionBuffer.length; i++) {
            if (this.positionBuffer[i].timestamp <= renderTime) {
                previous = this.positionBuffer[i];
            }
            if (this.positionBuffer[i].timestamp >= renderTime) {
                target = this.positionBuffer[i];
                break;
            }
        }

        // No interpolation data available
        if (!previous || !target) {
            if (this.positionBuffer.length > 0) {
                this.renderPosition = this.positionBuffer[0].position.copy();
            }
            return;
        }

        // Interpolate between the two positions
        const timeDiff = target.timestamp - previous.timestamp;
        const t = (renderTime - previous.timestamp) / timeDiff;

        this.renderPosition = Vector2D.lerp(
            previous.position,
            target.position,
            t
        );
    }
}

// Client-side prediction for local player
class PredictedPlayer {
    constructor() {
        this.position = new Vector2D(0, 0);
        this.velocity = new Vector2D(0, 0);
        this.inputSequence = 0;

        // Store inputs for reconciliation
        this.pendingInputs = [];
    }

    // Apply input immediately (prediction)
    applyInput(input) {
        this.inputSequence++;

        // Store input with sequence number
        this.pendingInputs.push({
            input: input,
            sequence: this.inputSequence
        });

        // Apply movement immediately
        this.velocity.set(input.x * 5, input.y * 5);
        this.position.add(this.velocity);

        // Send to server
        this.sendToServer(input, this.inputSequence);
    }

    // Reconcile with server state
    reconcileWithServer(serverPosition, lastProcessedInput) {
        // Remove inputs already processed by server
        this.pendingInputs = this.pendingInputs.filter(
            i => i.sequence > lastProcessedInput
        );

        // Rewind to server position
        this.position = serverPosition.copy();

        // Replay unprocessed inputs
        for (const input of this.pendingInputs) {
            this.velocity.set(input.input.x * 5, input.input.y * 5);
            this.position.add(this.velocity);
        }
    }

    sendToServer(input, sequence) {
        // Send input to server (websocket, etc.)
        // server.send({ input, sequence });
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Network Simulation</h3>
            <div class="diagram">
                <canvas id="networkDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddLatency">Add 100ms Latency</button>
                <button id="btnTogglePrediction">Toggle Prediction</button>
                <button id="btnPacketLoss">Simulate Packet Loss</button>
                <button id="btnResetNetwork">Reset</button>
            </div>
            <div id="networkInfo" class="info-display">Use WASD to move. Compare with/without client-side prediction!</div>

            <div class="thinking-prompt">
                <h4>ü§î Advanced Topic:</h4>
                <p>Real multiplayer games combine multiple techniques: client prediction + server reconciliation + entity interpolation + lag compensation. Games like Rocket League and Overwatch use sophisticated systems to handle 100+ ms of latency smoothly!</p>
            </div>
        </div>

        <!-- DELTA TIME & FIXED TIMESTEP -->
        <div id="delta-time" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>‚è±Ô∏è Delta Time & Fixed Timestep</h2>

            <div class="concept-box">
                <h4>The Problem: Frame Rate Inconsistency</h4>
                <p>Without delta time, your game runs at different speeds on different computers! A player with 60 FPS moves twice as fast as someone with 30 FPS.</p>
                <p><strong>The Solution:</strong> Use delta time (dt) to make movement frame-rate independent.</p>
            </div>

            <h3>Delta Time Basics</h3>

            <details>
                <summary>üìù Click to see: Delta Time Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// WRONG: Frame-rate dependent (bad!)
function badUpdate() {
    player.x += 5;  // Moves 5px per frame
    // At 60fps: moves 300px/sec
    // At 30fps: moves 150px/sec (half speed!)
}

// CORRECT: Frame-rate independent (good!)
let lastTime = 0;

function goodUpdate(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;  // Convert to seconds
    lastTime = currentTime;

    const speed = 300;  // pixels per second
    player.x += speed * deltaTime;
    // At 60fps (dt‚âà0.016): moves 300 * 0.016 = 4.8px per frame = 300px/sec
    // At 30fps (dt‚âà0.033): moves 300 * 0.033 = 10px per frame = 300px/sec
    // Same speed regardless of framerate!
}

// Game loop with delta time
function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(deltaTime);
    render();

    requestAnimationFrame(gameLoop);
}</code></pre>
                </div>
            </details>

            <h3>Fixed Timestep for Physics</h3>

            <div class="concept-box">
                <h4>Why Fixed Timestep?</h4>
                <p>Variable delta time can cause physics instability! Small rounding errors accumulate, tunneling occurs, and determinism is lost.</p>
                <p><strong>Fixed Timestep:</strong> Run physics at a constant rate (like 60Hz), regardless of frame rate. Used in most professional physics engines!</p>
            </div>

            <details>
                <summary>üìù Click to see: Fixed Timestep Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class FixedTimestepGame {
    constructor() {
        this.accumulator = 0;
        this.fixedTimeStep = 1 / 60;  // 60 Hz physics
        this.lastTime = 0;
        this.maxFrameTime = 0.25;  // Cap at 4 FPS to prevent spiral
    }

    update(currentTime) {
        // Calculate frame time
        let frameTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        // Cap frame time to prevent spiral of death
        if (frameTime > this.maxFrameTime) {
            frameTime = this.maxFrameTime;
        }

        // Add to accumulator
        this.accumulator += frameTime;

        // Consume accumulator in fixed-size chunks
        while (this.accumulator >= this.fixedTimeStep) {
            this.fixedUpdate(this.fixedTimeStep);
            this.accumulator -= this.fixedTimeStep;
        }

        // Interpolation factor for smooth rendering
        const alpha = this.accumulator / this.fixedTimeStep;
        this.render(alpha);
    }

    fixedUpdate(dt) {
        // Physics updates here (always constant dt)
        this.updatePhysics(dt);
        this.updateGameLogic(dt);
    }

    render(alpha) {
        // Interpolate between current and previous state
        // for smooth rendering even if physics runs slower
        entities.forEach(entity => {
            const renderPos = Vector2D.lerp(
                entity.previousPosition,
                entity.position,
                alpha
            );
            entity.draw(renderPos);
        });
    }
}

// Game loop
const game = new FixedTimestepGame();

function gameLoop(timestamp) {
    game.update(timestamp);
    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ How it Works:</h4>
                    <pre><code class="language-javascript">// Example timeline:
// Frame 1: dt = 16ms (60fps)
//   accumulator = 16ms
//   Run physics once (16.6ms consumed)
//   accumulator = 0ms

// Frame 2: dt = 33ms (30fps - slow frame!)
//   accumulator = 33ms
//   Run physics twice (16.6ms √ó 2 = 33.2ms consumed)
//   accumulator = 0ms

// Frame 3: dt = 8ms (120fps - fast frame!)
//   accumulator = 8ms
//   Don't run physics (not enough time)
//   accumulator = 8ms (carry over)

// Result: Physics ALWAYS runs at 60Hz,
// regardless of rendering framerate!</code></pre>
                </div>
            </details>

            <h3>Comparison Table</h3>

            <div class="concept-box">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: rgba(255,255,255,0.1);">
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Approach</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Pros</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Cons</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Use Case</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>No Delta Time</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Inconsistent speed</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Never!</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>Variable Delta Time</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple, smooth</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Physics instability</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple games, UI</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>Fixed Timestep</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Stable physics, deterministic</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">More complex</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Physics games, multiplayer</td>
                    </tr>
                </table>
            </div>

            <div class="key-point">
                <strong>üí° Best Practice:</strong>
                <ul>
                    <li>Use <strong>Variable Delta Time</strong> for simple games, animations, and UI elements</li>
                    <li>Use <strong>Fixed Timestep</strong> for physics, platformers, and multiplayer games</li>
                    <li>Always cap your delta time to prevent the "spiral of death" (when the game can't keep up)</li>
                    <li>Professional engines (Unity, Unreal) use fixed timestep for physics by default!</li>
                </ul>
            </div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Implement Both!</h4>
                <p>Try creating a game with:</p>
                <ul>
                    <li>Fixed timestep physics (60Hz) for collision and movement</li>
                    <li>Variable delta time for particle effects and UI animations</li>
                    <li>Interpolated rendering for smooth visuals</li>
                </ul>
            </div>
        </div>

        <!-- Congratulations -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Congratulations, Expert!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You've completed the entire Game Dev Math Guide! You now have the knowledge to create sophisticated, optimized games.
            </p>

            <div class="key-point" style="text-align: left;">
                <strong>üöÄ Where to go from here:</strong>
                <ul>
                    <li>Build a complete game using these techniques</li>
                    <li>Experiment with combining multiple systems</li>
                    <li>Research more advanced topics like shaders, physics engines, and multiplayer networking</li>
                    <li>Share your creations with the game dev community!</li>
                </ul>
            </div>

            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                <a href="index.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                    ‚Üê Back to Home
                </a>
                <a href="beginner.html" class="nav-button">
                    Review Fundamentals
                </a>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="expert-demos.js"></script>
</body>
</html>
