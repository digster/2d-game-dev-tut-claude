<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expert - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üéÆ Expert Game Math</h1>
        <p class="subtitle">Optimization & Advanced Systems - Performance, procedural generation, and complex features</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="advanced.html" class="nav-button">‚Üê Advanced</a>
            <a href="expert.html" class="nav-button active">Expert</a>
            <a href="index.html" class="nav-button">Home</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#spatial">Spatial Partitioning & QuadTree</a></li>
                <li><a href="#pooling">Object Pooling</a></li>
                <li><a href="#procgen">Procedural Generation</a></li>
                <li><a href="#noise">Perlin Noise & Terrain Generation</a></li>
                <li><a href="#tilemap">Tilemap Systems</a></li>
                <li><a href="#ecs">Entity Component System (ECS)</a></li>
                <li><a href="#sound">Sound Propagation</a></li>
                <li><a href="#network">Network Interpolation</a></li>
                <li><a href="#delta-time">Delta Time & Fixed Timestep</a></li>
            </ul>
        </div>

        <!-- SPATIAL PARTITIONING & QUADTREE -->
        <div id="spatial" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üå≥ Spatial Partitioning & QuadTree</h2>

            <div class="concept-box">
                <h4>The Problem: Collision Detection is Slow!</h4>
                <p>Imagine you have 1000 objects in your game. To check collisions between all of them, you'd need to check every pair:</p>
                <div class="formula">
                    1000 √ó 1000 = 1,000,000 checks per frame!
                </div>
                <p>At 60 FPS, that's 60 million checks per second. Your game would crawl to a halt!</p>

                <h4>The Solution: Spatial Partitioning</h4>
                <p>Instead of checking every object against every other object, divide space into regions. Only check objects that are in the same region!</p>
                <p><strong>QuadTree</strong> recursively divides 2D space into four quadrants. Each quadrant can be further divided if it contains too many objects.</p>
            </div>

            <details data-demo-id="quadtree" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: QuadTree Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">QuadTree</span> {
    <span class="keyword">constructor</span>(boundary, capacity = <span class="number">4</span>) {
        <span class="keyword">this</span>.boundary = boundary;  <span class="comment">// Rectangle defining this quad</span>
        <span class="keyword">this</span>.capacity = capacity;  <span class="comment">// Max objects before subdividing</span>
        <span class="keyword">this</span>.objects = [];
        <span class="keyword">this</span>.divided = <span class="keyword">false</span>;
    }

    <span class="function">subdivide</span>() {
        <span class="keyword">const</span> x = <span class="keyword">this</span>.boundary.x;
        <span class="keyword">const</span> y = <span class="keyword">this</span>.boundary.y;
        <span class="keyword">const</span> w = <span class="keyword">this</span>.boundary.width / <span class="number">2</span>;
        <span class="keyword">const</span> h = <span class="keyword">this</span>.boundary.height / <span class="number">2</span>;

        <span class="keyword">this</span>.northeast = <span class="keyword">new</span> <span class="function">QuadTree</span>({x: x + w, y: y, width: w, height: h}, <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.northwest = <span class="keyword">new</span> <span class="function">QuadTree</span>({x: x, y: y, width: w, height: h}, <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.southeast = <span class="keyword">new</span> <span class="function">QuadTree</span>({x: x + w, y: y + h, width: w, height: h}, <span class="keyword">this</span>.capacity);
        <span class="keyword">this</span>.southwest = <span class="keyword">new</span> <span class="function">QuadTree</span>({x: x, y: y + h, width: w, height: h}, <span class="keyword">this</span>.capacity);

        <span class="keyword">this</span>.divided = <span class="keyword">true</span>;
    }

    <span class="function">insert</span>(object) {
        <span class="comment">// Check if object is in this boundary</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="function">contains</span>(object)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        <span class="comment">// If there's room, add it here</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.objects.length < <span class="keyword">this</span>.capacity) {
            <span class="keyword">this</span>.objects.<span class="function">push</span>(object);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="comment">// Otherwise, subdivide and add to child</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>.divided) {
            <span class="keyword">this</span>.<span class="function">subdivide</span>();
        }

        <span class="keyword">return</span> <span class="keyword">this</span>.northeast.<span class="function">insert</span>(object) ||
               <span class="keyword">this</span>.northwest.<span class="function">insert</span>(object) ||
               <span class="keyword">this</span>.southeast.<span class="function">insert</span>(object) ||
               <span class="keyword">this</span>.southwest.<span class="function">insert</span>(object);
    }

    <span class="function">query</span>(range, found = []) {
        <span class="comment">// Check if range intersects this quad's boundary</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="function">intersects</span>(range)) {
            <span class="keyword">return</span> found;
        }

        <span class="comment">// Check objects in this quad</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> <span class="keyword">this</span>.objects) {
            <span class="keyword">if</span> (<span class="function">rangeContains</span>(range, obj)) {
                found.<span class="function">push</span>(obj);
            }
        }

        <span class="comment">// Recursively search children</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.divided) {
            <span class="keyword">this</span>.northeast.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.northwest.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.southeast.<span class="function">query</span>(range, found);
            <span class="keyword">this</span>.southwest.<span class="function">query</span>(range, found);
        }

        <span class="keyword">return</span> found;
    }

    <span class="function">contains</span>(object) {
        <span class="keyword">return</span> object.x >= <span class="keyword">this</span>.boundary.x &&
               object.x < <span class="keyword">this</span>.boundary.x + <span class="keyword">this</span>.boundary.width &&
               object.y >= <span class="keyword">this</span>.boundary.y &&
               object.y < <span class="keyword">this</span>.boundary.y + <span class="keyword">this</span>.boundary.height;
    }

    <span class="function">intersects</span>(range) {
        <span class="keyword">return</span> !(<span class="keyword">this</span>.boundary.x > range.x + range.width ||
                 <span class="keyword">this</span>.boundary.x + <span class="keyword">this</span>.boundary.width < range.x ||
                 <span class="keyword">this</span>.boundary.y > range.y + range.height ||
                 <span class="keyword">this</span>.boundary.y + <span class="keyword">this</span>.boundary.height < range.y);
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using QuadTree for Collision Detection:</h4>
                    <pre><code><span class="comment">// Create quadtree</span>
<span class="keyword">const</span> boundary = {x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">800</span>, height: <span class="number">600</span>};
<span class="keyword">const</span> quadtree = <span class="keyword">new</span> <span class="function">QuadTree</span>(boundary);

<span class="comment">// Insert all objects</span>
objects.<span class="function">forEach</span>(obj => quadtree.<span class="function">insert</span>(obj));

<span class="comment">// For each object, only check nearby objects</span>
objects.<span class="function">forEach</span>(obj => {
    <span class="keyword">const</span> range = {
        x: obj.x - obj.radius * <span class="number">2</span>,
        y: obj.y - obj.radius * <span class="number">2</span>,
        width: obj.radius * <span class="number">4</span>,
        height: obj.radius * <span class="number">4</span>
    };

    <span class="keyword">const</span> nearby = quadtree.<span class="function">query</span>(range);
    nearby.<span class="function">forEach</span>(other => {
        <span class="keyword">if</span> (obj !== other && obj.<span class="function">collidesWith</span>(other)) {
            <span class="function">handleCollision</span>(obj, other);
        }
    });
});</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: QuadTree Visualization</h3>
            <div class="diagram">
                <canvas id="quadtreeDemo" width="800" height="600"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddMany">Add 100 Objects</button>
                <button id="btnToggleTree">Toggle Tree Visualization</button>
                <button id="btnClearQuad">Clear All</button>
            </div>
            <div id="quadInfo" class="info-display">Move mouse to query nearby objects</div>

            <div class="key-point">
                <strong>üí° Performance Impact:</strong> With QuadTree, 1000 objects might only require ~5,000 checks instead of 1,000,000! That's a 200x speedup!
            </div>
        </div>

        <!-- OBJECT POOLING -->
        <div id="pooling" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>‚ôªÔ∏è Object Pooling</h2>

            <div class="concept-box">
                <h4>The Problem: Creating Objects is Slow</h4>
                <p>In games with lots of bullets, particles, or enemies, constantly creating and destroying objects causes:</p>
                <ul>
                    <li>Memory allocation overhead</li>
                    <li>Garbage collection pauses (frame drops!)</li>
                    <li>Slower performance</li>
                </ul>

                <h4>The Solution: Object Pooling</h4>
                <p>Instead of creating/destroying objects, reuse them! Create a "pool" of objects at startup, then activate/deactivate them as needed.</p>
            </div>

            <details data-demo-id="pooling" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Object Pool Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">ObjectPool</span> {
    <span class="keyword">constructor</span>(createFn, resetFn, initialSize = <span class="number">50</span>) {
        <span class="keyword">this</span>.createFn = createFn;  <span class="comment">// Function to create new objects</span>
        <span class="keyword">this</span>.resetFn = resetFn;    <span class="comment">// Function to reset objects for reuse</span>
        <span class="keyword">this</span>.pool = [];
        <span class="keyword">this</span>.active = [];

        <span class="comment">// Pre-create objects</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < initialSize; i++) {
            <span class="keyword">this</span>.pool.<span class="function">push</span>(<span class="keyword">this</span>.<span class="function">createFn</span>());
        }
    }

    <span class="function">get</span>(...args) {
        <span class="keyword">let</span> object;

        <span class="keyword">if</span> (<span class="keyword">this</span>.pool.length > <span class="number">0</span>) {
            <span class="comment">// Reuse from pool</span>
            object = <span class="keyword">this</span>.pool.<span class="function">pop</span>();
        } <span class="keyword">else</span> {
            <span class="comment">// Pool is empty, create new</span>
            object = <span class="keyword">this</span>.<span class="function">createFn</span>();
        }

        <span class="comment">// Reset and activate</span>
        <span class="keyword">this</span>.<span class="function">resetFn</span>(object, ...args);
        <span class="keyword">this</span>.active.<span class="function">push</span>(object);

        <span class="keyword">return</span> object;
    }

    <span class="function">release</span>(object) {
        <span class="comment">// Remove from active</span>
        <span class="keyword">const</span> index = <span class="keyword">this</span>.active.<span class="function">indexOf</span>(object);
        <span class="keyword">if</span> (index !== -<span class="number">1</span>) {
            <span class="keyword">this</span>.active.<span class="function">splice</span>(index, <span class="number">1</span>);
        }

        <span class="comment">// Return to pool</span>
        <span class="keyword">this</span>.pool.<span class="function">push</span>(object);
    }

    <span class="function">update</span>() {
        <span class="comment">// Update all active objects</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.active.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
            <span class="keyword">const</span> obj = <span class="keyword">this</span>.active[i];

            <span class="comment">// Update returns false when object should be released</span>
            <span class="keyword">if</span> (!obj.<span class="function">update</span>()) {
                <span class="keyword">this</span>.<span class="function">release</span>(obj);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Example: Bullet Pool</h4>
                    <pre><code><span class="comment">// Create bullet pool</span>
<span class="keyword">const</span> bulletPool = <span class="keyword">new</span> <span class="function">ObjectPool</span>(
    <span class="comment">// Create function</span>
    () => ({
        position: <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>),
        velocity: <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>),
        active: <span class="keyword">false</span>,
        update() {
            <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
            <span class="comment">// Return false if out of bounds</span>
            <span class="keyword">return</span> <span class="keyword">this</span>.position.x >= <span class="number">0</span> && <span class="keyword">this</span>.position.x <= <span class="number">800</span>;
        }
    }),
    <span class="comment">// Reset function</span>
    (bullet, x, y, vx, vy) => {
        bullet.position.<span class="function">set</span>(x, y);
        bullet.velocity.<span class="function">set</span>(vx, vy);
        bullet.active = <span class="keyword">true</span>;
    }
);

<span class="comment">// Spawn a bullet (no garbage creation!)</span>
<span class="keyword">const</span> bullet = bulletPool.<span class="function">get</span>(playerX, playerY, <span class="number">10</span>, <span class="number">0</span>);

<span class="comment">// Update all active bullets</span>
bulletPool.<span class="function">update</span>();</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Object Pooling</h3>
            <div class="diagram">
                <canvas id="poolingDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnWithPool">With Pooling</button>
                <button id="btnWithoutPool">Without Pooling</button>
                <button id="btnSpawnMany">Spawn 100 Objects</button>
            </div>
            <div id="poolInfo" class="info-display">Compare performance with and without object pooling</div>
        </div>

        <!-- PROCEDURAL GENERATION -->
        <div id="procgen" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üé≤ Procedural Generation</h2>

            <div class="concept-box">
                <h4>What is Procedural Generation?</h4>
                <p>Creating game content algorithmically instead of manually. Used for:</p>
                <ul>
                    <li>Terrain and landscapes</li>
                    <li>Dungeons and levels</li>
                    <li>Trees and vegetation</li>
                    <li>Textures and patterns</li>
                </ul>
                <p><strong>Perlin Noise</strong> creates smooth, natural-looking randomness - perfect for terrain!</p>
            </div>

            <details data-demo-id="noise" data-deps="clearCanvas">
                <summary>üìù Click to see: Simple Noise Function</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Simplified Perlin-like noise</span>
<span class="keyword">class</span> <span class="function">NoiseGenerator</span> {
    <span class="keyword">constructor</span>(seed = <span class="number">0</span>) {
        <span class="keyword">this</span>.seed = seed;
    }

    <span class="comment">// Simple hash function for pseudo-random values</span>
    <span class="function">hash</span>(x, y) {
        <span class="keyword">let</span> h = <span class="keyword">this</span>.seed + x * <span class="number">374761393</span> + y * <span class="number">668265263</span>;
        h = (h ^ (h >> <span class="number">13</span>)) * <span class="number">1274126177</span>;
        <span class="keyword">return</span> (h ^ (h >> <span class="number">16</span>)) / <span class="number">2147483648</span> + <span class="number">0.5</span>;
    }

    <span class="comment">// Smooth interpolation</span>
    <span class="function">smoothstep</span>(t) {
        <span class="keyword">return</span> t * t * (<span class="number">3</span> - <span class="number">2</span> * t);
    }

    <span class="comment">// 2D noise function</span>
    <span class="function">noise</span>(x, y) {
        <span class="keyword">const</span> xi = Math.<span class="function">floor</span>(x);
        <span class="keyword">const</span> yi = Math.<span class="function">floor</span>(y);
        <span class="keyword">const</span> xf = x - xi;
        <span class="keyword">const</span> yf = y - yi;

        <span class="comment">// Get corner values</span>
        <span class="keyword">const</span> n00 = <span class="keyword">this</span>.<span class="function">hash</span>(xi, yi);
        <span class="keyword">const</span> n10 = <span class="keyword">this</span>.<span class="function">hash</span>(xi + <span class="number">1</span>, yi);
        <span class="keyword">const</span> n01 = <span class="keyword">this</span>.<span class="function">hash</span>(xi, yi + <span class="number">1</span>);
        <span class="keyword">const</span> n11 = <span class="keyword">this</span>.<span class="function">hash</span>(xi + <span class="number">1</span>, yi + <span class="number">1</span>);

        <span class="comment">// Smooth interpolation</span>
        <span class="keyword">const</span> sx = <span class="keyword">this</span>.<span class="function">smoothstep</span>(xf);
        <span class="keyword">const</span> sy = <span class="keyword">this</span>.<span class="function">smoothstep</span>(yf);

        <span class="keyword">const</span> nx0 = <span class="function">lerp</span>(n00, n10, sx);
        <span class="keyword">const</span> nx1 = <span class="function">lerp</span>(n01, n11, sx);

        <span class="keyword">return</span> <span class="function">lerp</span>(nx0, nx1, sy);
    }

    <span class="comment">// Multi-octave noise (more detail)</span>
    <span class="function">fractalNoise</span>(x, y, octaves = <span class="number">4</span>) {
        <span class="keyword">let</span> value = <span class="number">0</span>;
        <span class="keyword">let</span> amplitude = <span class="number">1</span>;
        <span class="keyword">let</span> frequency = <span class="number">1</span>;
        <span class="keyword">let</span> maxValue = <span class="number">0</span>;

        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < octaves; i++) {
            value += <span class="keyword">this</span>.<span class="function">noise</span>(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= <span class="number">0.5</span>;
            frequency *= <span class="number">2</span>;
        }

        <span class="keyword">return</span> value / maxValue;
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Procedural Terrain</h3>
            <div class="diagram">
                <canvas id="procgenDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnNewSeed">New Random Seed</button>
                <button id="btnTerrain">Generate Terrain</button>
                <button id="btnClouds">Generate Clouds</button>
                <button id="btnMarble">Generate Marble</button>
            </div>
            <div id="procgenInfo" class="info-display">Watch procedural generation create natural patterns</div>
        </div>

        <!-- PERLIN NOISE & TERRAIN GENERATION -->
        <div id="noise" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üèîÔ∏è Perlin Noise & Terrain Generation</h2>

            <div class="concept-box">
                <h4>What is Perlin Noise?</h4>
                <p>Perlin Noise creates smooth, natural-looking randomness. Unlike pure random values that jump erratically, Perlin Noise produces coherent, organic patterns perfect for:</p>
                <ul>
                    <li>Terrain height maps (mountains, valleys)</li>
                    <li>Cloud patterns</li>
                    <li>Wood/marble textures</li>
                    <li>Ocean waves</li>
                </ul>
            </div>

            <details data-demo-id="procgen" data-deps="clearCanvas">
                <summary>üìù Click to see: Perlin Noise Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">PerlinNoise</span> {
    <span class="keyword">constructor</span>() {
        <span class="comment">// Permutation table (256 values, repeated)</span>
        <span class="keyword">this</span>.p = [];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">256</span>; i++) {
            <span class="keyword">this</span>.p[i] = Math.<span class="function">floor</span>(Math.<span class="function">random</span>() * <span class="number">256</span>);
        }
        <span class="comment">// Duplicate for overflow</span>
        <span class="keyword">this</span>.p = <span class="keyword">this</span>.p.<span class="function">concat</span>(<span class="keyword">this</span>.p);
    }

    <span class="function">fade</span>(t) {
        <span class="comment">// Smoothstep: 6t^5 - 15t^4 + 10t^3</span>
        <span class="keyword">return</span> t * t * t * (t * (t * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);
    }

    <span class="function">lerp</span>(a, b, t) {
        <span class="keyword">return</span> a + t * (b - a);
    }

    <span class="function">grad</span>(hash, x, y) {
        <span class="comment">// Convert hash to gradient vector</span>
        <span class="keyword">const</span> h = hash & <span class="number">3</span>;
        <span class="keyword">const</span> u = h < <span class="number">2</span> ? x : y;
        <span class="keyword">const</span> v = h < <span class="number">2</span> ? y : x;
        <span class="keyword">return</span> ((h & <span class="number">1</span>) ? -u : u) + ((h & <span class="number">2</span>) ? -v : v);
    }

    <span class="function">noise</span>(x, y) {
        <span class="comment">// Find grid cell</span>
        <span class="keyword">const</span> X = Math.<span class="function">floor</span>(x) & <span class="number">255</span>;
        <span class="keyword">const</span> Y = Math.<span class="function">floor</span>(y) & <span class="number">255</span>;

        <span class="comment">// Relative position within cell</span>
        x -= Math.<span class="function">floor</span>(x);
        y -= Math.<span class="function">floor</span>(y);

        <span class="comment">// Fade curves</span>
        <span class="keyword">const</span> u = <span class="keyword">this</span>.<span class="function">fade</span>(x);
        <span class="keyword">const</span> v = <span class="keyword">this</span>.<span class="function">fade</span>(y);

        <span class="comment">// Hash coordinates of 4 cube corners</span>
        <span class="keyword">const</span> a = <span class="keyword">this</span>.p[X] + Y;
        <span class="keyword">const</span> aa = <span class="keyword">this</span>.p[a];
        <span class="keyword">const</span> ab = <span class="keyword">this</span>.p[a + <span class="number">1</span>];
        <span class="keyword">const</span> b = <span class="keyword">this</span>.p[X + <span class="number">1</span>] + Y;
        <span class="keyword">const</span> ba = <span class="keyword">this</span>.p[b];
        <span class="keyword">const</span> bb = <span class="keyword">this</span>.p[b + <span class="number">1</span>];

        <span class="comment">// Blend results from 4 corners</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">lerp</span>(
            <span class="keyword">this</span>.<span class="function">lerp</span>(<span class="keyword">this</span>.<span class="function">grad</span>(aa, x, y), <span class="keyword">this</span>.<span class="function">grad</span>(ba, x - <span class="number">1</span>, y), u),
            <span class="keyword">this</span>.<span class="function">lerp</span>(<span class="keyword">this</span>.<span class="function">grad</span>(ab, x, y - <span class="number">1</span>), <span class="keyword">this</span>.<span class="function">grad</span>(bb, x - <span class="number">1</span>, y - <span class="number">1</span>), u),
            v
        );
    }

    <span class="comment">// Octave noise - combine multiple frequencies</span>
    <span class="function">octaveNoise</span>(x, y, octaves = <span class="number">4</span>, persistence = <span class="number">0.5</span>) {
        <span class="keyword">let</span> total = <span class="number">0</span>;
        <span class="keyword">let</span> frequency = <span class="number">1</span>;
        <span class="keyword">let</span> amplitude = <span class="number">1</span>;
        <span class="keyword">let</span> maxValue = <span class="number">0</span>;

        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < octaves; i++) {
            total += <span class="keyword">this</span>.<span class="function">noise</span>(x * frequency, y * frequency) * amplitude;
            maxValue += amplitude;
            amplitude *= persistence;
            frequency *= <span class="number">2</span>;
        }

        <span class="keyword">return</span> total / maxValue;
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Terrain Generation Example:</h4>
                    <pre><code><span class="keyword">class</span> <span class="function">TerrainGenerator</span> {
    <span class="keyword">constructor</span>(width, height) {
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
        <span class="keyword">this</span>.noise = <span class="keyword">new</span> <span class="function">PerlinNoise</span>();
        <span class="keyword">this</span>.heightmap = [];
    }

    <span class="function">generate</span>(scale = <span class="number">0.05</span>) {
        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y < <span class="keyword">this</span>.height; y++) {
            <span class="keyword">this</span>.heightmap[y] = [];
            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x < <span class="keyword">this</span>.width; x++) {
                <span class="comment">// Get noise value (0-1)</span>
                <span class="keyword">const</span> value = <span class="keyword">this</span>.noise.<span class="function">octaveNoise</span>(
                    x * scale,
                    y * scale,
                    <span class="number">4</span>,      <span class="comment">// 4 octaves</span>
                    <span class="number">0.5</span>     <span class="comment">// persistence</span>
                );

                <span class="comment">// Normalize to 0-1 range</span>
                <span class="keyword">this</span>.heightmap[y][x] = (value + <span class="number">1</span>) / <span class="number">2</span>;
            }
        }
    }

    <span class="function">getTileType</span>(x, y) {
        <span class="keyword">const</span> height = <span class="keyword">this</span>.heightmap[y][x];

        <span class="comment">// Map height to terrain types</span>
        <span class="keyword">if</span> (height < <span class="number">0.3</span>) <span class="keyword">return</span> <span class="string">'water'</span>;
        <span class="keyword">if</span> (height < <span class="number">0.4</span>) <span class="keyword">return</span> <span class="string">'sand'</span>;
        <span class="keyword">if</span> (height < <span class="number">0.7</span>) <span class="keyword">return</span> <span class="string">'grass'</span>;
        <span class="keyword">if</span> (height < <span class="number">0.9</span>) <span class="keyword">return</span> <span class="string">'mountain'</span>;
        <span class="keyword">return</span> <span class="string">'snow'</span>;
    }

    <span class="function">getColor</span>(tileType) {
        <span class="keyword">const</span> colors = {
            water: <span class="string">'#4A90E2'</span>,
            sand: <span class="string">'#F5DEB3'</span>,
            grass: <span class="string">'#7EC850'</span>,
            mountain: <span class="string">'#8B7355'</span>,
            snow: <span class="string">'#FFFFFF'</span>
        };
        <span class="keyword">return</span> colors[tileType];
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Terrain Generation</h3>
            <div class="diagram">
                <canvas id="noiseDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnNewSeed">New Seed</button>
                <button id="btnIncreaseScale">Zoom Out</button>
                <button id="btnDecreaseScale">Zoom In</button>
                <button id="btnToggleHeight">Toggle Heightmap</button>
                <button id="btnToggleContours">Toggle Contours</button>
            </div>
            <div id="noiseInfo" class="info-display">Click to generate new terrain!</div>

            <div class="key-point">
                <strong>üí° Octaves Explained:</strong>
                <ul>
                    <li><strong>1 Octave:</strong> Smooth, rolling hills</li>
                    <li><strong>4 Octaves:</strong> Realistic terrain with detail</li>
                    <li><strong>8 Octaves:</strong> Highly detailed, rocky landscapes</li>
                </ul>
                More octaves = more detail, but slower generation!
            </div>
        </div>

        <!-- TILEMAP SYSTEMS -->
        <div id="tilemap" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üó∫Ô∏è Tilemap Systems</h2>

            <div class="concept-box">
                <h4>What are Tilemaps?</h4>
                <p>Tilemaps divide the game world into a grid of tiles. Each tile can be a different type (grass, wall, water, etc.). Benefits:</p>
                <ul>
                    <li>Memory efficient (reuse tile graphics)</li>
                    <li>Easy level editing</li>
                    <li>Simple collision detection</li>
                    <li>Fast rendering (only draw visible tiles)</li>
                </ul>
            </div>

            <details data-demo-id="tilemap" data-deps="clearCanvas">
                <summary>üìù Click to see: Tilemap Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">Tilemap</span> {
    <span class="keyword">constructor</span>(width, height, tileSize) {
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
        <span class="keyword">this</span>.tileSize = tileSize;
        <span class="keyword">this</span>.tiles = [];

        <span class="comment">// Initialize empty map</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y < height; y++) {
            <span class="keyword">this</span>.tiles[y] = [];
            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x < width; x++) {
                <span class="keyword">this</span>.tiles[y][x] = <span class="number">0</span>;  <span class="comment">// 0 = empty</span>
            }
        }
    }

    <span class="function">setTile</span>(x, y, type) {
        <span class="keyword">if</span> (x >= <span class="number">0</span> && x < <span class="keyword">this</span>.width && y >= <span class="number">0</span> && y < <span class="keyword">this</span>.height) {
            <span class="keyword">this</span>.tiles[y][x] = type;
        }
    }

    <span class="function">getTile</span>(x, y) {
        <span class="keyword">if</span> (x >= <span class="number">0</span> && x < <span class="keyword">this</span>.width && y >= <span class="number">0</span> && y < <span class="keyword">this</span>.height) {
            <span class="keyword">return</span> <span class="keyword">this</span>.tiles[y][x];
        }
        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// Out of bounds</span>
    }

    <span class="comment">// Convert world position to tile coordinates</span>
    <span class="function">worldToTile</span>(worldX, worldY) {
        <span class="keyword">return</span> {
            x: Math.<span class="function">floor</span>(worldX / <span class="keyword">this</span>.tileSize),
            y: Math.<span class="function">floor</span>(worldY / <span class="keyword">this</span>.tileSize)
        };
    }

    <span class="comment">// Check if tile is solid (for collision)</span>
    <span class="function">isSolid</span>(x, y) {
        <span class="keyword">const</span> tile = <span class="keyword">this</span>.<span class="function">getTile</span>(x, y);
        <span class="keyword">return</span> tile === <span class="number">1</span>;  <span class="comment">// 1 = wall</span>
    }

    <span class="function">render</span>(ctx, camera) {
        <span class="comment">// Only render visible tiles</span>
        <span class="keyword">const</span> startX = Math.<span class="function">max</span>(<span class="number">0</span>, Math.<span class="function">floor</span>(camera.x / <span class="keyword">this</span>.tileSize));
        <span class="keyword">const</span> startY = Math.<span class="function">max</span>(<span class="number">0</span>, Math.<span class="function">floor</span>(camera.y / <span class="keyword">this</span>.tileSize));
        <span class="keyword">const</span> endX = Math.<span class="function">min</span>(<span class="keyword">this</span>.width, startX + camera.width / <span class="keyword">this</span>.tileSize + <span class="number">1</span>);
        <span class="keyword">const</span> endY = Math.<span class="function">min</span>(<span class="keyword">this</span>.height, startY + camera.height / <span class="keyword">this</span>.tileSize + <span class="number">1</span>);

        <span class="keyword">for</span> (<span class="keyword">let</span> y = startY; y < endY; y++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> x = startX; x < endX; x++) {
                <span class="keyword">const</span> tile = <span class="keyword">this</span>.tiles[y][x];
                <span class="keyword">if</span> (tile !== <span class="number">0</span>) {
                    <span class="keyword">this</span>.<span class="function">renderTile</span>(ctx, x, y, tile, camera);
                }
            }
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Tilemap Editor</h3>
            <div class="diagram">
                <canvas id="tilemapDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnGrass">Paint Grass</button>
                <button id="btnWall">Paint Wall</button>
                <button id="btnWater">Paint Water</button>
                <button id="btnErase">Erase</button>
                <button id="btnClearTilemap">Clear Map</button>
            </div>
            <div id="tilemapInfo" class="info-display">Click and drag to paint tiles</div>
        </div>

        <!-- ENTITY COMPONENT SYSTEM (ECS) -->
        <div id="ecs" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üß© Entity Component System (ECS)</h2>

            <div class="concept-box">
                <h4>What is ECS?</h4>
                <p>ECS is a design pattern that separates data (Components) from logic (Systems) and objects (Entities). It's used in many modern game engines for performance and flexibility.</p>
                <p><strong>The Three Parts:</strong></p>
                <ul>
                    <li><strong>Entity:</strong> Just an ID - a bag to hold components</li>
                    <li><strong>Component:</strong> Pure data (Position, Velocity, Health, etc.)</li>
                    <li><strong>System:</strong> Logic that operates on entities with specific components</li>
                </ul>
                <p><strong>Why ECS?</strong></p>
                <ul>
                    <li>Better performance (cache-friendly data layout)</li>
                    <li>More flexible than inheritance</li>
                    <li>Easy to add/remove behaviors</li>
                    <li>Used in Unity DOTS, Bevy, Flecs, etc.</li>
                </ul>
            </div>

            <details data-demo-id="ecs" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: ECS Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Components are pure data</span>
<span class="keyword">class</span> <span class="function">Position</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
    }
}

<span class="keyword">class</span> <span class="function">Velocity</span> {
    <span class="keyword">constructor</span>(x, y) {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
    }
}

<span class="keyword">class</span> <span class="function">Renderable</span> {
    <span class="keyword">constructor</span>(sprite, color) {
        <span class="keyword">this</span>.sprite = sprite;
        <span class="keyword">this</span>.color = color;
    }
}

<span class="keyword">class</span> <span class="function">Health</span> {
    <span class="keyword">constructor</span>(max) {
        <span class="keyword">this</span>.current = max;
        <span class="keyword">this</span>.max = max;
    }
}

<span class="comment">// Entity is just an ID with components</span>
<span class="keyword">class</span> <span class="function">Entity</span> {
    <span class="keyword">static</span> nextId = <span class="number">0</span>;

    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.id = Entity.nextId++;
        <span class="keyword">this</span>.components = <span class="keyword">new</span> <span class="function">Map</span>();
    }

    <span class="function">addComponent</span>(component) {
        <span class="keyword">this</span>.components.<span class="function">set</span>(component.constructor, component);
        <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// For chaining</span>
    }

    <span class="function">getComponent</span>(componentClass) {
        <span class="keyword">return</span> <span class="keyword">this</span>.components.<span class="function">get</span>(componentClass);
    }

    <span class="function">hasComponent</span>(componentClass) {
        <span class="keyword">return</span> <span class="keyword">this</span>.components.<span class="function">has</span>(componentClass);
    }

    <span class="function">removeComponent</span>(componentClass) {
        <span class="keyword">this</span>.components.<span class="function">delete</span>(componentClass);
    }
}

<span class="comment">// World manages all entities</span>
<span class="keyword">class</span> <span class="function">World</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.entities = [];
        <span class="keyword">this</span>.systems = [];
    }

    <span class="function">createEntity</span>() {
        <span class="keyword">const</span> entity = <span class="keyword">new</span> <span class="function">Entity</span>();
        <span class="keyword">this</span>.entities.<span class="function">push</span>(entity);
        <span class="keyword">return</span> entity;
    }

    <span class="function">removeEntity</span>(entity) {
        <span class="keyword">const</span> index = <span class="keyword">this</span>.entities.<span class="function">indexOf</span>(entity);
        <span class="keyword">if</span> (index !== -<span class="number">1</span>) {
            <span class="keyword">this</span>.entities.<span class="function">splice</span>(index, <span class="number">1</span>);
        }
    }

    <span class="function">addSystem</span>(system) {
        <span class="keyword">this</span>.systems.<span class="function">push</span>(system);
    }

    <span class="function">update</span>(deltaTime) {
        <span class="keyword">for</span> (<span class="keyword">const</span> system <span class="keyword">of</span> <span class="keyword">this</span>.systems) {
            system.<span class="function">update</span>(<span class="keyword">this</span>.entities, deltaTime);
        }
    }

    <span class="comment">// Query entities with specific components</span>
    <span class="function">query</span>(...componentClasses) {
        <span class="keyword">return</span> <span class="keyword">this</span>.entities.<span class="function">filter</span>(entity =>
            componentClasses.<span class="function">every</span>(comp => entity.<span class="function">hasComponent</span>(comp))
        );
    }
}

<span class="comment">// Systems contain the logic</span>
<span class="keyword">class</span> <span class="function">MovementSystem</span> {
    <span class="function">update</span>(entities, deltaTime) {
        <span class="comment">// Process only entities with Position and Velocity</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> entity <span class="keyword">of</span> entities) {
            <span class="keyword">if</span> (!entity.<span class="function">hasComponent</span>(Position) ||
                !entity.<span class="function">hasComponent</span>(Velocity)) {
                <span class="keyword">continue</span>;
            }

            <span class="keyword">const</span> pos = entity.<span class="function">getComponent</span>(Position);
            <span class="keyword">const</span> vel = entity.<span class="function">getComponent</span>(Velocity);

            pos.x += vel.x * deltaTime;
            pos.y += vel.y * deltaTime;
        }
    }
}

<span class="keyword">class</span> <span class="function">RenderSystem</span> {
    <span class="keyword">constructor</span>(ctx) {
        <span class="keyword">this</span>.ctx = ctx;
    }

    <span class="function">update</span>(entities) {
        <span class="keyword">for</span> (<span class="keyword">const</span> entity <span class="keyword">of</span> entities) {
            <span class="keyword">if</span> (!entity.<span class="function">hasComponent</span>(Position) ||
                !entity.<span class="function">hasComponent</span>(Renderable)) {
                <span class="keyword">continue</span>;
            }

            <span class="keyword">const</span> pos = entity.<span class="function">getComponent</span>(Position);
            <span class="keyword">const</span> rend = entity.<span class="function">getComponent</span>(Renderable);

            <span class="keyword">this</span>.ctx.fillStyle = rend.color;
            <span class="keyword">this</span>.ctx.beginPath();
            <span class="keyword">this</span>.ctx.<span class="function">arc</span>(pos.x, pos.y, <span class="number">10</span>, <span class="number">0</span>, Math.PI * <span class="number">2</span>);
            <span class="keyword">this</span>.ctx.<span class="function">fill</span>();
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ Using ECS:</h4>
                    <pre><code><span class="comment">// Create world</span>
<span class="keyword">const</span> world = <span class="keyword">new</span> <span class="function">World</span>();

<span class="comment">// Add systems</span>
world.<span class="function">addSystem</span>(<span class="keyword">new</span> <span class="function">MovementSystem</span>());
world.<span class="function">addSystem</span>(<span class="keyword">new</span> <span class="function">RenderSystem</span>(ctx));

<span class="comment">// Create a moving, visible entity (like a player)</span>
world.<span class="function">createEntity</span>()
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Position</span>(<span class="number">100</span>, <span class="number">100</span>))
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Velocity</span>(<span class="number">2</span>, <span class="number">1</span>))
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Renderable</span>(<span class="string">'circle'</span>, <span class="string">'blue'</span>))
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Health</span>(<span class="number">100</span>));

<span class="comment">// Create a static, visible entity (like a tree)</span>
world.<span class="function">createEntity</span>()
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Position</span>(<span class="number">300</span>, <span class="number">200</span>))
    .<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Renderable</span>(<span class="string">'tree'</span>, <span class="string">'green'</span>));
    <span class="comment">// No Velocity = doesn't move!</span>

<span class="comment">// Game loop</span>
<span class="keyword">function</span> <span class="function">update</span>(deltaTime) {
    world.<span class="function">update</span>(deltaTime);
}

<span class="comment">// Query examples</span>
<span class="keyword">const</span> movingThings = world.<span class="function">query</span>(Position, Velocity);
<span class="keyword">const</span> damageable = world.<span class="function">query</span>(Health);</code></pre>
                </div>

                <div class="thinking-prompt">
                    <h4>üß† ECS vs Traditional OOP:</h4>
                    <p><strong>Traditional (Inheritance):</strong></p>
                    <pre><code><span class="keyword">class</span> <span class="function">Enemy</span> <span class="keyword">extends</span> <span class="function">GameObject</span> {
    <span class="comment">// What if we want a moving tree?</span>
    <span class="comment">// Or a static enemy?</span>
    <span class="comment">// Inheritance is rigid!</span>
}</code></pre>
                    <p><strong>ECS (Composition):</strong></p>
                    <pre><code><span class="comment">// Mix and match components freely!</span>
<span class="comment">// Tree that moves? Add Velocity</span>
<span class="comment">// Enemy that's frozen? Remove Velocity</span>
entity.<span class="function">addComponent</span>(<span class="keyword">new</span> <span class="function">Frozen</span>(<span class="number">5</span>));</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: ECS in Action</h3>
            <div class="diagram">
                <canvas id="ecsDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnSpawnMoving">Spawn Moving Entity</button>
                <button id="btnSpawnStatic">Spawn Static Entity</button>
                <button id="btnAddVelocity">Add Velocity to All</button>
                <button id="btnRemoveVelocity">Remove Velocity from All</button>
                <button id="btnClearECS">Clear All</button>
            </div>
            <div id="ecsInfo" class="info-display">Watch how adding/removing components changes behavior!</div>

            <div class="key-point">
                <strong>üí° Performance Tip:</strong> Real ECS implementations store components in contiguous arrays (Structure of Arrays) for CPU cache efficiency. This demo uses Object-Oriented ECS for clarity, but production engines use data-oriented design!
            </div>
        </div>

        <!-- SOUND PROPAGATION -->
        <div id="sound" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üîä Sound Propagation</h2>

            <div class="concept-box">
                <h4>What is Sound Propagation?</h4>
                <p>Sound propagation simulates how audio changes based on distance, obstacles, and environment. This creates immersive audio experiences in games.</p>
                <p><strong>Key Concepts:</strong></p>
                <ul>
                    <li><strong>Distance Attenuation:</strong> Sound gets quieter with distance</li>
                    <li><strong>Occlusion:</strong> Walls block or muffle sound</li>
                    <li><strong>Reverb:</strong> Echoes in enclosed spaces</li>
                    <li><strong>Doppler Effect:</strong> Pitch changes based on relative velocity</li>
                    <li><strong>3D Positioning:</strong> Panning based on direction</li>
                </ul>
            </div>

            <details data-demo-id="sound" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Sound Propagation System</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">SoundSource</span> {
    <span class="keyword">constructor</span>(x, y, maxDistance = <span class="number">500</span>) {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(x, y);
        <span class="keyword">this</span>.maxDistance = maxDistance;
        <span class="keyword">this</span>.baseVolume = <span class="number">1.0</span>;
    }

    <span class="comment">// Calculate volume based on distance</span>
    <span class="function">calculateVolume</span>(listenerPos) {
        <span class="keyword">const</span> distance = <span class="keyword">this</span>.position.<span class="function">distance</span>(listenerPos);

        <span class="keyword">if</span> (distance >= <span class="keyword">this</span>.maxDistance) {
            <span class="keyword">return</span> <span class="number">0</span>;
        }

        <span class="comment">// Linear falloff (can also use inverse square law)</span>
        <span class="keyword">const</span> attenuation = <span class="number">1</span> - (distance / <span class="keyword">this</span>.maxDistance);

        <span class="keyword">return</span> <span class="keyword">this</span>.baseVolume * attenuation;
    }

    <span class="comment">// Calculate stereo panning (-1 = left, 0 = center, 1 = right)</span>
    <span class="function">calculatePanning</span>(listenerPos, listenerForward) {
        <span class="keyword">const</span> toSound = <span class="keyword">this</span>.position.<span class="function">subtract</span>(listenerPos);
        <span class="keyword">const</span> right = <span class="keyword">new</span> <span class="function">Vector2D</span>(-listenerForward.y, listenerForward.x);

        <span class="comment">// Dot product with right vector</span>
        <span class="keyword">const</span> pan = toSound.<span class="function">normalize</span>().<span class="function">dot</span>(right);

        <span class="keyword">return</span> <span class="function">clamp</span>(pan, -<span class="number">1</span>, <span class="number">1</span>);
    }

    <span class="comment">// Check if sound is occluded by obstacles</span>
    <span class="function">calculateOcclusion</span>(listenerPos, obstacles) {
        <span class="keyword">let</span> occlusionFactor = <span class="number">1.0</span>;

        <span class="keyword">for</span> (<span class="keyword">const</span> obstacle <span class="keyword">of</span> obstacles) {
            <span class="comment">// Cast ray from listener to sound source</span>
            <span class="keyword">const</span> intersection = <span class="function">lineIntersectsRect</span>(
                listenerPos,
                <span class="keyword">this</span>.position,
                obstacle
            );

            <span class="keyword">if</span> (intersection) {
                <span class="comment">// Sound is muffled by obstacle</span>
                occlusionFactor *= <span class="number">0.3</span>;  <span class="comment">// 70% reduction</span>
            }
        }

        <span class="keyword">return</span> occlusionFactor;
    }
}

<span class="keyword">class</span> <span class="function">AudioManager</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.listener = {
            position: <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>),
            forward: <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, -<span class="number">1</span>)  <span class="comment">// Facing up</span>
        };
        <span class="keyword">this</span>.sources = [];
        <span class="keyword">this</span>.obstacles = [];
    }

    <span class="function">addSource</span>(x, y, audioElement) {
        <span class="keyword">const</span> source = <span class="keyword">new</span> <span class="function">SoundSource</span>(x, y);
        source.audio = audioElement;
        <span class="keyword">this</span>.sources.<span class="function">push</span>(source);
        <span class="keyword">return</span> source;
    }

    <span class="function">update</span>() {
        <span class="keyword">for</span> (<span class="keyword">const</span> source <span class="keyword">of</span> <span class="keyword">this</span>.sources) {
            <span class="comment">// Calculate volume with distance and occlusion</span>
            <span class="keyword">let</span> volume = source.<span class="function">calculateVolume</span>(<span class="keyword">this</span>.listener.position);
            <span class="keyword">const</span> occlusion = source.<span class="function">calculateOcclusion</span>(
                <span class="keyword">this</span>.listener.position,
                <span class="keyword">this</span>.obstacles
            );
            volume *= occlusion;

            <span class="comment">// Calculate panning</span>
            <span class="keyword">const</span> pan = source.<span class="function">calculatePanning</span>(
                <span class="keyword">this</span>.listener.position,
                <span class="keyword">this</span>.listener.forward
            );

            <span class="comment">// Apply to Web Audio API (if available)</span>
            <span class="keyword">if</span> (source.audio) {
                source.audio.volume = volume;
                <span class="comment">// For stereo panning, you'd use a StereoPannerNode</span>
            }
        }
    }

    <span class="comment">// Doppler effect (pitch shift based on velocity)</span>
    <span class="function">calculateDopplerShift</span>(sourcePos, sourceVel, listenerPos, listenerVel) {
        <span class="keyword">const</span> speedOfSound = <span class="number">343</span>;  <span class="comment">// m/s (or arbitrary game units)</span>

        <span class="keyword">const</span> toListener = listenerPos.<span class="function">subtract</span>(sourcePos).<span class="function">normalize</span>();

        <span class="comment">// Velocity components toward each other</span>
        <span class="keyword">const</span> sourceSpeed = sourceVel.<span class="function">dot</span>(toListener);
        <span class="keyword">const</span> listenerSpeed = listenerVel.<span class="function">dot</span>(toListener);

        <span class="comment">// Doppler formula</span>
        <span class="keyword">const</span> pitchShift = (speedOfSound + listenerSpeed) /
                           (speedOfSound - sourceSpeed);

        <span class="keyword">return</span> <span class="function">clamp</span>(pitchShift, <span class="number">0.5</span>, <span class="number">2.0</span>);  <span class="comment">// Limit to reasonable range</span>
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Sound Propagation</h3>
            <div class="diagram">
                <canvas id="soundDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddSoundSource">Add Sound Source</button>
                <button id="btnAddWall">Add Wall</button>
                <button id="btnToggleSound">Enable Sound</button>
                <button id="btnClearSound">Clear All</button>
            </div>
            <div id="soundInfo" class="info-display">Click "Enable Sound" to hear audio! Use WASD to move the listener (blue circle).</div>

            <div class="key-point">
                <strong>üí° Web Audio API:</strong> For real games, use the Web Audio API with AudioContext, PannerNode for 3D positioning, and GainNode for volume control. It provides hardware-accelerated spatial audio!
            </div>
        </div>

        <!-- NETWORK INTERPOLATION -->
        <div id="network" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåê Network Interpolation</h2>

            <div class="concept-box">
                <h4>What is Network Interpolation?</h4>
                <p>In multiplayer games, network updates arrive irregularly (lag, packet loss). Interpolation smoothly animates between network updates to create fluid motion.</p>
                <p><strong>Core Techniques:</strong></p>
                <ul>
                    <li><strong>Client-Side Prediction:</strong> Predict local player movement immediately</li>
                    <li><strong>Server Reconciliation:</strong> Correct predictions when server disagrees</li>
                    <li><strong>Entity Interpolation:</strong> Smooth other players' movement</li>
                    <li><strong>Lag Compensation:</strong> Account for network delay in hit detection</li>
                </ul>
            </div>

            <details data-demo-id="network" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Network Interpolation System</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">NetworkEntity</span> {
    <span class="keyword">constructor</span>(id) {
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.renderPosition = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);

        <span class="comment">// Buffer of recent server updates</span>
        <span class="keyword">this</span>.positionBuffer = [];
        <span class="keyword">this</span>.interpolationDelay = <span class="number">100</span>;  <span class="comment">// ms behind server</span>
    }

    <span class="comment">// Receive position update from server</span>
    <span class="function">receiveServerUpdate</span>(position, timestamp) {
        <span class="keyword">this</span>.positionBuffer.<span class="function">push</span>({
            position: position.<span class="function">copy</span>(),
            timestamp: timestamp
        });

        <span class="comment">// Keep only last 1 second of updates</span>
        <span class="keyword">const</span> cutoff = timestamp - <span class="number">1000</span>;
        <span class="keyword">this</span>.positionBuffer = <span class="keyword">this</span>.positionBuffer.<span class="function">filter</span>(
            update => update.timestamp > cutoff
        );
    }

    <span class="comment">// Interpolate position based on buffered updates</span>
    <span class="function">updateInterpolation</span>(currentTime) {
        <span class="comment">// Render time is slightly behind server</span>
        <span class="keyword">const</span> renderTime = currentTime - <span class="keyword">this</span>.interpolationDelay;

        <span class="comment">// Find two updates to interpolate between</span>
        <span class="keyword">let</span> target = <span class="keyword">null</span>;
        <span class="keyword">let</span> previous = <span class="keyword">null</span>;

        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="keyword">this</span>.positionBuffer.length; i++) {
            <span class="keyword">if</span> (<span class="keyword">this</span>.positionBuffer[i].timestamp <= renderTime) {
                previous = <span class="keyword">this</span>.positionBuffer[i];
            }
            <span class="keyword">if</span> (<span class="keyword">this</span>.positionBuffer[i].timestamp >= renderTime) {
                target = <span class="keyword">this</span>.positionBuffer[i];
                <span class="keyword">break</span>;
            }
        }

        <span class="comment">// No interpolation data available</span>
        <span class="keyword">if</span> (!previous || !target) {
            <span class="keyword">if</span> (<span class="keyword">this</span>.positionBuffer.length > <span class="number">0</span>) {
                <span class="keyword">this</span>.renderPosition = <span class="keyword">this</span>.positionBuffer[<span class="number">0</span>].position.<span class="function">copy</span>();
            }
            <span class="keyword">return</span>;
        }

        <span class="comment">// Interpolate between the two positions</span>
        <span class="keyword">const</span> timeDiff = target.timestamp - previous.timestamp;
        <span class="keyword">const</span> t = (renderTime - previous.timestamp) / timeDiff;

        <span class="keyword">this</span>.renderPosition = Vector2D.<span class="function">lerp</span>(
            previous.position,
            target.position,
            t
        );
    }
}

<span class="comment">// Client-side prediction for local player</span>
<span class="keyword">class</span> <span class="function">PredictedPlayer</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.position = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.velocity = <span class="keyword">new</span> <span class="function">Vector2D</span>(<span class="number">0</span>, <span class="number">0</span>);
        <span class="keyword">this</span>.inputSequence = <span class="number">0</span>;

        <span class="comment">// Store inputs for reconciliation</span>
        <span class="keyword">this</span>.pendingInputs = [];
    }

    <span class="comment">// Apply input immediately (prediction)</span>
    <span class="function">applyInput</span>(input) {
        <span class="keyword">this</span>.inputSequence++;

        <span class="comment">// Store input with sequence number</span>
        <span class="keyword">this</span>.pendingInputs.<span class="function">push</span>({
            input: input,
            sequence: <span class="keyword">this</span>.inputSequence
        });

        <span class="comment">// Apply movement immediately</span>
        <span class="keyword">this</span>.velocity.<span class="function">set</span>(input.x * <span class="number">5</span>, input.y * <span class="number">5</span>);
        <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);

        <span class="comment">// Send to server</span>
        <span class="keyword">this</span>.<span class="function">sendToServer</span>(input, <span class="keyword">this</span>.inputSequence);
    }

    <span class="comment">// Reconcile with server state</span>
    <span class="function">reconcileWithServer</span>(serverPosition, lastProcessedInput) {
        <span class="comment">// Remove inputs already processed by server</span>
        <span class="keyword">this</span>.pendingInputs = <span class="keyword">this</span>.pendingInputs.<span class="function">filter</span>(
            i => i.sequence > lastProcessedInput
        );

        <span class="comment">// Rewind to server position</span>
        <span class="keyword">this</span>.position = serverPosition.<span class="function">copy</span>();

        <span class="comment">// Replay unprocessed inputs</span>
        <span class="keyword">for</span> (<span class="keyword">const</span> input <span class="keyword">of</span> <span class="keyword">this</span>.pendingInputs) {
            <span class="keyword">this</span>.velocity.<span class="function">set</span>(input.input.x * <span class="number">5</span>, input.input.y * <span class="number">5</span>);
            <span class="keyword">this</span>.position.<span class="function">add</span>(<span class="keyword">this</span>.velocity);
        }
    }

    <span class="function">sendToServer</span>(input, sequence) {
        <span class="comment">// Send input to server (websocket, etc.)</span>
        <span class="comment">// server.send({ input, sequence });</span>
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Network Simulation</h3>
            <div class="diagram">
                <canvas id="networkDemo" width="800" height="500"></canvas>
            </div>
            <div class="controls">
                <button id="btnAddLatency">Add 100ms Latency</button>
                <button id="btnTogglePrediction">Toggle Prediction</button>
                <button id="btnPacketLoss">Simulate Packet Loss</button>
                <button id="btnResetNetwork">Reset</button>
            </div>
            <div id="networkInfo" class="info-display">Use WASD to move. Compare with/without client-side prediction!</div>

            <div class="thinking-prompt">
                <h4>ü§î Advanced Topic:</h4>
                <p>Real multiplayer games combine multiple techniques: client prediction + server reconciliation + entity interpolation + lag compensation. Games like Rocket League and Overwatch use sophisticated systems to handle 100+ ms of latency smoothly!</p>
            </div>
        </div>

        <!-- DELTA TIME & FIXED TIMESTEP -->
        <div id="delta-time" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>‚è±Ô∏è Delta Time & Fixed Timestep</h2>

            <div class="concept-box">
                <h4>The Problem: Frame Rate Inconsistency</h4>
                <p>Without delta time, your game runs at different speeds on different computers! A player with 60 FPS moves twice as fast as someone with 30 FPS.</p>
                <p><strong>The Solution:</strong> Use delta time (dt) to make movement frame-rate independent.</p>
            </div>

            <h3>Delta Time Basics</h3>

            <details>
                <summary>üìù Click to see: Delta Time Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// WRONG: Frame-rate dependent (bad!)</span>
<span class="keyword">function</span> <span class="function">badUpdate</span>() {
    player.x += <span class="number">5</span>;  <span class="comment">// Moves 5px per frame</span>
    <span class="comment">// At 60fps: moves 300px/sec</span>
    <span class="comment">// At 30fps: moves 150px/sec (half speed!)</span>
}

<span class="comment">// CORRECT: Frame-rate independent (good!)</span>
<span class="keyword">let</span> lastTime = <span class="number">0</span>;

<span class="keyword">function</span> <span class="function">goodUpdate</span>(currentTime) {
    <span class="keyword">const</span> deltaTime = (currentTime - lastTime) / <span class="number">1000</span>;  <span class="comment">// Convert to seconds</span>
    lastTime = currentTime;

    <span class="keyword">const</span> speed = <span class="number">300</span>;  <span class="comment">// pixels per second</span>
    player.x += speed * deltaTime;
    <span class="comment">// At 60fps (dt‚âà0.016): moves 300 * 0.016 = 4.8px per frame = 300px/sec</span>
    <span class="comment">// At 30fps (dt‚âà0.033): moves 300 * 0.033 = 10px per frame = 300px/sec</span>
    <span class="comment">// Same speed regardless of framerate!</span>
}

<span class="comment">// Game loop with delta time</span>
<span class="keyword">function</span> <span class="function">gameLoop</span>(timestamp) {
    <span class="keyword">const</span> deltaTime = (timestamp - lastTime) / <span class="number">1000</span>;
    lastTime = timestamp;

    <span class="function">update</span>(deltaTime);
    <span class="function">render</span>();

    <span class="function">requestAnimationFrame</span>(gameLoop);
}</code></pre>
                </div>
            </details>

            <h3>Fixed Timestep for Physics</h3>

            <div class="concept-box">
                <h4>Why Fixed Timestep?</h4>
                <p>Variable delta time can cause physics instability! Small rounding errors accumulate, tunneling occurs, and determinism is lost.</p>
                <p><strong>Fixed Timestep:</strong> Run physics at a constant rate (like 60Hz), regardless of frame rate. Used in most professional physics engines!</p>
            </div>

            <details>
                <summary>üìù Click to see: Fixed Timestep Implementation</summary>
                <div class="code-container">
                    <pre><code><span class="keyword">class</span> <span class="function">FixedTimestepGame</span> {
    <span class="keyword">constructor</span>() {
        <span class="keyword">this</span>.accumulator = <span class="number">0</span>;
        <span class="keyword">this</span>.fixedTimeStep = <span class="number">1</span> / <span class="number">60</span>;  <span class="comment">// 60 Hz physics</span>
        <span class="keyword">this</span>.lastTime = <span class="number">0</span>;
        <span class="keyword">this</span>.maxFrameTime = <span class="number">0.25</span>;  <span class="comment">// Cap at 4 FPS to prevent spiral</span>
    }

    <span class="function">update</span>(currentTime) {
        <span class="comment">// Calculate frame time</span>
        <span class="keyword">let</span> frameTime = (currentTime - <span class="keyword">this</span>.lastTime) / <span class="number">1000</span>;
        <span class="keyword">this</span>.lastTime = currentTime;

        <span class="comment">// Cap frame time to prevent spiral of death</span>
        <span class="keyword">if</span> (frameTime > <span class="keyword">this</span>.maxFrameTime) {
            frameTime = <span class="keyword">this</span>.maxFrameTime;
        }

        <span class="comment">// Add to accumulator</span>
        <span class="keyword">this</span>.accumulator += frameTime;

        <span class="comment">// Consume accumulator in fixed-size chunks</span>
        <span class="keyword">while</span> (<span class="keyword">this</span>.accumulator >= <span class="keyword">this</span>.fixedTimeStep) {
            <span class="keyword">this</span>.<span class="function">fixedUpdate</span>(<span class="keyword">this</span>.fixedTimeStep);
            <span class="keyword">this</span>.accumulator -= <span class="keyword">this</span>.fixedTimeStep;
        }

        <span class="comment">// Interpolation factor for smooth rendering</span>
        <span class="keyword">const</span> alpha = <span class="keyword">this</span>.accumulator / <span class="keyword">this</span>.fixedTimeStep;
        <span class="keyword">this</span>.<span class="function">render</span>(alpha);
    }

    <span class="function">fixedUpdate</span>(dt) {
        <span class="comment">// Physics updates here (always constant dt)</span>
        <span class="keyword">this</span>.<span class="function">updatePhysics</span>(dt);
        <span class="keyword">this</span>.<span class="function">updateGameLogic</span>(dt);
    }

    <span class="function">render</span>(alpha) {
        <span class="comment">// Interpolate between current and previous state</span>
        <span class="comment">// for smooth rendering even if physics runs slower</span>
        entities.<span class="function">forEach</span>(entity => {
            <span class="keyword">const</span> renderPos = Vector2D.<span class="function">lerp</span>(
                entity.previousPosition,
                entity.position,
                alpha
            );
            entity.<span class="function">draw</span>(renderPos);
        });
    }
}

<span class="comment">// Game loop</span>
<span class="keyword">const</span> game = <span class="keyword">new</span> <span class="function">FixedTimestepGame</span>();

<span class="keyword">function</span> <span class="function">gameLoop</span>(timestamp) {
    game.<span class="function">update</span>(timestamp);
    <span class="function">requestAnimationFrame</span>(gameLoop);
}

<span class="function">requestAnimationFrame</span>(gameLoop);</code></pre>
                </div>

                <div class="example-box">
                    <h4>üéÆ How it Works:</h4>
                    <pre><code><span class="comment">// Example timeline:</span>
<span class="comment">// Frame 1: dt = 16ms (60fps)</span>
<span class="comment">//   accumulator = 16ms</span>
<span class="comment">//   Run physics once (16.6ms consumed)</span>
<span class="comment">//   accumulator = 0ms</span>

<span class="comment">// Frame 2: dt = 33ms (30fps - slow frame!)</span>
<span class="comment">//   accumulator = 33ms</span>
<span class="comment">//   Run physics twice (16.6ms √ó 2 = 33.2ms consumed)</span>
<span class="comment">//   accumulator = 0ms</span>

<span class="comment">// Frame 3: dt = 8ms (120fps - fast frame!)</span>
<span class="comment">//   accumulator = 8ms</span>
<span class="comment">//   Don't run physics (not enough time)</span>
<span class="comment">//   accumulator = 8ms (carry over)</span>

<span class="comment">// Result: Physics ALWAYS runs at 60Hz,</span>
<span class="comment">// regardless of rendering framerate!</span></code></pre>
                </div>
            </details>

            <h3>Comparison Table</h3>

            <div class="concept-box">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: rgba(255,255,255,0.1);">
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Approach</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Pros</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Cons</th>
                        <th style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Use Case</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>No Delta Time</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Inconsistent speed</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Never!</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>Variable Delta Time</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple, smooth</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Physics instability</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Simple games, UI</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);"><strong>Fixed Timestep</strong></td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Stable physics, deterministic</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">More complex</td>
                        <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Physics games, multiplayer</td>
                    </tr>
                </table>
            </div>

            <div class="key-point">
                <strong>üí° Best Practice:</strong>
                <ul>
                    <li>Use <strong>Variable Delta Time</strong> for simple games, animations, and UI elements</li>
                    <li>Use <strong>Fixed Timestep</strong> for physics, platformers, and multiplayer games</li>
                    <li>Always cap your delta time to prevent the "spiral of death" (when the game can't keep up)</li>
                    <li>Professional engines (Unity, Unreal) use fixed timestep for physics by default!</li>
                </ul>
            </div>

            <div class="challenge-box">
                <h4>üèÜ Challenge: Implement Both!</h4>
                <p>Try creating a game with:</p>
                <ul>
                    <li>Fixed timestep physics (60Hz) for collision and movement</li>
                    <li>Variable delta time for particle effects and UI animations</li>
                    <li>Interpolated rendering for smooth visuals</li>
                </ul>
            </div>
        </div>

        <!-- Congratulations -->
        <div class="section" style="text-align: center;">
            <h2>üéâ Congratulations, Expert!</h2>
            <p style="font-size: 1.2em; margin: 30px 0;">
                You've completed the entire Game Dev Math Guide! You now have the knowledge to create sophisticated, optimized games.
            </p>

            <div class="key-point" style="text-align: left;">
                <strong>üöÄ Where to go from here:</strong>
                <ul>
                    <li>Build a complete game using these techniques</li>
                    <li>Experiment with combining multiple systems</li>
                    <li>Research more advanced topics like shaders, physics engines, and multiplayer networking</li>
                    <li>Share your creations with the game dev community!</li>
                </ul>
            </div>

            <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin-top: 40px;">
                <a href="index.html" class="nav-button" style="font-size: 1.2em; padding: 20px 40px;">
                    ‚Üê Back to Home
                </a>
                <a href="beginner.html" class="nav-button">
                    Review Fundamentals
                </a>
            </div>
        </div>
    </div>

    <!-- Scroll to Top Button -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <!-- Load shared utilities -->
    <script src="shared/utils.js"></script>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <!-- Page-specific JavaScript -->
    <script src="expert-demos.js"></script>
</body>
</html>
