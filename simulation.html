<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üåä Simulation Systems</h1>
        <p class="subtitle">Advanced simulation techniques - Fluids, cloth, and realistic effects</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="expert.html" class="nav-button">Expert</a>
            <a href="simulation.html" class="nav-button active">Simulation</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#fluid-dynamics">Fluid Dynamics Simulation</a></li>
            </ul>
        </div>

        <!-- FLUID DYNAMICS -->
        <div id="fluid-dynamics" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåä Fluid Dynamics Simulation</h2>

            <div class="concept-box">
                <h4>What is Fluid Simulation?</h4>
                <p>Fluid simulation recreates the behavior of liquids and gases - water splashing, smoke rising, or fire spreading. In games, we often use simplified models that look realistic without the massive computational cost of real physics.</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Instead of simulating individual water molecules, we divide space into a grid and calculate how properties like velocity, pressure, and density flow between neighboring cells.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Fluids Work: The Basics</h4>
                <p>Real fluids follow the <strong>Navier-Stokes equations</strong>, but don't worry - we'll break this down into simple concepts!</p>

                <ul>
                    <li><strong>Advection:</strong> Fluid carries things along with it (like a river carrying a leaf)</li>
                    <li><strong>Diffusion:</strong> Properties spread out over time (like ink dispersing in water)</li>
                    <li><strong>Pressure:</strong> Fluid pushes away from high-pressure areas</li>
                    <li><strong>Incompressibility:</strong> Liquid volume stays constant (water doesn't compress)</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Fluid Grid Setup</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Fluid simulation grid</span>
<span class="keyword">class</span> <span class="function">FluidGrid</span> {
    <span class="keyword">constructor</span>(width, height, scale) {
        <span class="keyword">this</span>.cols = Math.<span class="function">floor</span>(width / scale);
        <span class="keyword">this</span>.rows = Math.<span class="function">floor</span>(height / scale);
        <span class="keyword">this</span>.scale = scale;

        <span class="comment">// Create grids for velocity (in X and Y directions)</span>
        <span class="keyword">this</span>.vx = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Previous velocity (for stability)</span>
        <span class="keyword">this</span>.vx0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Density (for visualization - like dye in water)</span>
        <span class="keyword">this</span>.density = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.density0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
    }

    <span class="function">createGrid</span>() {
        <span class="keyword">const</span> grid = [];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
            grid[i] = <span class="keyword">new</span> <span class="function">Array</span>(<span class="keyword">this</span>.cols).<span class="function">fill</span>(<span class="number">0</span>);
        }
        <span class="keyword">return</span> grid;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Diffusion (Spreading)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Diffusion spreads values to neighbors
// Like heat spreading through metal or ink dispersing in water</span>
<span class="function">diffuse</span>(x, x0, diffusion, dt) {
    <span class="keyword">const</span> a = dt * diffusion * <span class="keyword">this</span>.cols * <span class="keyword">this</span>.rows;

    <span class="comment">// Gauss-Seidel iteration for stability</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                <span class="comment">// Average with neighbors, weighted by diffusion rate</span>
                x[i][j] = (x0[i][j] + a * (
                    x[i - <span class="number">1</span>][j] + x[i + <span class="number">1</span>][j] +
                    x[i][j - <span class="number">1</span>] + x[i][j + <span class="number">1</span>]
                )) / (<span class="number">1</span> + <span class="number">4</span> * a);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Diffusion:</h4>
                    <p>Think of a drop of food coloring in water. It starts concentrated, then slowly spreads out. Each cell shares a bit of its "stuff" with neighbors. The <code>diffusion</code> parameter controls how fast this happens.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Advection (Flow)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Advection moves values along the velocity field
// Like a river carrying leaves downstream</span>
<span class="function">advect</span>(d, d0, vx, vy, dt) {
    <span class="keyword">const</span> dt0 = dt * <span class="keyword">this</span>.cols;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            <span class="comment">// Trace backwards along velocity</span>
            <span class="keyword">let</span> x = j - dt0 * vx[i][j];
            <span class="keyword">let</span> y = i - dt0 * vy[i][j];

            <span class="comment">// Clamp to grid boundaries</span>
            x = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.cols - <span class="number">1.5</span>, x));
            y = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.rows - <span class="number">1.5</span>, y));

            <span class="comment">// Interpolate between grid cells</span>
            <span class="keyword">const</span> i0 = Math.<span class="function">floor</span>(y);
            <span class="keyword">const</span> i1 = i0 + <span class="number">1</span>;
            <span class="keyword">const</span> j0 = Math.<span class="function">floor</span>(x);
            <span class="keyword">const</span> j1 = j0 + <span class="number">1</span>;

            <span class="keyword">const</span> s1 = x - j0;
            <span class="keyword">const</span> s0 = <span class="number">1</span> - s1;
            <span class="keyword">const</span> t1 = y - i0;
            <span class="keyword">const</span> t0 = <span class="number">1</span> - t1;

            <span class="comment">// Bilinear interpolation</span>
            d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                      s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Advection:</h4>
                    <p>Imagine you drop dye in a moving river. The dye doesn't just sit there - it flows with the water. Advection does this: for each cell, we look backward along the velocity to see where the fluid came from, then bring that value forward.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Pressure & Incompressibility</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Project removes divergence (ensures fluid is incompressible)
// This is what makes fluid behave like liquid, not gas</span>
<span class="function">project</span>(vx, vy, p, div) {
    <span class="comment">// Calculate divergence (how much fluid is leaving each cell)</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            div[i][j] = -<span class="number">0.5</span> * (
                vx[i][j + <span class="number">1</span>] - vx[i][j - <span class="number">1</span>] +
                vy[i + <span class="number">1</span>][j] - vy[i - <span class="number">1</span>][j]
            ) / <span class="keyword">this</span>.cols;
            p[i][j] = <span class="number">0</span>;
        }
    }

    <span class="comment">// Solve for pressure using iterative method</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                p[i][j] = (div[i][j] +
                    p[i - <span class="number">1</span>][j] + p[i + <span class="number">1</span>][j] +
                    p[i][j - <span class="number">1</span>] + p[i][j + <span class="number">1</span>]
                ) / <span class="number">4</span>;
            }
        }
    }

    <span class="comment">// Subtract pressure gradient from velocity</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            vx[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i][j + <span class="number">1</span>] - p[i][j - <span class="number">1</span>]);
            vy[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i + <span class="number">1</span>][j] - p[i - <span class="number">1</span>][j]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pressure:</h4>
                    <p>Water doesn't compress easily. If too much water flows into a cell, pressure builds up and pushes it out to neighbors. This step ensures the simulation stays physically plausible - the same amount of fluid stays in the system.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Complete Simulation Step</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Main simulation step - call this every frame</span>
<span class="function">step</span>(dt = <span class="number">0.016</span>) {
    <span class="keyword">const</span> visc = <span class="number">0.0001</span>;  <span class="comment">// Viscosity (thickness of fluid)</span>
    <span class="keyword">const</span> diff = <span class="number">0.0001</span>;  <span class="comment">// Diffusion rate</span>

    <span class="comment">// 1. Diffuse velocity (friction between fluid layers)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, visc, dt);
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, visc, dt);

    <span class="comment">// 2. Project (fix velocity to be incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 3. Advect velocity (velocity moves itself)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);

    <span class="comment">// 4. Project again (ensure still incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 5. Diffuse density (dye spreads out)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, diff, dt);

    <span class="comment">// 6. Advect density (velocity carries dye along)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, <span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, dt);

    <span class="comment">// 7. Fade density over time (optional, for visual effect)</span>
    <span class="keyword">this</span>.<span class="function">fadeDensity</span>(<span class="number">0.99</span>);
}

<span class="function">fadeDensity</span>(fadeRate) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++) {
            <span class="keyword">this</span>.density[i][j] *= fadeRate;
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Fluid Simulation</h3>
            <div class="example-box">
                <strong>üñ±Ô∏è How to Use:</strong> Click and drag on the canvas below to add fluid and watch it flow! Try different presets and features below.
            </div>
            <div class="diagram">
                <canvas id="fluidDemo" width="800" height="600" style="border: 1px solid #444;"></canvas>
            </div>

            <div class="controls" style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px;">
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Presets:</strong>
                    <button id="btnWater">üíß Water</button>
                    <button id="btnSmoke">üí® Smoke</button>
                    <button id="btnInk">üñãÔ∏è Ink</button>
                    <button id="btnHoney">üçØ Honey</button>
                    <button id="btnGas">‚òÅÔ∏è Gas</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Features:</strong>
                    <button id="btnVelocity">Show Velocity Field</button>
                    <button id="btnAddObstacle">Add Obstacle (Click Canvas)</button>
                    <button id="btnClearObstacles">Clear Obstacles</button>
                    <button id="btnContinuousSource">Continuous Source</button>
                    <button id="btnWind">Toggle Wind</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Quick Switch:</strong>
                    <button id="btnColorDefault">üíß Water</button>
                    <button id="btnColorRainbow">üåà Ink</button>
                    <button id="btnColorFire">üçØ Honey</button>
                    <button id="btnColorBlue">‚òÅÔ∏è Gas</button>
                    <button id="btnClearFluid">üóëÔ∏è Clear All</button>
                </div>

                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <label>
                        Viscosity: <input type="range" id="viscSlider" min="0" max="0.002" step="0.0001" value="0.0001">
                        <span id="viscValue">0.0001</span>
                    </label>
                    <label>
                        Diffusion: <input type="range" id="diffSlider" min="0" max="0.001" step="0.0001" value="0.0001">
                        <span id="diffValue">0.0001</span>
                    </label>
                    <label>
                        Fade Rate: <input type="range" id="fadeSlider" min="0.9" max="1" step="0.01" value="0.99">
                        <span id="fadeValue">0.99</span>
                    </label>
                </div>
            </div>

            <div class="info-display" id="fluidInfo" style="margin-top: 10px;">
                Current Mode: Free Draw | Click and drag to add fluid
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üé® Try These Examples (Each Material Looks Completely Different!):</h4>
                <ol>
                    <li><strong>üíß Water (Clear Blue):</strong> Flows freely with a cyan-blue transparent appearance. Great for water effects!</li>
                    <li><strong>üí® Smoke (Gray Wisps):</strong> Soft gray with glow effect that rises upward. Click "Continuous Source" to see it billow!</li>
                    <li><strong>üñãÔ∏è Ink (Rainbow Colors):</strong> Vibrant multicolored fluid that creates beautiful psychedelic patterns</li>
                    <li><strong>üçØ Honey (Golden Amber):</strong> Rich golden color, very thick and viscous - watch it pour slowly!</li>
                    <li><strong>‚òÅÔ∏è Gas (Green-Yellow):</strong> Light greenish with glow, disperses quickly and rises slightly</li>
                    <li><strong>Add Obstacles:</strong> Try any material with obstacles to see realistic flow patterns!</li>
                </ol>
            </div>

            <div class="example-box" style="margin-top: 20px;">
                <h4>‚öôÔ∏è Understanding the Parameters:</h4>
                <ul>
                    <li><strong>Viscosity:</strong> How "thick" the fluid is
                        <ul>
                            <li>Low (0.00001) = Water, gas - flows freely</li>
                            <li>High (0.001) = Honey, syrup - very thick and slow</li>
                        </ul>
                    </li>
                    <li><strong>Diffusion:</strong> How fast properties spread out
                        <ul>
                            <li>Low = Fluid stays concentrated</li>
                            <li>High = Fluid disperses quickly like smoke or gas</li>
                        </ul>
                    </li>
                    <li><strong>Fade Rate:</strong> How quickly density disappears
                        <ul>
                            <li>0.95 = Fades very quickly (good for gas effects)</li>
                            <li>0.999 = Stays visible for a long time (good for permanent liquids)</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üéØ Visual Features & Material Properties:</h4>
                <ul>
                    <li><strong>Material-Specific Colors:</strong> Each material has unique colors, transparency, and background
                        <ul>
                            <li>üíß <strong>Water:</strong> Cyan-blue on dark blue background (70% opacity)</li>
                            <li>üí® <strong>Smoke:</strong> Soft gray with glow effect on dark gray bg (50% opacity)</li>
                            <li>üñãÔ∏è <strong>Ink:</strong> Rainbow gradient on black background (90% opacity)</li>
                            <li>üçØ <strong>Honey:</strong> Golden amber on brown background (85% opacity)</li>
                            <li>‚òÅÔ∏è <strong>Gas:</strong> Green-yellow with glow on greenish bg (40% opacity)</li>
                        </ul>
                    </li>
                    <li><strong>Velocity Field:</strong> White arrows showing fluid movement direction and speed</li>
                    <li><strong>Obstacles:</strong> Gray barriers that create realistic flow patterns around them</li>
                    <li><strong>Continuous Source:</strong> Constant fluid stream from top center</li>
                    <li><strong>Wind/Buoyancy:</strong> Upward force (automatic for smoke and gas)</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üéÆ Game Usage:</strong> Fluid simulation is perfect for water effects, smoke, fire, magic spells, and atmospheric effects. Adjust grid resolution for performance - smaller grids run faster but look less detailed.
            </div>

            <div class="example-box">
                <h4>‚ö° Performance Tips:</h4>
                <ul>
                    <li><strong>Grid Size:</strong> Use smaller grids (32x32 or 64x64) for real-time games</li>
                    <li><strong>Iterations:</strong> Reduce iteration count (10-15) if too slow</li>
                    <li><strong>GPU:</strong> Consider WebGL shaders for large simulations</li>
                    <li><strong>Hybrid:</strong> Combine simple particle systems with fluid for best visual/performance ratio</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>üìö Further Reading:</h4>
                <ul>
                    <li><strong>Navier-Stokes Equations:</strong> The full physics of fluid motion</li>
                    <li><strong>Jos Stam's "Stable Fluids":</strong> The paper this technique is based on</li>
                    <li><strong>SPH (Smoothed Particle Hydrodynamics):</strong> Alternative particle-based approach</li>
                    <li><strong>Level Set Methods:</strong> For tracking fluid surfaces</li>
                </ul>
            </div>
        </div>

        <!-- Scroll to Top Button -->
        <div class="scroll-to-top" id="scrollToTop">‚Üë</div>
    </div>

    <script>
        // Scroll to top functionality
        const scrollToTopBtn = document.getElementById('scrollToTop');

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.style.opacity = '1';
            } else {
                scrollToTopBtn.style.opacity = '0';
            }
        });

        scrollToTopBtn.style.opacity = '0';
        scrollToTopBtn.style.transition = 'opacity 0.3s';

        // ===================================
        // FLUID SIMULATION DEMO
        // ===================================

        // Ensure DOM is loaded
        const canvas = document.getElementById('fluidDemo');
        const ctx = canvas.getContext('2d');

        if (!canvas || !ctx) {
            console.error('Canvas not found!');
        } else {

        class FluidGrid {
            constructor(width, height, scale) {
                this.cols = Math.floor(width / scale);
                this.rows = Math.floor(height / scale);
                this.scale = scale;

                this.vx = this.createGrid();
                this.vy = this.createGrid();
                this.vx0 = this.createGrid();
                this.vy0 = this.createGrid();

                this.density = this.createGrid();
                this.density0 = this.createGrid();

                // For projection
                this.p = this.createGrid();
                this.div = this.createGrid();

                // Obstacles (1 = blocked, 0 = free)
                this.obstacles = this.createGrid();

                // Settings
                this.visc = 0.0001;
                this.diff = 0.0001;
                this.fadeRate = 0.99;

                // Visual settings
                this.colorMode = 'default';
                this.showVelocity = false;
                this.material = 'water'; // water, smoke, ink, honey, gas

                // Wind/gravity
                this.windX = 0;
                this.windY = 0;
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.rows; i++) {
                    grid[i] = new Array(this.cols).fill(0);
                }
                return grid;
            }

            diffuse(x, x0, diffusion, dt) {
                const a = dt * diffusion * this.cols * this.rows;

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            if (this.obstacles[i][j] === 1) continue;

                            x[i][j] = (x0[i][j] + a * (
                                x[i - 1][j] + x[i + 1][j] +
                                x[i][j - 1] + x[i][j + 1]
                            )) / (1 + 4 * a);
                        }
                    }
                    this.setBoundary(0, x);
                }
            }

            advect(d, d0, vx, vy, dt) {
                const dt0 = dt * this.cols;

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        if (this.obstacles[i][j] === 1) {
                            d[i][j] = 0;
                            continue;
                        }

                        let x = j - dt0 * vx[i][j];
                        let y = i - dt0 * vy[i][j];

                        x = Math.max(0.5, Math.min(this.cols - 1.5, x));
                        y = Math.max(0.5, Math.min(this.rows - 1.5, y));

                        const i0 = Math.floor(y);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(x);
                        const j1 = j0 + 1;

                        const s1 = x - j0;
                        const s0 = 1 - s1;
                        const t1 = y - i0;
                        const t0 = 1 - t1;

                        d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                                  s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
                    }
                }
                this.setBoundary(0, d);
            }

            project(vx, vy, p, div) {
                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        div[i][j] = -0.5 * (
                            vx[i][j + 1] - vx[i][j - 1] +
                            vy[i + 1][j] - vy[i - 1][j]
                        ) / this.cols;
                        p[i][j] = 0;
                    }
                }
                this.setBoundary(0, div);
                this.setBoundary(0, p);

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            p[i][j] = (div[i][j] +
                                p[i - 1][j] + p[i + 1][j] +
                                p[i][j - 1] + p[i][j + 1]
                            ) / 4;
                        }
                    }
                    this.setBoundary(0, p);
                }

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        vx[i][j] -= 0.5 * this.cols * (p[i][j + 1] - p[i][j - 1]);
                        vy[i][j] -= 0.5 * this.cols * (p[i + 1][j] - p[i - 1][j]);
                    }
                }
                this.setBoundary(1, vx);
                this.setBoundary(2, vy);
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.rows - 1; i++) {
                    x[i][0] = b === 1 ? -x[i][1] : x[i][1];
                    x[i][this.cols - 1] = b === 1 ? -x[i][this.cols - 2] : x[i][this.cols - 2];
                }
                for (let j = 1; j < this.cols - 1; j++) {
                    x[0][j] = b === 2 ? -x[1][j] : x[1][j];
                    x[this.rows - 1][j] = b === 2 ? -x[this.rows - 2][j] : x[this.rows - 2][j];
                }

                x[0][0] = 0.5 * (x[1][0] + x[0][1]);
                x[0][this.cols - 1] = 0.5 * (x[1][this.cols - 1] + x[0][this.cols - 2]);
                x[this.rows - 1][0] = 0.5 * (x[this.rows - 2][0] + x[this.rows - 1][1]);
                x[this.rows - 1][this.cols - 1] = 0.5 * (x[this.rows - 2][this.cols - 1] + x[this.rows - 1][this.cols - 2]);
            }

            step(dt = 0.016) {
                // Apply wind/gravity
                if (this.windX !== 0 || this.windY !== 0) {
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            this.vx[i][j] += this.windX * dt * 10;
                            this.vy[i][j] += this.windY * dt * 10;
                        }
                    }
                }

                // Swap arrays
                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.diffuse(this.vx, this.vx0, this.visc, dt);
                this.diffuse(this.vy, this.vy0, this.visc, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.advect(this.vx, this.vx0, this.vx0, this.vy0, dt);
                this.advect(this.vy, this.vy0, this.vx0, this.vy0, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.density0, this.density] = [this.density, this.density0];

                this.diffuse(this.density, this.density0, this.diff, dt);

                [this.density0, this.density] = [this.density, this.density0];

                this.advect(this.density, this.density0, this.vx, this.vy, dt);

                this.fadeDensity(this.fadeRate);
            }

            fadeDensity(fadeRate) {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.density[i][j] *= fadeRate;
                    }
                }
            }

            addDensity(x, y, amount) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.density[i][j] += amount;
                }
            }

            addVelocity(x, y, vx, vy) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.vx[i][j] += vx;
                    this.vy[i][j] += vy;
                }
            }

            addObstacle(x, y, radius = 3) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);

                for (let di = -radius; di <= radius; di++) {
                    for (let dj = -radius; dj <= radius; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                            if (di * di + dj * dj <= radius * radius) {
                                this.obstacles[ni][nj] = 1;
                            }
                        }
                    }
                }
            }

            clearObstacles() {
                this.obstacles = this.createGrid();
            }

            getColor(density) {
                const d = Math.min(255, Math.floor(density));
                const alpha = Math.min(1, d / 255);

                // Material-specific colors with very distinct appearances
                switch(this.material) {
                    case 'water':
                        // Clear blue water with cyan highlights
                        const waterBlue = Math.floor(150 + (d / 255) * 105);
                        const waterGreen = Math.floor(100 + (d / 255) * 100);
                        return `rgba(30, ${waterGreen}, ${waterBlue}, ${alpha * 0.7})`;

                    case 'smoke':
                        // Gray smoke with slight transparency
                        const smokeGray = Math.floor(100 + (d / 255) * 155);
                        return `rgba(${smokeGray}, ${smokeGray}, ${smokeGray + 20}, ${alpha * 0.5})`;

                    case 'ink':
                        // Vibrant rainbow colors based on density
                        const inkHue = (d / 255) * 360;
                        return `hsla(${inkHue}, 100%, 60%, ${alpha * 0.9})`;

                    case 'honey':
                        // Golden/amber honey color
                        const honeyR = Math.floor(200 + (d / 255) * 55);
                        const honeyG = Math.floor(140 + (d / 255) * 50);
                        const honeyB = Math.floor(20 + (d / 255) * 20);
                        return `rgba(${honeyR}, ${honeyG}, ${honeyB}, ${alpha * 0.85})`;

                    case 'gas':
                        // Light green/yellow gas
                        const gasR = Math.floor(150 + (d / 255) * 80);
                        const gasG = Math.floor(200 + (d / 255) * 55);
                        const gasB = Math.floor(100 + (d / 255) * 60);
                        return `rgba(${gasR}, ${gasG}, ${gasB}, ${alpha * 0.4})`;

                    default:
                        return `rgba(${d}, ${d * 0.5}, ${255 - d}, ${d / 255})`;
                }
            }

            render(ctx) {
                // Background color based on material
                switch(this.material) {
                    case 'water':
                        ctx.fillStyle = '#001020'; // Deep blue-black
                        break;
                    case 'smoke':
                        ctx.fillStyle = '#0a0a0a'; // Dark gray
                        break;
                    case 'honey':
                        ctx.fillStyle = '#1a0f00'; // Dark brown
                        break;
                    case 'gas':
                        ctx.fillStyle = '#0a1008'; // Dark greenish
                        break;
                    default:
                        ctx.fillStyle = '#000';
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw fluid density with glow effect for some materials
                const needsGlow = (this.material === 'gas' || this.material === 'smoke');

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const d = this.density[i][j];
                        if (d > 0) {
                            ctx.fillStyle = this.getColor(d);

                            // Add glow effect for smoke and gas
                            if (needsGlow && d > 50) {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.getColor(d);
                            } else {
                                ctx.shadowBlur = 0;
                            }

                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                ctx.shadowBlur = 0;

                // Draw obstacles
                ctx.fillStyle = '#666';
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.obstacles[i][j] === 1) {
                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                // Draw velocity field
                if (this.showVelocity) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;

                    const step = 4; // Show every 4th cell
                    for (let i = 0; i < this.rows; i += step) {
                        for (let j = 0; j < this.cols; j += step) {
                            const vx = this.vx[i][j];
                            const vy = this.vy[i][j];
                            const mag = Math.sqrt(vx * vx + vy * vy);

                            if (mag > 0.1) {
                                const x = j * this.scale + this.scale / 2;
                                const y = i * this.scale + this.scale / 2;
                                const scale = 5;

                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + vx * scale, y + vy * scale);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
        }

        const fluid = new FluidGrid(canvas.width, canvas.height, 8);

        // Initialize canvas with black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let addingObstacles = false;
        let continuousSource = false;
        let sourceX = canvas.width / 2;
        let sourceY = 50;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            prevMouseX = e.clientX - rect.left;
            prevMouseY = e.clientY - rect.top;

            if (addingObstacles) {
                fluid.addObstacle(prevMouseX, prevMouseY);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (addingObstacles) {
                    fluid.addObstacle(x, y);
                } else {
                    const vx = (x - prevMouseX) * 10;
                    const vy = (y - prevMouseY) * 10;

                    fluid.addDensity(x, y, 200);
                    fluid.addVelocity(x, y, vx, vy);
                }

                prevMouseX = x;
                prevMouseY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // ===================================
        // PRESET BUTTONS
        // ===================================

        document.getElementById('btnWater').addEventListener('click', () => {
            fluid.visc = 0.0001;
            fluid.diff = 0.0001;
            fluid.fadeRate = 0.99;
            fluid.material = 'water';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üíß Water - Clear blue liquid, low viscosity');
        });

        document.getElementById('btnSmoke').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.0005;
            fluid.fadeRate = 0.97;
            fluid.material = 'smoke';
            fluid.windY = -0.8; // Strong upward buoyancy
            updateSliders();
            updateInfo('üí® Smoke - Gray wisps that rise upward with buoyancy');
        });

        document.getElementById('btnInk').addEventListener('click', () => {
            fluid.visc = 0.0002;
            fluid.diff = 0.0003;
            fluid.fadeRate = 0.995;
            fluid.material = 'ink';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üñãÔ∏è Ink - Vibrant rainbow colors, medium viscosity');
        });

        document.getElementById('btnHoney').addEventListener('click', () => {
            fluid.visc = 0.0015;
            fluid.diff = 0.00003;
            fluid.fadeRate = 0.999;
            fluid.material = 'honey';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üçØ Honey - Golden amber, very thick and viscous');
        });

        document.getElementById('btnGas').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.001;
            fluid.fadeRate = 0.94;
            fluid.material = 'gas';
            fluid.windY = -0.3;
            updateSliders();
            updateInfo('‚òÅÔ∏è Gas - Light green/yellow, disperses quickly');
        });

        // ===================================
        // FEATURE BUTTONS
        // ===================================

        document.getElementById('btnVelocity').addEventListener('click', () => {
            fluid.showVelocity = !fluid.showVelocity;
            updateInfo(fluid.showVelocity ? 'Velocity field shown' : 'Velocity field hidden');
        });

        document.getElementById('btnAddObstacle').addEventListener('click', () => {
            addingObstacles = !addingObstacles;
            updateInfo(addingObstacles ? 'Click canvas to add obstacles' : 'Obstacle mode disabled');
        });

        document.getElementById('btnClearObstacles').addEventListener('click', () => {
            fluid.clearObstacles();
            updateInfo('Obstacles cleared');
        });

        document.getElementById('btnContinuousSource').addEventListener('click', () => {
            continuousSource = !continuousSource;
            updateInfo(continuousSource ? 'Continuous source enabled at top center' : 'Continuous source disabled');
        });

        document.getElementById('btnWind').addEventListener('click', () => {
            if (fluid.windY === 0) {
                fluid.windY = -0.5;
                updateInfo('Wind enabled - Upward force');
            } else {
                fluid.windY = 0;
                updateInfo('Wind disabled');
            }
        });

        // ===================================
        // COLOR MODE BUTTONS
        // ===================================

        document.getElementById('btnColorDefault').addEventListener('click', () => {
            fluid.material = 'water';
            updateInfo('Material changed to Water (blue)');
        });

        document.getElementById('btnColorRainbow').addEventListener('click', () => {
            fluid.material = 'ink';
            updateInfo('Material changed to Ink (rainbow)');
        });

        document.getElementById('btnColorFire').addEventListener('click', () => {
            fluid.material = 'honey';
            updateInfo('Material changed to Honey (golden/amber)');
        });

        document.getElementById('btnColorBlue').addEventListener('click', () => {
            fluid.material = 'gas';
            updateInfo('Material changed to Gas (green/yellow)');
        });

        document.getElementById('btnClearFluid').addEventListener('click', () => {
            fluid.density = fluid.createGrid();
            fluid.vx = fluid.createGrid();
            fluid.vy = fluid.createGrid();
            fluid.windX = 0;
            fluid.windY = 0;
            continuousSource = false;
            updateInfo('Fluid cleared');
        });

        // ===================================
        // SLIDERS
        // ===================================

        const viscSlider = document.getElementById('viscSlider');
        const viscValue = document.getElementById('viscValue');
        const diffSlider = document.getElementById('diffSlider');
        const diffValue = document.getElementById('diffValue');
        const fadeSlider = document.getElementById('fadeSlider');
        const fadeValue = document.getElementById('fadeValue');

        viscSlider.addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            viscValue.textContent = fluid.visc.toFixed(4);
        });

        diffSlider.addEventListener('input', (e) => {
            fluid.diff = parseFloat(e.target.value);
            diffValue.textContent = fluid.diff.toFixed(4);
        });

        fadeSlider.addEventListener('input', (e) => {
            fluid.fadeRate = parseFloat(e.target.value);
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        });

        function updateSliders() {
            viscSlider.value = fluid.visc;
            viscValue.textContent = fluid.visc.toFixed(4);
            diffSlider.value = fluid.diff;
            diffValue.textContent = fluid.diff.toFixed(4);
            fadeSlider.value = fluid.fadeRate;
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        }

        function updateInfo(message) {
            document.getElementById('fluidInfo').textContent = message;
        }

        function animate() {
            // Add continuous source if enabled
            if (continuousSource) {
                fluid.addDensity(sourceX, sourceY, 100);
                fluid.addVelocity(sourceX, sourceY, 0, 2);
            }

            fluid.step();
            fluid.render(ctx);
            requestAnimationFrame(animate);
        }

        animate();
        } // End canvas check
    </script>
</body>
</html>
