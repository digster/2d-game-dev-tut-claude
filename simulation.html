<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üåä Simulation Systems</h1>
        <p class="subtitle">Advanced simulation techniques - Fluids, cloth, and realistic effects</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="expert.html" class="nav-button">Expert</a>
            <a href="simulation.html" class="nav-button active">Simulation</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#fluid-dynamics">Fluid Dynamics Simulation (Grid-Based)</a></li>
                <li><a href="#game-mechanics">Fluid Dynamics as Game Mechanics</a>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><a href="#game-mechanics">‚Üí Water Buoyancy & Floating Objects</a></li>
                        <li><a href="#game-mechanics">‚Üí Rising Water Challenge (Platformer)</a></li>
                        <li><a href="#game-mechanics">‚Üí Particle-Based Water (SPH)</a></li>
                        <li><a href="#game-mechanics">‚Üí Flow Direction & Collection</a></li>
                    </ul>
                </li>
                <li><a href="#wind-weather">Wind & Weather Systems</a></li>
                <li><a href="#destructible-terrain">Destructible Terrain</a></li>
                <li><a href="#thermal-simulation">Thermal Simulation</a></li>
            </ul>
        </div>

        <!-- FLUID DYNAMICS -->
        <div id="fluid-dynamics" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåä Fluid Dynamics Simulation</h2>

            <div class="concept-box">
                <h4>What is Fluid Simulation?</h4>
                <p>Fluid simulation recreates the behavior of liquids and gases - water splashing, smoke rising, or fire spreading. In games, we often use simplified models that look realistic without the massive computational cost of real physics.</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Instead of simulating individual water molecules, we divide space into a grid and calculate how properties like velocity, pressure, and density flow between neighboring cells.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Fluids Work: The Basics</h4>
                <p>Real fluids follow the <strong>Navier-Stokes equations</strong>, but don't worry - we'll break this down into simple concepts!</p>

                <ul>
                    <li><strong>Advection:</strong> Fluid carries things along with it (like a river carrying a leaf)</li>
                    <li><strong>Diffusion:</strong> Properties spread out over time (like ink dispersing in water)</li>
                    <li><strong>Pressure:</strong> Fluid pushes away from high-pressure areas</li>
                    <li><strong>Incompressibility:</strong> Liquid volume stays constant (water doesn't compress)</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Fluid Grid Setup</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Fluid simulation grid</span>
<span class="keyword">class</span> <span class="function">FluidGrid</span> {
    <span class="keyword">constructor</span>(width, height, scale) {
        <span class="keyword">this</span>.cols = Math.<span class="function">floor</span>(width / scale);
        <span class="keyword">this</span>.rows = Math.<span class="function">floor</span>(height / scale);
        <span class="keyword">this</span>.scale = scale;

        <span class="comment">// Create grids for velocity (in X and Y directions)</span>
        <span class="keyword">this</span>.vx = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Previous velocity (for stability)</span>
        <span class="keyword">this</span>.vx0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Density (for visualization - like dye in water)</span>
        <span class="keyword">this</span>.density = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.density0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
    }

    <span class="function">createGrid</span>() {
        <span class="keyword">const</span> grid = [];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
            grid[i] = <span class="keyword">new</span> <span class="function">Array</span>(<span class="keyword">this</span>.cols).<span class="function">fill</span>(<span class="number">0</span>);
        }
        <span class="keyword">return</span> grid;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Diffusion (Spreading)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Diffusion spreads values to neighbors
// Like heat spreading through metal or ink dispersing in water</span>
<span class="function">diffuse</span>(x, x0, diffusion, dt) {
    <span class="keyword">const</span> a = dt * diffusion * <span class="keyword">this</span>.cols * <span class="keyword">this</span>.rows;

    <span class="comment">// Gauss-Seidel iteration for stability</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                <span class="comment">// Average with neighbors, weighted by diffusion rate</span>
                x[i][j] = (x0[i][j] + a * (
                    x[i - <span class="number">1</span>][j] + x[i + <span class="number">1</span>][j] +
                    x[i][j - <span class="number">1</span>] + x[i][j + <span class="number">1</span>]
                )) / (<span class="number">1</span> + <span class="number">4</span> * a);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Diffusion:</h4>
                    <p>Think of a drop of food coloring in water. It starts concentrated, then slowly spreads out. Each cell shares a bit of its "stuff" with neighbors. The <code>diffusion</code> parameter controls how fast this happens.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Advection (Flow)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Advection moves values along the velocity field
// Like a river carrying leaves downstream</span>
<span class="function">advect</span>(d, d0, vx, vy, dt) {
    <span class="keyword">const</span> dt0 = dt * <span class="keyword">this</span>.cols;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            <span class="comment">// Trace backwards along velocity</span>
            <span class="keyword">let</span> x = j - dt0 * vx[i][j];
            <span class="keyword">let</span> y = i - dt0 * vy[i][j];

            <span class="comment">// Clamp to grid boundaries</span>
            x = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.cols - <span class="number">1.5</span>, x));
            y = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.rows - <span class="number">1.5</span>, y));

            <span class="comment">// Interpolate between grid cells</span>
            <span class="keyword">const</span> i0 = Math.<span class="function">floor</span>(y);
            <span class="keyword">const</span> i1 = i0 + <span class="number">1</span>;
            <span class="keyword">const</span> j0 = Math.<span class="function">floor</span>(x);
            <span class="keyword">const</span> j1 = j0 + <span class="number">1</span>;

            <span class="keyword">const</span> s1 = x - j0;
            <span class="keyword">const</span> s0 = <span class="number">1</span> - s1;
            <span class="keyword">const</span> t1 = y - i0;
            <span class="keyword">const</span> t0 = <span class="number">1</span> - t1;

            <span class="comment">// Bilinear interpolation</span>
            d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                      s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Advection:</h4>
                    <p>Imagine you drop dye in a moving river. The dye doesn't just sit there - it flows with the water. Advection does this: for each cell, we look backward along the velocity to see where the fluid came from, then bring that value forward.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Pressure & Incompressibility</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Project removes divergence (ensures fluid is incompressible)
// This is what makes fluid behave like liquid, not gas</span>
<span class="function">project</span>(vx, vy, p, div) {
    <span class="comment">// Calculate divergence (how much fluid is leaving each cell)</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            div[i][j] = -<span class="number">0.5</span> * (
                vx[i][j + <span class="number">1</span>] - vx[i][j - <span class="number">1</span>] +
                vy[i + <span class="number">1</span>][j] - vy[i - <span class="number">1</span>][j]
            ) / <span class="keyword">this</span>.cols;
            p[i][j] = <span class="number">0</span>;
        }
    }

    <span class="comment">// Solve for pressure using iterative method</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                p[i][j] = (div[i][j] +
                    p[i - <span class="number">1</span>][j] + p[i + <span class="number">1</span>][j] +
                    p[i][j - <span class="number">1</span>] + p[i][j + <span class="number">1</span>]
                ) / <span class="number">4</span>;
            }
        }
    }

    <span class="comment">// Subtract pressure gradient from velocity</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            vx[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i][j + <span class="number">1</span>] - p[i][j - <span class="number">1</span>]);
            vy[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i + <span class="number">1</span>][j] - p[i - <span class="number">1</span>][j]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pressure:</h4>
                    <p>Water doesn't compress easily. If too much water flows into a cell, pressure builds up and pushes it out to neighbors. This step ensures the simulation stays physically plausible - the same amount of fluid stays in the system.</p>
                </div>
            </details>

            <details data-demo-id="fluid" data-deps="clearCanvas">
                <summary>üìù Click to see: Complete Simulation Step</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Main simulation step - call this every frame</span>
<span class="function">step</span>(dt = <span class="number">0.016</span>) {
    <span class="keyword">const</span> visc = <span class="number">0.0001</span>;  <span class="comment">// Viscosity (thickness of fluid)</span>
    <span class="keyword">const</span> diff = <span class="number">0.0001</span>;  <span class="comment">// Diffusion rate</span>

    <span class="comment">// 1. Diffuse velocity (friction between fluid layers)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, visc, dt);
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, visc, dt);

    <span class="comment">// 2. Project (fix velocity to be incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 3. Advect velocity (velocity moves itself)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);

    <span class="comment">// 4. Project again (ensure still incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 5. Diffuse density (dye spreads out)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, diff, dt);

    <span class="comment">// 6. Advect density (velocity carries dye along)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, <span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, dt);

    <span class="comment">// 7. Fade density over time (optional, for visual effect)</span>
    <span class="keyword">this</span>.<span class="function">fadeDensity</span>(<span class="number">0.99</span>);
}

<span class="function">fadeDensity</span>(fadeRate) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++) {
            <span class="keyword">this</span>.density[i][j] *= fadeRate;
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Fluid Simulation</h3>
            <div class="example-box">
                <strong>üñ±Ô∏è How to Use:</strong> Click and drag on the canvas below to add fluid and watch it flow! Try different presets and features below.
            </div>
            <div class="diagram">
                <canvas id="fluidDemo" width="800" height="600" style="border: 1px solid #444;"></canvas>
            </div>

            <div class="controls" style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px;">
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Presets:</strong>
                    <button id="btnWater">üíß Water</button>
                    <button id="btnSmoke">üí® Smoke</button>
                    <button id="btnInk">üñãÔ∏è Ink</button>
                    <button id="btnHoney">üçØ Honey</button>
                    <button id="btnGas">‚òÅÔ∏è Gas</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Features:</strong>
                    <button id="btnVelocity">Show Velocity Field</button>
                    <button id="btnAddObstacle">Add Obstacle (Click Canvas)</button>
                    <button id="btnClearObstacles">Clear Obstacles</button>
                    <button id="btnContinuousSource">Continuous Source</button>
                    <button id="btnWind">Toggle Wind</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Quick Switch:</strong>
                    <button id="btnColorDefault">üíß Water</button>
                    <button id="btnColorRainbow">üåà Ink</button>
                    <button id="btnColorFire">üçØ Honey</button>
                    <button id="btnColorBlue">‚òÅÔ∏è Gas</button>
                    <button id="btnClearFluid">üóëÔ∏è Clear All</button>
                </div>

                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <label>
                        Viscosity: <input type="range" id="viscSlider" min="0" max="0.002" step="0.0001" value="0.0001">
                        <span id="viscValue">0.0001</span>
                    </label>
                    <label>
                        Diffusion: <input type="range" id="diffSlider" min="0" max="0.001" step="0.0001" value="0.0001">
                        <span id="diffValue">0.0001</span>
                    </label>
                    <label>
                        Fade Rate: <input type="range" id="fadeSlider" min="0.9" max="1" step="0.01" value="0.99">
                        <span id="fadeValue">0.99</span>
                    </label>
                </div>
            </div>

            <div class="info-display" id="fluidInfo" style="margin-top: 10px;">
                Current Mode: Free Draw | Click and drag to add fluid
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üé® Try These Examples (Each Material Looks Completely Different!):</h4>
                <ol>
                    <li><strong>üíß Water (Clear Blue):</strong> Flows freely with a cyan-blue transparent appearance. Great for water effects!</li>
                    <li><strong>üí® Smoke (Gray Wisps):</strong> Soft gray with glow effect that rises upward. Click "Continuous Source" to see it billow!</li>
                    <li><strong>üñãÔ∏è Ink (Rainbow Colors):</strong> Vibrant multicolored fluid that creates beautiful psychedelic patterns</li>
                    <li><strong>üçØ Honey (Golden Amber):</strong> Rich golden color, very thick and viscous - watch it pour slowly!</li>
                    <li><strong>‚òÅÔ∏è Gas (Green-Yellow):</strong> Light greenish with glow, disperses quickly and rises slightly</li>
                    <li><strong>Add Obstacles:</strong> Try any material with obstacles to see realistic flow patterns!</li>
                </ol>
            </div>

            <div class="example-box" style="margin-top: 20px;">
                <h4>‚öôÔ∏è Understanding the Parameters:</h4>
                <ul>
                    <li><strong>Viscosity:</strong> How "thick" the fluid is
                        <ul>
                            <li>Low (0.00001) = Water, gas - flows freely</li>
                            <li>High (0.001) = Honey, syrup - very thick and slow</li>
                        </ul>
                    </li>
                    <li><strong>Diffusion:</strong> How fast properties spread out
                        <ul>
                            <li>Low = Fluid stays concentrated</li>
                            <li>High = Fluid disperses quickly like smoke or gas</li>
                        </ul>
                    </li>
                    <li><strong>Fade Rate:</strong> How quickly density disappears
                        <ul>
                            <li>0.95 = Fades very quickly (good for gas effects)</li>
                            <li>0.999 = Stays visible for a long time (good for permanent liquids)</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üéØ Visual Features & Material Properties:</h4>
                <ul>
                    <li><strong>Material-Specific Colors:</strong> Each material has unique colors, transparency, and background
                        <ul>
                            <li>üíß <strong>Water:</strong> Cyan-blue on dark blue background (70% opacity)</li>
                            <li>üí® <strong>Smoke:</strong> Soft gray with glow effect on dark gray bg (50% opacity)</li>
                            <li>üñãÔ∏è <strong>Ink:</strong> Rainbow gradient on black background (90% opacity)</li>
                            <li>üçØ <strong>Honey:</strong> Golden amber on brown background (85% opacity)</li>
                            <li>‚òÅÔ∏è <strong>Gas:</strong> Green-yellow with glow on greenish bg (40% opacity)</li>
                        </ul>
                    </li>
                    <li><strong>Velocity Field:</strong> White arrows showing fluid movement direction and speed</li>
                    <li><strong>Obstacles:</strong> Gray barriers that create realistic flow patterns around them</li>
                    <li><strong>Continuous Source:</strong> Constant fluid stream from top center</li>
                    <li><strong>Wind/Buoyancy:</strong> Upward force (automatic for smoke and gas)</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üéÆ Game Usage:</strong> Fluid simulation is perfect for water effects, smoke, fire, magic spells, and atmospheric effects. Adjust grid resolution for performance - smaller grids run faster but look less detailed.
            </div>

            <div class="example-box">
                <h4>‚ö° Performance Tips:</h4>
                <ul>
                    <li><strong>Grid Size:</strong> Use smaller grids (32x32 or 64x64) for real-time games</li>
                    <li><strong>Iterations:</strong> Reduce iteration count (10-15) if too slow</li>
                    <li><strong>GPU:</strong> Consider WebGL shaders for large simulations</li>
                    <li><strong>Hybrid:</strong> Combine simple particle systems with fluid for best visual/performance ratio</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>üìö Further Reading:</h4>
                <ul>
                    <li><strong>Navier-Stokes Equations:</strong> The full physics of fluid motion</li>
                    <li><strong>Jos Stam's "Stable Fluids":</strong> The paper this technique is based on</li>
                    <li><strong>SPH (Smoothed Particle Hydrodynamics):</strong> Alternative particle-based approach</li>
                    <li><strong>Level Set Methods:</strong> For tracking fluid surfaces</li>
                </ul>
            </div>
        </div>

        <!-- GAME MECHANICS DEMOS -->
        <div id="game-mechanics" class="section">
            <h2>üéÆ Fluid Dynamics as Game Mechanics</h2>
            <p>Let's see how fluid simulation translates into actual playable game mechanics!</p>

            <!-- Demo 1: Water Buoyancy -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>1. üåä Water Buoyancy & Floating Objects</h3>
                <p>Objects float or sink based on their density. This is used in games for boats, swimming mechanics, and physics puzzles.</p>

                <details data-demo-id="buoyancy" data-deps="vector2d,clearCanvas,randomFloat">
                    <summary>üìù Click to see: Buoyancy Force Calculation</summary>
                    <div class="code-container">
                        <pre><code><span class="comment">// Apply buoyancy force to objects in water</span>
<span class="keyword">function</span> <span class="function">applyBuoyancy</span>(object, waterLevel) {
    <span class="comment">// Calculate how much of object is submerged</span>
    <span class="keyword">const</span> objectBottom = object.y + object.height / <span class="number">2</span>;
    <span class="keyword">const</span> objectTop = object.y - object.height / <span class="number">2</span>;

    <span class="keyword">if</span> (objectBottom &gt; waterLevel) {
        <span class="comment">// Calculate submerged percentage (0 to 1)</span>
        <span class="keyword">let</span> submergedHeight = objectBottom - waterLevel;
        <span class="keyword">if</span> (objectTop &lt; waterLevel) {
            submergedHeight = object.height;
        }
        <span class="keyword">const</span> submergedPercent = submergedHeight / object.height;

        <span class="comment">// Buoyancy force = (water density - object density) * submerged volume * gravity</span>
        <span class="comment">// Simplified: use density ratio for force calculation</span>
        <span class="keyword">const</span> waterDensity = <span class="number">1.0</span>;
        <span class="keyword">const</span> buoyancyForce = (waterDensity - object.density) * submergedPercent * <span class="number">0.5</span>;

        <span class="comment">// Apply upward buoyancy force</span>
        object.vy += buoyancyForce;

        <span class="comment">// Water drag (resistance)</span>
        object.vx *= <span class="number">0.95</span>;
        object.vy *= <span class="number">0.98</span>;
    }
}</code></pre>
                    </div>

                    <div class="example-box">
                        <h4>üí° Understanding Buoyancy:</h4>
                        <p>Buoyancy is an upward force that acts on objects in fluid. If an object's density is less than water (< 1.0), it floats. If it's greater, it sinks. The force depends on how much of the object is submerged. This is Archimedes' principle in action!</p>
                    </div>
                </details>

                <div class="diagram">
                    <canvas id="buoyancyDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddBox">Add Box (Floats)</button>
                    <button id="btnAddStone">Add Stone (Sinks)</button>
                    <button id="btnAddBall">Add Ball (Bounces)</button>
                    <button id="btnDrain">Drain Water</button>
                    <button id="btnFill">Fill Water</button>
                    <button id="btnResetBuoyancy">Reset</button>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to drop objects! Lighter objects float, heavier ones sink. Watch buoyancy forces in action!
                </div>
            </div>

            <!-- Demo 2: Rising Water Level -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>2. ‚è´ Rising Water Challenge</h3>
                <p>Classic escape mechanic - water rises and the player must climb to safety! Used in platformers and puzzle games.</p>

                <details data-demo-id="risingWater" data-deps="vector2d,clearCanvas">
                    <summary>üìù Click to see: Rising Water & Player Movement Code</summary>
                    <div class="code-container">
                        <pre><code><span class="comment">// Rising water challenge mechanics</span>
<span class="keyword">let</span> waterLevel = canvas.height;
<span class="keyword">let</span> waterRising = <span class="keyword">false</span>;
<span class="keyword">const</span> waterRiseSpeed = <span class="number">0.5</span>;

<span class="comment">// Update water level</span>
<span class="keyword">function</span> <span class="function">updateWater</span>() {
    <span class="keyword">if</span> (waterRising &amp;&amp; waterLevel &gt; <span class="number">0</span>) {
        waterLevel -= waterRiseSpeed; <span class="comment">// Water rises (Y decreases upward)</span>
    }

    <span class="comment">// Check if player is caught by water</span>
    <span class="keyword">if</span> (player.y &gt;= waterLevel) {
        <span class="comment">// Game over - player drowns!</span>
        gameOver = <span class="keyword">true</span>;
    }
}

<span class="comment">// Player movement in water</span>
<span class="keyword">function</span> <span class="function">updatePlayer</span>() {
    <span class="comment">// Apply gravity</span>
    player.vy += gravity;

    <span class="comment">// Check if player is in water</span>
    <span class="keyword">if</span> (player.y + player.height / <span class="number">2</span> &gt; waterLevel) {
        <span class="comment">// Reduce speed in water (water resistance)</span>
        player.vx *= <span class="number">0.8</span>;
        player.vy *= <span class="number">0.8</span>;

        <span class="comment">// Apply buoyancy (slight upward force)</span>
        player.vy -= <span class="number">0.3</span>;
    }

    <span class="comment">// Apply velocity</span>
    player.x += player.vx;
    player.y += player.vy;
}</code></pre>
                    </div>

                    <div class="example-box">
                        <h4>üí° Understanding Rising Water Mechanics:</h4>
                        <p>This creates tension in games! The water rises at a constant rate, while the player moves slower in water. The key is balancing water rise speed with platform placement to create challenging but fair gameplay.</p>
                    </div>
                </details>

                <div class="diagram">
                    <canvas id="risingWaterDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnStartRising">Start Water Rising</button>
                    <button id="btnStopRising">Stop</button>
                    <button id="btnResetRising">Reset Level</button>
                    <span style="margin-left: 20px;">Use Arrow Keys to move the player</span>
                </div>
                <div class="info-display" id="risingWaterInfo" style="margin-top: 10px;">
                    Climb the platforms before the water reaches you! Player moves slower in water.
                </div>
            </div>

            <!-- Demo 3: Particle-Based Water (SPH) -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>3. üíß Particle-Based Water (SPH)</h3>
                <p>Smoothed Particle Hydrodynamics - each water particle interacts with neighbors. Great for splash effects and destructible water.</p>

                <details data-demo-id="sph" data-deps="vector2d,clearCanvas,randomFloat">
                    <summary>üìù Click to see: SPH Particle Interaction Code</summary>
                    <div class="code-container">
                        <pre><code><span class="comment">// SPH - Smoothed Particle Hydrodynamics</span>
<span class="keyword">const</span> smoothingRadius = <span class="number">30</span>; <span class="comment">// How far particles interact</span>
<span class="keyword">const</span> restDensity = <span class="number">1.0</span>;    <span class="comment">// Target density (how tightly packed)</span>
<span class="keyword">const</span> stiffness = <span class="number">0.1</span>;      <span class="comment">// How strongly particles push apart</span>

<span class="comment">// Update each particle</span>
<span class="keyword">function</span> <span class="function">updateSPHParticles</span>() {
    particles.<span class="function">forEach</span>(p =&gt; {
        <span class="comment">// Find nearby particles</span>
        <span class="keyword">let</span> density = <span class="number">0</span>;
        <span class="keyword">let</span> pressureForceX = <span class="number">0</span>;
        <span class="keyword">let</span> pressureForceY = <span class="number">0</span>;

        particles.<span class="function">forEach</span>(neighbor =&gt; {
            <span class="keyword">if</span> (p === neighbor) <span class="keyword">return</span>;

            <span class="keyword">const</span> dx = neighbor.x - p.x;
            <span class="keyword">const</span> dy = neighbor.y - p.y;
            <span class="keyword">const</span> dist = Math.<span class="function">sqrt</span>(dx * dx + dy * dy);

            <span class="keyword">if</span> (dist &lt; smoothingRadius) {
                <span class="comment">// Smoothing kernel - particles closer = stronger influence</span>
                <span class="keyword">const</span> influence = <span class="number">1</span> - dist / smoothingRadius;
                density += influence;

                <span class="comment">// Pressure force pushes particles apart</span>
                <span class="keyword">const</span> pressure = (density - restDensity) * stiffness;
                pressureForceX -= (dx / dist) * pressure * influence;
                pressureForceY -= (dy / dist) * pressure * influence;
            }
        });

        <span class="comment">// Apply forces</span>
        p.vx += pressureForceX;
        p.vy += pressureForceY;

        <span class="comment">// Viscosity (water sticks together)</span>
        p.vx *= <span class="number">0.98</span>;
        p.vy *= <span class="number">0.98</span>;

        <span class="comment">// Gravity</span>
        p.vy += <span class="number">0.5</span>;

        <span class="comment">// Update position</span>
        p.x += p.vx;
        p.y += p.vy;
    });
}</code></pre>
                    </div>

                    <div class="example-box">
                        <h4>üí° Understanding SPH:</h4>
                        <p>SPH treats water as many independent particles. Each particle feels pressure from nearby particles - when too close, they push apart. This creates realistic water behavior: cohesion (sticking together), pressure, and splashing!</p>
                    </div>
                </details>

                <div class="diagram">
                    <canvas id="sphDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddWater">Add Water Particles</button>
                    <button id="btnAddBarrier">Add Barrier (Click Canvas)</button>
                    <button id="btnToggleGravity">Toggle Gravity</button>
                    <button id="btnResetSPH">Reset</button>
                    <label>
                        Viscosity: <input type="range" id="sphViscosity" min="0.1" max="1" step="0.1" value="0.5">
                        <span id="sphViscValue">0.5</span>
                    </label>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to add water particles. They attract each other and flow like real liquid!
                </div>
            </div>

            <!-- Demo 4: Flow-Based Puzzle -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>4. üß© Flow Direction Mechanic (Simplified)</h3>
                <p>Water flows downward but can be redirected. This demo shows the concept behind puzzle games like "Where's My Water?" - simplified for clarity.</p>

                <details data-demo-id="flowPuzzle" data-deps="vector2d,clearCanvas,randomFloat">
                    <summary>üìù Click to see: Particle Flow & Obstacle Detection</summary>
                    <div class="code-container">
                        <pre><code><span class="comment">// Simple particle-based water flow</span>
<span class="keyword">let</span> waterParticles = [];
<span class="keyword">let</span> obstacles = [];
<span class="keyword">let</span> bucket = { x: <span class="number">600</span>, y: <span class="number">400</span>, width: <span class="number">100</span>, height: <span class="number">60</span> };
<span class="keyword">let</span> collected = <span class="number">0</span>;

<span class="comment">// Update water particles</span>
<span class="keyword">function</span> <span class="function">updateFlowParticles</span>() {
    waterParticles.<span class="function">forEach</span>((p, index) =&gt; {
        <span class="comment">// Gravity pulls water down</span>
        p.vy += <span class="number">0.3</span>;

        <span class="comment">// Apply velocity</span>
        p.x += p.vx;
        p.y += p.vy;

        <span class="comment">// Check collision with obstacles</span>
        obstacles.<span class="function">forEach</span>(obs =&gt; {
            <span class="keyword">if</span> (p.x &gt; obs.x &amp;&amp; p.x &lt; obs.x + obs.width &amp;&amp;
                p.y &gt; obs.y &amp;&amp; p.y &lt; obs.y + obs.height) {
                <span class="comment">// Bounce off obstacle</span>
                p.vy *= -<span class="number">0.5</span>;
                p.vx += (Math.<span class="function">random</span>() - <span class="number">0.5</span>) * <span class="number">2</span>; <span class="comment">// Scatter sideways</span>
                p.y = obs.y - <span class="number">1</span>; <span class="comment">// Push out of obstacle</span>
            }
        });

        <span class="comment">// Check if particle reaches bucket</span>
        <span class="keyword">if</span> (p.x &gt; bucket.x &amp;&amp; p.x &lt; bucket.x + bucket.width &amp;&amp;
            p.y &gt; bucket.y &amp;&amp; p.y &lt; bucket.y + bucket.height) {
            collected++;
            waterParticles.<span class="function">splice</span>(index, <span class="number">1</span>); <span class="comment">// Remove collected particle</span>
        }

        <span class="comment">// Remove particles that fall off screen</span>
        <span class="keyword">if</span> (p.y &gt; canvas.height) {
            waterParticles.<span class="function">splice</span>(index, <span class="number">1</span>);
        }
    });
}</code></pre>
                    </div>

                    <div class="example-box">
                        <h4>üí° Understanding Flow Puzzles:</h4>
                        <p>The core mechanic: water particles follow physics (gravity + obstacles). Players place platforms/pipes to redirect flow. When particles reach the goal (bucket), they're collected. This creates puzzle gameplay about path planning!</p>
                    </div>
                </details>

                <div class="diagram">
                    <canvas id="flowPuzzleDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnRelease">Release Water</button>
                    <button id="btnAddPlatform">Add Platform (Blocks Water)</button>
                    <button id="btnResetPuzzle">Reset</button>
                    <span style="margin-left: 20px; font-weight: bold;" id="puzzleStatus">Watch water flow and collect</span>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click "Release Water" to start. Water flows down naturally and fills the bucket. Click "Add Platform" then click canvas to block water flow.
                </div>

                <div class="key-point" style="margin-top: 15px;">
                    <strong>üí° Implementation Note:</strong> Full pipe-routing puzzles require complex pathfinding logic. This simplified demo shows the core concept: water as particles that follow simple rules (gravity + obstacles). For production games, consider using:
                    <ul style="margin-top: 5px;">
                        <li>Grid-based flow fields for directing water</li>
                        <li>Waypoint systems for pipe networks</li>
                        <li>Simplified particle systems for visual effects</li>
                    </ul>
                </div>
            </div>

            <div class="key-point" style="margin-top: 30px;">
                <strong>üí° Design Tip:</strong> Different fluid representations work for different game types:
                <ul style="margin-top: 10px;">
                    <li><strong>Grid-based (Navier-Stokes):</strong> Best for atmospheric effects, smoke, gas - continuous fields</li>
                    <li><strong>Particle-based (SPH):</strong> Best for interactive water, splashes, destruction - discrete elements</li>
                    <li><strong>Simplified/Fake:</strong> Best for performance-critical games - rising water levels, flow direction only</li>
                </ul>
            </div>
        </div>

        <!-- WIND/WEATHER SYSTEMS -->
        <div id="wind-weather" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üå¨Ô∏è Wind & Weather Systems</h2>

            <div class="concept-box">
                <h4>What is a Wind System?</h4>
                <p>Wind systems simulate invisible forces that affect objects in your game world - like leaves blowing in the breeze, projectiles being deflected, or a character's cape flowing. In games like Zelda: Breath of the Wild or Genshin Impact, wind isn't just visual - it's a gameplay mechanic!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Wind is just a vector field - at every point in space, there's a force vector pushing objects in a direction. We can make this field dynamic, turbulent, and interactive to create realistic weather effects.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Wind Works</h4>
                <p>Think of wind as an invisible river of air flowing through your game world:</p>

                <ul>
                    <li><strong>Vector Field:</strong> Each point in space has a wind direction and strength</li>
                    <li><strong>Turbulence:</strong> Random fluctuations make wind feel natural, not mechanical</li>
                    <li><strong>Obstacles:</strong> Wind flows around objects and creates sheltered areas</li>
                    <li><strong>Gusts:</strong> Temporary increases in wind strength create dynamic effects</li>
                </ul>
            </div>

            <details data-demo-id="wind" data-deps="vector2d,clearCanvas,randomFloat">
                <summary>üìù Click to see: Wind Field Setup</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Wind field - grid-based vector field with turbulence</span>
<span class="keyword">const</span> windGridSize = <span class="number">20</span>;
<span class="keyword">const</span> windCols = Math.<span class="function">ceil</span>(canvas.width / windGridSize);
<span class="keyword">const</span> windRows = Math.<span class="function">ceil</span>(canvas.height / windGridSize);

<span class="keyword">let</span> windVectors = [];
<span class="keyword">let</span> windParticles = [];
<span class="keyword">let</span> windGusts = [];
<span class="keyword">let</span> windTime = <span class="number">0</span>;

<span class="comment">// Initialize wind field grid</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; windRows; i++) {
    windVectors[i] = [];
    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; windCols; j++) {
        windVectors[i][j] = { x: <span class="number">0</span>, y: <span class="number">0</span> };
    }
}

<span class="comment">// Create particles to visualize wind</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) {
    windParticles.<span class="function">push</span>({
        x: Math.<span class="function">random</span>() * canvas.width,
        y: Math.<span class="function">random</span>() * canvas.height,
        vx: <span class="number">0</span>,
        vy: <span class="number">0</span>,
        trail: []
    });
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Wind Grids:</h4>
                    <p>We divide space into a grid where each cell stores a wind vector (direction and strength). Particles interpolate between grid points for smooth movement. This is much more efficient than calculating wind for every particle individually!</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Wind Field Update with Turbulence</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Simple noise function for natural turbulence</span>
<span class="keyword">function</span> <span class="function">windNoise</span>(x, y, t) {
    <span class="keyword">const</span> n = Math.<span class="function">sin</span>(x * <span class="number">0.1</span> + t) * Math.<span class="function">cos</span>(y * <span class="number">0.1</span> + t * <span class="number">0.7</span>);
    <span class="keyword">return</span> n * <span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// Normalize to 0-1</span>
}

<span class="comment">// Update wind field each frame</span>
<span class="keyword">function</span> <span class="function">updateWindField</span>(dt) {
    windTime += dt * <span class="number">0.001</span>;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; windRows; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; windCols; j++) {
            <span class="comment">// Base wind direction (left to right)</span>
            <span class="keyword">let</span> wx = <span class="number">1</span> * windStrength;
            <span class="keyword">let</span> wy = <span class="number">0</span>;

            <span class="comment">// Add turbulence using noise</span>
            <span class="keyword">const</span> noiseX = <span class="function">windNoise</span>(j, i, windTime);
            <span class="keyword">const</span> noiseY = <span class="function">windNoise</span>(j + <span class="number">100</span>, i + <span class="number">100</span>, windTime);
            wx += (noiseX - <span class="number">0.5</span>) * turbulence * <span class="number">2</span>;
            wy += (noiseY - <span class="number">0.5</span>) * turbulence * <span class="number">2</span>;

            <span class="comment">// Add gust effects (temporary wind bursts)</span>
            <span class="keyword">const</span> x = j * windGridSize;
            <span class="keyword">const</span> y = i * windGridSize;
            <span class="keyword">for</span> (<span class="keyword">let</span> gust <span class="keyword">of</span> windGusts) {
                <span class="keyword">const</span> dx = x - gust.x;
                <span class="keyword">const</span> dy = y - gust.y;
                <span class="keyword">const</span> dist = Math.<span class="function">sqrt</span>(dx * dx + dy * dy);
                <span class="keyword">if</span> (dist &lt; gust.radius) {
                    <span class="keyword">const</span> influence = (<span class="number">1</span> - dist / gust.radius) * gust.strength;
                    <span class="keyword">const</span> angle = Math.<span class="function">atan2</span>(dy, dx);
                    wx += Math.<span class="function">cos</span>(angle) * influence;
                    wy += Math.<span class="function">sin</span>(angle) * influence;
                }
            }

            windVectors[i][j] = { x: wx, y: wy };
        }
    }

    <span class="comment">// Decay gusts over time</span>
    windGusts = windGusts.<span class="function">filter</span>(g =&gt; {
        g.strength *= <span class="number">0.95</span>;
        <span class="keyword">return</span> g.strength &gt; <span class="number">0.1</span>;
    });
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Turbulence:</h4>
                    <p>Natural wind isn't constant - it swirls and fluctuates. We use noise functions to add variation. Gusts are temporary circular forces that radiate outward, creating dramatic wind bursts when you click the canvas.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Particle Movement & Interpolation</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Get interpolated wind at any position (smooth between grid cells)</span>
<span class="keyword">function</span> <span class="function">getWindAt</span>(x, y) {
    <span class="keyword">const</span> gridX = x / windGridSize;
    <span class="keyword">const</span> gridY = y / windGridSize;
    <span class="keyword">const</span> i = Math.<span class="function">floor</span>(gridY);
    <span class="keyword">const</span> j = Math.<span class="function">floor</span>(gridX);

    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= windRows - <span class="number">1</span> || j &lt; <span class="number">0</span> || j &gt;= windCols - <span class="number">1</span>) {
        <span class="keyword">return</span> { x: <span class="number">0</span>, y: <span class="number">0</span> };
    }

    <span class="comment">// Bilinear interpolation between 4 grid points</span>
    <span class="keyword">const</span> fx = gridX - j;
    <span class="keyword">const</span> fy = gridY - i;
    <span class="keyword">const</span> v00 = windVectors[i][j];
    <span class="keyword">const</span> v10 = windVectors[i][j + <span class="number">1</span>];
    <span class="keyword">const</span> v01 = windVectors[i + <span class="number">1</span>][j];
    <span class="keyword">const</span> v11 = windVectors[i + <span class="number">1</span>][j + <span class="number">1</span>];

    <span class="keyword">const</span> wx = v00.x * (<span class="number">1</span> - fx) * (<span class="number">1</span> - fy) + v10.x * fx * (<span class="number">1</span> - fy) +
               v01.x * (<span class="number">1</span> - fx) * fy + v11.x * fx * fy;
    <span class="keyword">const</span> wy = v00.y * (<span class="number">1</span> - fx) * (<span class="number">1</span> - fy) + v10.y * fx * (<span class="number">1</span> - fy) +
               v01.y * (<span class="number">1</span> - fx) * fy + v11.y * fx * fy;

    <span class="keyword">return</span> { x: wx, y: wy };
}

<span class="comment">// Update particles based on wind</span>
<span class="keyword">function</span> <span class="function">updateWindParticles</span>() {
    windParticles.<span class="function">forEach</span>(p =&gt; {
        <span class="keyword">const</span> wind = <span class="function">getWindAt</span>(p.x, p.y);

        <span class="comment">// Apply wind force</span>
        p.vx += wind.x * <span class="number">0.5</span>;
        p.vy += wind.y * <span class="number">0.5</span>;

        <span class="comment">// Damping to prevent infinite acceleration</span>
        p.vx *= <span class="number">0.98</span>;
        p.vy *= <span class="number">0.98</span>;

        <span class="comment">// Move particle</span>
        p.x += p.vx;
        p.y += p.vy;

        <span class="comment">// Wrap around screen edges</span>
        <span class="keyword">if</span> (p.x &lt; <span class="number">0</span>) p.x = canvas.width;
        <span class="keyword">if</span> (p.x &gt; canvas.width) p.x = <span class="number">0</span>;
        <span class="keyword">if</span> (p.y &lt; <span class="number">0</span>) p.y = canvas.height;
        <span class="keyword">if</span> (p.y &gt; canvas.height) p.y = <span class="number">0</span>;
    });
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Bilinear Interpolation:</h4>
                    <p>Wind values are only stored at grid corners. For smooth motion, particles need wind values at ANY position. Bilinear interpolation blends the 4 nearest grid points based on distance. This is the same technique used for image scaling and texture mapping!</p>
                </div>
            </details>

            <!-- Interactive Demo: Wind Particles -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üçÉ Interactive Demo: Wind Field Visualization</h3>
                <p>Watch particles flow through a dynamic wind field! Click to create wind gusts.</p>

                <div class="diagram">
                    <canvas id="windCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <label>Wind Strength: <span id="windStrengthDisplay">1.0</span></label>
                    <input type="range" id="windStrengthSlider" min="0" max="3" step="0.1" value="1.0">
                    <label>Turbulence: <span id="turbulenceDisplay">0.5</span></label>
                    <input type="range" id="turbulenceSlider" min="0" max="2" step="0.1" value="0.5">
                    <button id="toggleWindVectors">Toggle Wind Vectors</button>
                    <button id="resetWindDemo">Reset</button>
                </div>
                <div class="info-display">
                    Click anywhere to create a wind gust! Watch particles flow with the wind.
                </div>
            </div>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li>Wind is a <strong>vector field</strong> - force at every point in space</li>
                    <li>Use <strong>noise functions</strong> for natural, flowing turbulence</li>
                    <li><strong>Grid-based calculation</strong> + interpolation = smooth, efficient wind</li>
                    <li><strong>Gusts</strong> add dynamic, interactive gameplay opportunities</li>
                    <li>Wind can be both <strong>aesthetic</strong> (particles, effects) and <strong>mechanical</strong> (gameplay)</li>
                </ul>
            </div>
        </div>

        <!-- DESTRUCTIBLE TERRAIN -->
        <div id="destructible-terrain" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üí• Destructible Terrain</h2>

            <div class="concept-box">
                <h4>What is Destructible Terrain?</h4>
                <p>Destructible terrain lets players break, dig, or reshape the game world. Think of games like Minecraft (block-based destruction), Worms (pixel-perfect terrain removal), or Red Faction (realistic structural damage). It's a powerful mechanic that gives players agency and creates emergent gameplay!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Represent terrain as a grid of cells or pixels. When something damages terrain, remove or modify those cells, then update physics and visuals accordingly. The challenge is making this fast and fun!
                </div>
            </div>

            <div class="concept-box">
                <h4>Three Approaches to Destructible Terrain</h4>

                <ul>
                    <li><strong>Grid/Voxel Based:</strong> World divided into blocks (like Minecraft)
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Fast collision detection</li>
                            <li>Easy to implement</li>
                            <li>Looks blocky unless cells are tiny</li>
                        </ul>
                    </li>
                    <li><strong>Pixel/Bitmap Based:</strong> Every pixel can be destroyed (like Worms)
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Smooth, organic destruction</li>
                            <li>Perfect for 2D games</li>
                            <li>More complex collision detection</li>
                        </ul>
                    </li>
                    <li><strong>Chunk/Region Based:</strong> Pre-made destructible pieces
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Controlled destruction (buildings collapsing)</li>
                            <li>Can look very realistic</li>
                            <li>Limited interactivity</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üéÆ Game Applications:</h4>
                <ul>
                    <li><strong>Mining/Digging games:</strong> Terraria, Dig Dug - core gameplay loop</li>
                    <li><strong>Strategy games:</strong> Worms, Scorched Earth - terrain affects tactics</li>
                    <li><strong>Puzzle games:</strong> Remove terrain to guide objects to goals</li>
                    <li><strong>Destruction games:</strong> Red Faction, Battlefield - environmental damage</li>
                    <li><strong>Platformers:</strong> Breakable floors, walls create shortcuts</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Terrain Initialization (Pixel-Based)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Use ImageData to store terrain at pixel level</span>
<span class="keyword">let</span> terrainImageData = ctx.<span class="function">createImageData</span>(canvas.width, canvas.height);
<span class="keyword">let</span> balls = [];

<span class="comment">// Initialize terrain with layered generation</span>
<span class="keyword">function</span> <span class="function">initTerrain</span>() {
    balls = [];
    terrainImageData = ctx.<span class="function">createImageData</span>(canvas.width, canvas.height);
    <span class="keyword">const</span> data = terrainImageData.data;

    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; canvas.height; y++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; canvas.width; x++) {
            <span class="keyword">const</span> idx = (y * canvas.width + x) * <span class="number">4</span>; <span class="comment">// RGBA = 4 bytes per pixel</span>

            <span class="comment">// Create layered terrain with noise</span>
            <span class="keyword">if</span> (y &gt; <span class="number">150</span> &amp;&amp; y &lt; <span class="number">450</span>) {
                <span class="keyword">const</span> noise = Math.<span class="function">sin</span>(x * <span class="number">0.05</span>) * <span class="number">10</span> + Math.<span class="function">cos</span>(y * <span class="number">0.03</span>) * <span class="number">5</span>;
                <span class="keyword">if</span> (y + noise &gt; <span class="number">200</span>) {
                    <span class="comment">// Dirt layer (brown)</span>
                    data[idx] = <span class="number">139</span>;     <span class="comment">// R</span>
                    data[idx + <span class="number">1</span>] = <span class="number">90</span>;  <span class="comment">// G</span>
                    data[idx + <span class="number">2</span>] = <span class="number">43</span>;  <span class="comment">// B</span>
                    data[idx + <span class="number">3</span>] = <span class="number">255</span>; <span class="comment">// A (fully opaque = solid terrain)</span>
                }
            }
        }
    }

    ctx.<span class="function">putImageData</span>(terrainImageData, <span class="number">0</span>, <span class="number">0</span>);
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pixel-Based Terrain:</h4>
                    <p>We use ImageData to directly manipulate pixels. Each pixel has 4 values (RGBA). The alpha channel (A) determines if a pixel is solid (255) or empty (0). This allows for smooth, organic destruction at the pixel level!</p>
                </div>
            </details>

            <details data-demo-id="terrain" data-deps="clearCanvas,randomFloat">
                <summary>üìù Click to see: Terrain Destruction</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Check if terrain exists at a position</span>
<span class="keyword">function</span> <span class="function">isTerrainAt</span>(x, y) {
    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= canvas.width || y &lt; <span class="number">0</span> || y &gt;= canvas.height) <span class="keyword">return</span> <span class="keyword">false</span>;
    <span class="keyword">const</span> idx = (Math.<span class="function">floor</span>(y) * canvas.width + Math.<span class="function">floor</span>(x)) * <span class="number">4</span>;
    <span class="keyword">return</span> terrainImageData.data[idx + <span class="number">3</span>] &gt; <span class="number">0</span>; <span class="comment">// Check alpha channel</span>
}

<span class="comment">// Destroy terrain in circular area</span>
<span class="keyword">function</span> <span class="function">destroyTerrain</span>(x, y, radius) {
    <span class="keyword">const</span> data = terrainImageData.data;

    <span class="comment">// Loop through square bounding box, check distance for circle</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> dy = -radius; dy &lt;= radius; dy++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> dx = -radius; dx &lt;= radius; dx++) {
            <span class="keyword">const</span> dist = Math.<span class="function">sqrt</span>(dx * dx + dy * dy);
            <span class="keyword">if</span> (dist &lt;= radius) {
                <span class="keyword">const</span> px = Math.<span class="function">floor</span>(x + dx);
                <span class="keyword">const</span> py = Math.<span class="function">floor</span>(y + dy);

                <span class="keyword">if</span> (px &gt;= <span class="number">0</span> &amp;&amp; px &lt; canvas.width &amp;&amp; py &gt;= <span class="number">0</span> &amp;&amp; py &lt; canvas.height) {
                    <span class="keyword">const</span> idx = (py * canvas.width + px) * <span class="number">4</span>;
                    data[idx + <span class="number">3</span>] = <span class="number">0</span>; <span class="comment">// Set alpha to 0 = transparent = destroyed</span>
                }
            }
        }
    }

    <span class="comment">// Update canvas with destroyed terrain</span>
    ctx.<span class="function">putImageData</span>(terrainImageData, <span class="number">0</span>, <span class="number">0</span>);
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Circular Destruction:</h4>
                    <p>We loop through a square area but only destroy pixels within the circular radius. Setting the alpha channel to 0 makes pixels transparent. This is much faster than recalculating terrain geometry!</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Physics Collision with Terrain</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Update physics balls</span>
<span class="keyword">function</span> <span class="function">updateBalls</span>() {
    balls.<span class="function">forEach</span>((ball, index) =&gt; {
        <span class="comment">// Apply gravity</span>
        ball.vy += <span class="number">0.5</span>;

        <span class="comment">// Move ball</span>
        ball.x += ball.vx;
        ball.y += ball.vy;

        <span class="comment">// Check collision with terrain at multiple points around ball</span>
        <span class="keyword">let</span> collided = <span class="keyword">false</span>;
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span>; i += <span class="number">30</span>) {
            <span class="keyword">const</span> angle = i * Math.PI / <span class="number">180</span>;
            <span class="keyword">const</span> checkX = ball.x + Math.<span class="function">cos</span>(angle) * ball.radius;
            <span class="keyword">const</span> checkY = ball.y + Math.<span class="function">sin</span>(angle) * ball.radius;

            <span class="keyword">if</span> (<span class="function">isTerrainAt</span>(checkX, checkY)) {
                collided = <span class="keyword">true</span>;
                <span class="comment">// Bounce with energy loss</span>
                ball.vy *= -<span class="number">0.5</span>;
                ball.vx *= <span class="number">0.9</span>;
                ball.y -= <span class="number">2</span>; <span class="comment">// Push out of terrain</span>
                <span class="keyword">break</span>;
            }
        }

        <span class="comment">// Remove balls that fall off screen</span>
        <span class="keyword">if</span> (ball.y &gt; canvas.height + <span class="number">50</span>) {
            balls.<span class="function">splice</span>(index, <span class="number">1</span>);
        }
    });
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pixel-Perfect Collision:</h4>
                    <p>We check 12 points around the ball's perimeter (every 30 degrees). If any point touches terrain (alpha > 0), we bounce. This is more accurate than simple circle collision and works with any terrain shape!</p>
                </div>
            </details>

            <!-- Interactive Demo: Destructible Terrain -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üí• Interactive Demo: Pixel-Based Destructible Terrain</h3>
                <p>Click and drag to destroy terrain! Drop balls to see physics interact with the destroyed areas.</p>

                <div class="diagram">
                    <canvas id="terrainCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <label>Explosion Size: <span id="explosionSizeDisplay">30</span></label>
                    <input type="range" id="explosionSizeSlider" min="10" max="80" step="5" value="30">
                    <button id="addBall">Drop Ball</button>
                    <button id="resetTerrain">Reset Terrain</button>
                </div>
                <div class="info-display">
                    Click and drag to destroy terrain! Watch physics objects interact with the destruction.
                </div>
            </div>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li><strong>Grid-based</strong> is easiest to implement and fastest for collision</li>
                    <li><strong>Pixel-based</strong> looks smoother but needs spatial partitioning for performance</li>
                    <li>Always <strong>update both visual and collision</strong> representations together</li>
                    <li><strong>Add particle effects</strong> when terrain breaks for satisfying feedback</li>
                    <li>Consider <strong>regrowth or repair</strong> mechanics to prevent terrain depletion</li>
                </ul>
            </div>
        </div>

        <!-- THERMAL SIMULATION -->
        <div id="thermal-simulation" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üî• Fire Spread & Material Burning</h2>

            <div class="concept-box">
                <h4>What is Fire Spread Simulation?</h4>
                <p>Fire spread simulation creates realistic fire propagation through different materials. Fire catches on flammable objects, spreads to neighbors, and burns materials over time. Games like Minecraft (fire mechanics), Don't Starve (forest fires), The Forest (survival fires), and Teardown (destructive fire) all use these systems!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Each grid cell contains a material type (wood, grass, stone, etc.) with properties like flammability, burn rate, and ignition temperature. Fire spreads from burning cells to nearby flammable neighbors, creating dynamic chain reactions!
                </div>
            </div>

            <div class="concept-box">
                <h4>How Fire Spread Works</h4>
                <p>Fire simulation combines multiple systems working together:</p>

                <ul>
                    <li><strong>Material States:</strong> Each cell can be: normal ‚Üí igniting ‚Üí burning ‚Üí burned out (ash)</li>
                    <li><strong>Heat Propagation:</strong> Burning cells heat neighbors, igniting flammable materials above their ignition point</li>
                    <li><strong>Burn Duration:</strong> Materials burn for different times - grass burns quickly, wood takes longer</li>
                    <li><strong>Spread Probability:</strong> Fire doesn't always spread - some materials resist better than others</li>
                    <li><strong>Particle Effects:</strong> Rising smoke and embers make fires look alive and dangerous</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üéÆ Game Applications:</h4>
                <ul>
                    <li><strong>Forest fire mechanics:</strong> Lightning strikes or campfires can ignite entire forests</li>
                    <li><strong>Destructible environments:</strong> Burn wooden structures to create new paths or remove obstacles</li>
                    <li><strong>Tactical gameplay:</strong> Set traps using fire to corral enemies or destroy their resources</li>
                    <li><strong>Survival challenges:</strong> Prevent fires from spreading to your base, or use controlled burns for land clearing</li>
                    <li><strong>Puzzle mechanics:</strong> Use fire to burn specific objects while protecting others with firebreaks</li>
                </ul>
            </div>

            <!-- Interactive Demo: Fire Spread -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üî• Interactive Demo: Fire Spread & Burning</h3>
                <p>Place materials and ignite fires! Watch realistic fire propagation with particle effects.</p>

                <div class="diagram">
                    <canvas id="thermalCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="placeMaterial" class="material-wood">Place Wood</button>
                    <button id="placeGrass">Place Grass</button>
                    <button id="placeStone">Place Stone</button>
                    <button id="placeWater">Place Water</button>
                    <button id="ignite">Ignite Fire</button>
                    <button id="resetThermal">Reset & Generate Terrain</button>
                </div>
                <div class="info-display">
                    <div><strong>Materials:</strong> üü´ Wood | üü© Grass | ‚¨ú Stone | üü¶ Water | üüß Fire | ‚¨õ Ash</div>
                    <div style="margin-top: 5px;"><strong>Tip:</strong> Wood burns slowly, Grass burns fast, Stone doesn't burn, Water stops fire!</div>
                </div>
            </div>

            <details>
                <summary>üìù Click to see: Material Properties Code</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Define material types with burning properties</span>
<span class="keyword">const</span> <span class="function">MATERIALS</span> = {
    EMPTY: { id: <span class="number">0</span>, flammable: <span class="keyword">false</span>, color: <span class="string">'#1a1a1a'</span> },
    WOOD: {
        id: <span class="number">1</span>,
        flammable: <span class="keyword">true</span>,
        ignitionTemp: <span class="number">200</span>,
        burnDuration: <span class="number">150</span>,  <span class="comment">// frames to burn</span>
        spreadChance: <span class="number">0.3</span>,
        color: <span class="string">'#8B4513'</span>
    },
    GRASS: {
        id: <span class="number">2</span>,
        flammable: <span class="keyword">true</span>,
        ignitionTemp: <span class="number">150</span>,
        burnDuration: <span class="number">60</span>,
        spreadChance: <span class="number">0.6</span>,  <span class="comment">// spreads faster</span>
        color: <span class="string">'#228B22'</span>
    },
    STONE: {
        id: <span class="number">3</span>,
        flammable: <span class="keyword">false</span>,
        color: <span class="string">'#808080'</span>
    },
    WATER: {
        id: <span class="number">4</span>,
        flammable: <span class="keyword">false</span>,
        extinguishes: <span class="keyword">true</span>,  <span class="comment">// stops fire</span>
        color: <span class="string">'#1E90FF'</span>
    }
};</code></pre>
                </div>
            </details>

            <details data-demo-id="thermal" data-deps="clearCanvas,randomFloat">
                <summary>üìù Click to see: Fire Spread Algorithm</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Check if fire should spread to neighboring cells</span>
<span class="function">spreadFire</span>(i, j) {
    <span class="keyword">const</span> neighbors = [
        [i-<span class="number">1</span>, j], [i+<span class="number">1</span>, j], [i, j-<span class="number">1</span>], [i, j+<span class="number">1</span>],
        [i-<span class="number">1</span>, j-<span class="number">1</span>], [i-<span class="number">1</span>, j+<span class="number">1</span>], [i+<span class="number">1</span>, j-<span class="number">1</span>], [i+<span class="number">1</span>, j+<span class="number">1</span>]
    ];

    <span class="keyword">for</span> (<span class="keyword">const</span> [ni, nj] <span class="keyword">of</span> neighbors) {
        <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= rows || nj &lt; <span class="number">0</span> || nj &gt;= cols) <span class="keyword">continue</span>;

        <span class="keyword">const</span> cell = grid[ni][nj];
        <span class="keyword">const</span> material = MATERIALS[cell.type];

        <span class="comment">// Only spread to flammable materials not already burning</span>
        <span class="keyword">if</span> (material.flammable && !cell.burning) {
            <span class="comment">// Heat the neighbor</span>
            cell.temperature += <span class="number">50</span>;

            <span class="comment">// Try to ignite based on temperature and spread chance</span>
            <span class="keyword">if</span> (cell.temperature &gt; material.ignitionTemp) {
                <span class="keyword">if</span> (Math.<span class="function">random</span>() &lt; material.spreadChance) {
                    cell.burning = <span class="keyword">true</span>;
                    cell.burnTime = <span class="number">0</span>;
                }
            }
        }

        <span class="comment">// Water extinguishes nearby fire</span>
        <span class="keyword">if</span> (material.extinguishes && cell.burning) {
            cell.burning = <span class="keyword">false</span>;
            cell.temperature = <span class="number">20</span>;
        }
    }
}</code></pre>
                </div>
            </details>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li>Each material has <strong>unique burning properties</strong> - ignition temp, burn duration, spread rate</li>
                    <li><strong>State machines</strong> manage transitions: normal ‚Üí igniting ‚Üí burning ‚Üí ash</li>
                    <li><strong>Probabilistic spread</strong> makes fire feel organic and unpredictable</li>
                    <li><strong>Particle systems</strong> (smoke, embers) enhance visual feedback</li>
                    <li>Combine materials strategically to create <strong>firebreaks and controlled burns</strong></li>
                </ul>
            </div>
        </div>

        <!-- Scroll to Top Button -->
        <div class="scroll-to-top" id="scrollToTop">‚Üë</div>
    </div>

    <!-- Export Demo Feature -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>

    <script>
        // Scroll to top functionality
        const scrollToTopBtn = document.getElementById('scrollToTop');

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.style.opacity = '1';
            } else {
                scrollToTopBtn.style.opacity = '0';
            }
        });

        scrollToTopBtn.style.opacity = '0';
        scrollToTopBtn.style.transition = 'opacity 0.3s';

        // ===================================
        // FLUID SIMULATION DEMO
        // ===================================

        // Ensure DOM is loaded
        const canvas = document.getElementById('fluidDemo');
        const ctx = canvas.getContext('2d');

        if (!canvas || !ctx) {
            console.error('Canvas not found!');
        } else {

        class FluidGrid {
            constructor(width, height, scale) {
                this.cols = Math.floor(width / scale);
                this.rows = Math.floor(height / scale);
                this.scale = scale;

                this.vx = this.createGrid();
                this.vy = this.createGrid();
                this.vx0 = this.createGrid();
                this.vy0 = this.createGrid();

                this.density = this.createGrid();
                this.density0 = this.createGrid();

                // For projection
                this.p = this.createGrid();
                this.div = this.createGrid();

                // Obstacles (1 = blocked, 0 = free)
                this.obstacles = this.createGrid();

                // Settings
                this.visc = 0.0001;
                this.diff = 0.0001;
                this.fadeRate = 0.99;

                // Visual settings
                this.colorMode = 'default';
                this.showVelocity = false;
                this.material = 'water'; // water, smoke, ink, honey, gas

                // Wind/gravity
                this.windX = 0;
                this.windY = 0;
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.rows; i++) {
                    grid[i] = new Array(this.cols).fill(0);
                }
                return grid;
            }

            diffuse(x, x0, diffusion, dt) {
                const a = dt * diffusion * this.cols * this.rows;

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            if (this.obstacles[i][j] === 1) continue;

                            x[i][j] = (x0[i][j] + a * (
                                x[i - 1][j] + x[i + 1][j] +
                                x[i][j - 1] + x[i][j + 1]
                            )) / (1 + 4 * a);
                        }
                    }
                    this.setBoundary(0, x);
                }
            }

            advect(d, d0, vx, vy, dt) {
                const dt0 = dt * this.cols;

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        if (this.obstacles[i][j] === 1) {
                            d[i][j] = 0;
                            continue;
                        }

                        let x = j - dt0 * vx[i][j];
                        let y = i - dt0 * vy[i][j];

                        x = Math.max(0.5, Math.min(this.cols - 1.5, x));
                        y = Math.max(0.5, Math.min(this.rows - 1.5, y));

                        const i0 = Math.floor(y);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(x);
                        const j1 = j0 + 1;

                        const s1 = x - j0;
                        const s0 = 1 - s1;
                        const t1 = y - i0;
                        const t0 = 1 - t1;

                        d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                                  s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
                    }
                }
                this.setBoundary(0, d);
            }

            project(vx, vy, p, div) {
                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        div[i][j] = -0.5 * (
                            vx[i][j + 1] - vx[i][j - 1] +
                            vy[i + 1][j] - vy[i - 1][j]
                        ) / this.cols;
                        p[i][j] = 0;
                    }
                }
                this.setBoundary(0, div);
                this.setBoundary(0, p);

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            p[i][j] = (div[i][j] +
                                p[i - 1][j] + p[i + 1][j] +
                                p[i][j - 1] + p[i][j + 1]
                            ) / 4;
                        }
                    }
                    this.setBoundary(0, p);
                }

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        vx[i][j] -= 0.5 * this.cols * (p[i][j + 1] - p[i][j - 1]);
                        vy[i][j] -= 0.5 * this.cols * (p[i + 1][j] - p[i - 1][j]);
                    }
                }
                this.setBoundary(1, vx);
                this.setBoundary(2, vy);
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.rows - 1; i++) {
                    x[i][0] = b === 1 ? -x[i][1] : x[i][1];
                    x[i][this.cols - 1] = b === 1 ? -x[i][this.cols - 2] : x[i][this.cols - 2];
                }
                for (let j = 1; j < this.cols - 1; j++) {
                    x[0][j] = b === 2 ? -x[1][j] : x[1][j];
                    x[this.rows - 1][j] = b === 2 ? -x[this.rows - 2][j] : x[this.rows - 2][j];
                }

                x[0][0] = 0.5 * (x[1][0] + x[0][1]);
                x[0][this.cols - 1] = 0.5 * (x[1][this.cols - 1] + x[0][this.cols - 2]);
                x[this.rows - 1][0] = 0.5 * (x[this.rows - 2][0] + x[this.rows - 1][1]);
                x[this.rows - 1][this.cols - 1] = 0.5 * (x[this.rows - 2][this.cols - 1] + x[this.rows - 1][this.cols - 2]);
            }

            step(dt = 0.016) {
                // Apply wind/gravity
                if (this.windX !== 0 || this.windY !== 0) {
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            this.vx[i][j] += this.windX * dt * 10;
                            this.vy[i][j] += this.windY * dt * 10;
                        }
                    }
                }

                // Swap arrays
                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.diffuse(this.vx, this.vx0, this.visc, dt);
                this.diffuse(this.vy, this.vy0, this.visc, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.advect(this.vx, this.vx0, this.vx0, this.vy0, dt);
                this.advect(this.vy, this.vy0, this.vx0, this.vy0, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.density0, this.density] = [this.density, this.density0];

                this.diffuse(this.density, this.density0, this.diff, dt);

                [this.density0, this.density] = [this.density, this.density0];

                this.advect(this.density, this.density0, this.vx, this.vy, dt);

                this.fadeDensity(this.fadeRate);
            }

            fadeDensity(fadeRate) {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.density[i][j] *= fadeRate;
                    }
                }
            }

            addDensity(x, y, amount) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.density[i][j] += amount;
                }
            }

            addVelocity(x, y, vx, vy) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.vx[i][j] += vx;
                    this.vy[i][j] += vy;
                }
            }

            addObstacle(x, y, radius = 3) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);

                for (let di = -radius; di <= radius; di++) {
                    for (let dj = -radius; dj <= radius; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                            if (di * di + dj * dj <= radius * radius) {
                                this.obstacles[ni][nj] = 1;
                            }
                        }
                    }
                }
            }

            clearObstacles() {
                this.obstacles = this.createGrid();
            }

            getColor(density) {
                const d = Math.min(255, Math.floor(density));
                const alpha = Math.min(1, d / 255);

                // Material-specific colors with very distinct appearances
                switch(this.material) {
                    case 'water':
                        // Clear blue water with cyan highlights
                        const waterBlue = Math.floor(150 + (d / 255) * 105);
                        const waterGreen = Math.floor(100 + (d / 255) * 100);
                        return `rgba(30, ${waterGreen}, ${waterBlue}, ${alpha * 0.7})`;

                    case 'smoke':
                        // Gray smoke with slight transparency
                        const smokeGray = Math.floor(100 + (d / 255) * 155);
                        return `rgba(${smokeGray}, ${smokeGray}, ${smokeGray + 20}, ${alpha * 0.5})`;

                    case 'ink':
                        // Vibrant rainbow colors based on density
                        const inkHue = (d / 255) * 360;
                        return `hsla(${inkHue}, 100%, 60%, ${alpha * 0.9})`;

                    case 'honey':
                        // Golden/amber honey color
                        const honeyR = Math.floor(200 + (d / 255) * 55);
                        const honeyG = Math.floor(140 + (d / 255) * 50);
                        const honeyB = Math.floor(20 + (d / 255) * 20);
                        return `rgba(${honeyR}, ${honeyG}, ${honeyB}, ${alpha * 0.85})`;

                    case 'gas':
                        // Light green/yellow gas
                        const gasR = Math.floor(150 + (d / 255) * 80);
                        const gasG = Math.floor(200 + (d / 255) * 55);
                        const gasB = Math.floor(100 + (d / 255) * 60);
                        return `rgba(${gasR}, ${gasG}, ${gasB}, ${alpha * 0.4})`;

                    default:
                        return `rgba(${d}, ${d * 0.5}, ${255 - d}, ${d / 255})`;
                }
            }

            render(ctx) {
                // Background color based on material
                switch(this.material) {
                    case 'water':
                        ctx.fillStyle = '#001020'; // Deep blue-black
                        break;
                    case 'smoke':
                        ctx.fillStyle = '#0a0a0a'; // Dark gray
                        break;
                    case 'honey':
                        ctx.fillStyle = '#1a0f00'; // Dark brown
                        break;
                    case 'gas':
                        ctx.fillStyle = '#0a1008'; // Dark greenish
                        break;
                    default:
                        ctx.fillStyle = '#000';
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw fluid density with glow effect for some materials
                const needsGlow = (this.material === 'gas' || this.material === 'smoke');

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const d = this.density[i][j];
                        if (d > 0) {
                            ctx.fillStyle = this.getColor(d);

                            // Add glow effect for smoke and gas
                            if (needsGlow && d > 50) {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.getColor(d);
                            } else {
                                ctx.shadowBlur = 0;
                            }

                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                ctx.shadowBlur = 0;

                // Draw obstacles
                ctx.fillStyle = '#666';
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.obstacles[i][j] === 1) {
                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                // Draw velocity field
                if (this.showVelocity) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;

                    const step = 4; // Show every 4th cell
                    for (let i = 0; i < this.rows; i += step) {
                        for (let j = 0; j < this.cols; j += step) {
                            const vx = this.vx[i][j];
                            const vy = this.vy[i][j];
                            const mag = Math.sqrt(vx * vx + vy * vy);

                            if (mag > 0.1) {
                                const x = j * this.scale + this.scale / 2;
                                const y = i * this.scale + this.scale / 2;
                                const scale = 5;

                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + vx * scale, y + vy * scale);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
        }

        const fluid = new FluidGrid(canvas.width, canvas.height, 8);

        // Initialize canvas with black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let addingObstacles = false;
        let continuousSource = false;
        let sourceX = canvas.width / 2;
        let sourceY = 50;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            prevMouseX = e.clientX - rect.left;
            prevMouseY = e.clientY - rect.top;

            if (addingObstacles) {
                fluid.addObstacle(prevMouseX, prevMouseY);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (addingObstacles) {
                    fluid.addObstacle(x, y);
                } else {
                    const vx = (x - prevMouseX) * 10;
                    const vy = (y - prevMouseY) * 10;

                    fluid.addDensity(x, y, 200);
                    fluid.addVelocity(x, y, vx, vy);
                }

                prevMouseX = x;
                prevMouseY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // ===================================
        // PRESET BUTTONS
        // ===================================

        document.getElementById('btnWater').addEventListener('click', () => {
            fluid.visc = 0.0001;
            fluid.diff = 0.0001;
            fluid.fadeRate = 0.99;
            fluid.material = 'water';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üíß Water - Clear blue liquid, low viscosity');
        });

        document.getElementById('btnSmoke').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.0005;
            fluid.fadeRate = 0.97;
            fluid.material = 'smoke';
            fluid.windY = -0.8; // Strong upward buoyancy
            updateSliders();
            updateInfo('üí® Smoke - Gray wisps that rise upward with buoyancy');
        });

        document.getElementById('btnInk').addEventListener('click', () => {
            fluid.visc = 0.0002;
            fluid.diff = 0.0003;
            fluid.fadeRate = 0.995;
            fluid.material = 'ink';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üñãÔ∏è Ink - Vibrant rainbow colors, medium viscosity');
        });

        document.getElementById('btnHoney').addEventListener('click', () => {
            fluid.visc = 0.0015;
            fluid.diff = 0.00003;
            fluid.fadeRate = 0.999;
            fluid.material = 'honey';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üçØ Honey - Golden amber, very thick and viscous');
        });

        document.getElementById('btnGas').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.001;
            fluid.fadeRate = 0.94;
            fluid.material = 'gas';
            fluid.windY = -0.3;
            updateSliders();
            updateInfo('‚òÅÔ∏è Gas - Light green/yellow, disperses quickly');
        });

        // ===================================
        // FEATURE BUTTONS
        // ===================================

        document.getElementById('btnVelocity').addEventListener('click', () => {
            fluid.showVelocity = !fluid.showVelocity;
            updateInfo(fluid.showVelocity ? 'Velocity field shown' : 'Velocity field hidden');
        });

        document.getElementById('btnAddObstacle').addEventListener('click', () => {
            addingObstacles = !addingObstacles;
            updateInfo(addingObstacles ? 'Click canvas to add obstacles' : 'Obstacle mode disabled');
        });

        document.getElementById('btnClearObstacles').addEventListener('click', () => {
            fluid.clearObstacles();
            updateInfo('Obstacles cleared');
        });

        document.getElementById('btnContinuousSource').addEventListener('click', () => {
            continuousSource = !continuousSource;
            updateInfo(continuousSource ? 'Continuous source enabled at top center' : 'Continuous source disabled');
        });

        document.getElementById('btnWind').addEventListener('click', () => {
            if (fluid.windY === 0) {
                fluid.windY = -0.5;
                updateInfo('Wind enabled - Upward force');
            } else {
                fluid.windY = 0;
                updateInfo('Wind disabled');
            }
        });

        // ===================================
        // COLOR MODE BUTTONS
        // ===================================

        document.getElementById('btnColorDefault').addEventListener('click', () => {
            fluid.material = 'water';
            updateInfo('Material changed to Water (blue)');
        });

        document.getElementById('btnColorRainbow').addEventListener('click', () => {
            fluid.material = 'ink';
            updateInfo('Material changed to Ink (rainbow)');
        });

        document.getElementById('btnColorFire').addEventListener('click', () => {
            fluid.material = 'honey';
            updateInfo('Material changed to Honey (golden/amber)');
        });

        document.getElementById('btnColorBlue').addEventListener('click', () => {
            fluid.material = 'gas';
            updateInfo('Material changed to Gas (green/yellow)');
        });

        document.getElementById('btnClearFluid').addEventListener('click', () => {
            fluid.density = fluid.createGrid();
            fluid.vx = fluid.createGrid();
            fluid.vy = fluid.createGrid();
            fluid.windX = 0;
            fluid.windY = 0;
            continuousSource = false;
            updateInfo('Fluid cleared');
        });

        // ===================================
        // SLIDERS
        // ===================================

        const viscSlider = document.getElementById('viscSlider');
        const viscValue = document.getElementById('viscValue');
        const diffSlider = document.getElementById('diffSlider');
        const diffValue = document.getElementById('diffValue');
        const fadeSlider = document.getElementById('fadeSlider');
        const fadeValue = document.getElementById('fadeValue');

        viscSlider.addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            viscValue.textContent = fluid.visc.toFixed(4);
        });

        diffSlider.addEventListener('input', (e) => {
            fluid.diff = parseFloat(e.target.value);
            diffValue.textContent = fluid.diff.toFixed(4);
        });

        fadeSlider.addEventListener('input', (e) => {
            fluid.fadeRate = parseFloat(e.target.value);
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        });

        function updateSliders() {
            viscSlider.value = fluid.visc;
            viscValue.textContent = fluid.visc.toFixed(4);
            diffSlider.value = fluid.diff;
            diffValue.textContent = fluid.diff.toFixed(4);
            fadeSlider.value = fluid.fadeRate;
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        }

        function updateInfo(message) {
            document.getElementById('fluidInfo').textContent = message;
        }

        function animate() {
            // Add continuous source if enabled
            if (continuousSource) {
                fluid.addDensity(sourceX, sourceY, 100);
                fluid.addVelocity(sourceX, sourceY, 0, 2);
            }

            fluid.step();
            fluid.render(ctx);
            requestAnimationFrame(animate);
        }

        animate();
        } // End canvas check

        // ===================================
        // DEMO 1: BUOYANCY SIMULATION
        // ===================================

        const buoyancyCanvas = document.getElementById('buoyancyDemo');
        const buoyancyCtx = buoyancyCanvas.getContext('2d');

        let waterLevel = 350;
        const targetWaterLevel = 350;
        let objects = [];

        class PhysicsObject {
            constructor(x, y, width, height, density, color, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.density = density; // kg/m¬≥
                this.color = color;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.mass = width * height * density / 1000;
                this.onGround = false;
            }

            update(dt) {
                const gravity = 800; // pixels/s¬≤
                const waterDensity = 1.0;
                const airResistance = 0.02;
                const waterResistance = 0.1;

                // Check if submerged
                const bottomY = this.y + this.height;
                const topY = this.y;

                let submergedHeight = 0;
                if (bottomY > waterLevel && topY < waterLevel) {
                    submergedHeight = bottomY - waterLevel;
                } else if (topY >= waterLevel) {
                    submergedHeight = this.height;
                }

                const submergedFraction = submergedHeight / this.height;

                // Buoyancy force (Archimedes' principle)
                const buoyancyForce = submergedFraction * this.width * this.height * waterDensity * gravity / 1000;

                // Net force
                const gravityForce = this.mass * gravity;
                let netForce = gravityForce - buoyancyForce;

                // Apply force
                this.vy += (netForce / this.mass) * dt;

                // Resistance
                if (submergedFraction > 0) {
                    this.vx *= (1 - waterResistance);
                    this.vy *= (1 - waterResistance);
                } else {
                    this.vx *= (1 - airResistance);
                    this.vy *= (1 - airResistance);
                }

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < 0) {
                    this.x = 0;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x + this.width > buoyancyCanvas.width) {
                    this.x = buoyancyCanvas.width - this.width;
                    this.vx = -this.vx * 0.5;
                }

                // Floor
                if (this.y + this.height > buoyancyCanvas.height) {
                    this.y = buoyancyCanvas.height - this.height;
                    this.vy = -this.vy * 0.3;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Draw type label
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x + this.width / 2, this.y + this.height / 2 + 4);
            }
        }

        buoyancyCanvas.addEventListener('click', (e) => {
            const rect = buoyancyCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a random object at click position
            const types = ['box', 'stone', 'ball'];
            const type = types[Math.floor(Math.random() * types.length)];

            if (type === 'box') {
                objects.push(new PhysicsObject(x - 20, y - 20, 40, 40, 0.5, '#8B4513', 'BOX'));
            } else if (type === 'stone') {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 2.5, '#555', 'STONE'));
            } else {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 0.3, '#FF6B6B', 'BALL'));
            }
        });

        document.getElementById('btnAddBox').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 40, 40, 0.5, '#8B4513', 'BOX'));
        });

        document.getElementById('btnAddStone').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 2.5, '#555', 'STONE'));
        });

        document.getElementById('btnAddBall').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 0.3, '#FF6B6B', 'BALL'));
        });

        document.getElementById('btnDrain').addEventListener('click', () => {
            waterLevel = Math.min(waterLevel + 100, 500);
        });

        document.getElementById('btnFill').addEventListener('click', () => {
            waterLevel = Math.max(waterLevel - 100, 200);
        });

        document.getElementById('btnResetBuoyancy').addEventListener('click', () => {
            objects = [];
            waterLevel = 350;
        });

        function animateBuoyancy() {
            // Clear
            buoyancyCtx.fillStyle = '#1a1a2e';
            buoyancyCtx.fillRect(0, 0, buoyancyCanvas.width, buoyancyCanvas.height);

            // Draw water
            buoyancyCtx.fillStyle = 'rgba(30, 144, 255, 0.6)';
            buoyancyCtx.fillRect(0, waterLevel, buoyancyCanvas.width, buoyancyCanvas.height - waterLevel);

            // Draw water surface
            buoyancyCtx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            buoyancyCtx.lineWidth = 3;
            buoyancyCtx.beginPath();
            buoyancyCtx.moveTo(0, waterLevel);
            buoyancyCtx.lineTo(buoyancyCanvas.width, waterLevel);
            buoyancyCtx.stroke();

            // Update and draw objects
            objects.forEach(obj => {
                obj.update(0.016);
                obj.draw(buoyancyCtx);
            });

            // Draw info
            buoyancyCtx.fillStyle = '#fff';
            buoyancyCtx.font = '14px Arial';
            buoyancyCtx.textAlign = 'left';
            buoyancyCtx.fillText(`Water Level: ${Math.floor(waterLevel)}px`, 10, 20);
            buoyancyCtx.fillText(`Objects: ${objects.length}`, 10, 40);

            requestAnimationFrame(animateBuoyancy);
        }

        animateBuoyancy();

        // ===================================
        // DEMO 2: RISING WATER CHALLENGE
        // ===================================

        const risingCanvas = document.getElementById('risingWaterDemo');
        const risingCtx = risingCanvas.getContext('2d');

        let risingWaterLevel = 500;
        let isRising = false;
        let player = {
            x: 100,
            y: 400,
            width: 30,
            height: 40,
            vx: 0,
            vy: 0,
            onGround: false,
            inWater: false,
            alive: true
        };

        const platforms = [
            { x: 50, y: 450, width: 150, height: 20 },
            { x: 250, y: 380, width: 120, height: 20 },
            { x: 420, y: 310, width: 140, height: 20 },
            { x: 600, y: 240, width: 150, height: 20 },
            { x: 200, y: 170, width: 200, height: 20 },
            { x: 450, y: 100, width: 300, height: 20 },
        ];

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.getElementById('btnStartRising').addEventListener('click', () => {
            isRising = true;
        });

        document.getElementById('btnStopRising').addEventListener('click', () => {
            isRising = false;
        });

        document.getElementById('btnResetRising').addEventListener('click', () => {
            risingWaterLevel = 500;
            isRising = false;
            player = {
                x: 100,
                y: 400,
                width: 30,
                height: 40,
                vx: 0,
                vy: 0,
                onGround: false,
                inWater: false,
                alive: true
            };
        });

        function updateRisingWater() {
            if (!player.alive) return;

            const speed = player.inWater ? 3 : 5;
            const jumpPower = player.inWater ? -8 : -12;

            // Movement
            if (keys['ArrowLeft']) player.vx = -speed;
            else if (keys['ArrowRight']) player.vx = speed;
            else player.vx *= 0.8;

            // Jump
            if (keys['ArrowUp'] && player.onGround) {
                player.vy = jumpPower;
            }

            // Gravity
            const gravity = player.inWater ? 0.3 : 0.5;
            player.vy += gravity;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // Check water
            player.inWater = (player.y + player.height) > risingWaterLevel;

            // Collisions with platforms
            player.onGround = false;
            platforms.forEach(platform => {
                // Check if player is horizontally aligned with platform
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width) {
                    // Check if player's feet are landing on platform top (within tolerance)
                    const feetY = player.y + player.height;
                    const platformTop = platform.y;
                    if (feetY >= platformTop && feetY <= platformTop + 15 && player.vy >= 0) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            });

            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > risingCanvas.width) player.x = risingCanvas.width - player.width;

            // Check if drowned
            if (player.y > risingWaterLevel) {
                player.alive = false;
            }

            // Check if safe
            if (player.y < 50 && risingWaterLevel < 100) {
                document.getElementById('risingWaterInfo').textContent = 'üéâ You escaped! You win!';
            }

            // Rise water
            if (isRising && risingWaterLevel > 0) {
                risingWaterLevel -= 0.5;
            }
        }

        function renderRisingWater() {
            // Background
            risingCtx.fillStyle = '#16213e';
            risingCtx.fillRect(0, 0, risingCanvas.width, risingCanvas.height);

            // Platforms
            risingCtx.fillStyle = '#4a5568';
            platforms.forEach(platform => {
                risingCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                risingCtx.strokeStyle = '#718096';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Water
            risingCtx.fillStyle = 'rgba(30, 100, 200, 0.7)';
            risingCtx.fillRect(0, risingWaterLevel, risingCanvas.width, risingCanvas.height - risingWaterLevel);

            // Water surface animation
            risingCtx.strokeStyle = 'rgba(100, 180, 255, 0.9)';
            risingCtx.lineWidth = 3;
            risingCtx.beginPath();
            const time = Date.now() / 200;
            for (let x = 0; x < risingCanvas.width; x += 5) {
                const wave = Math.sin(x / 30 + time) * 3;
                risingCtx.lineTo(x, risingWaterLevel + wave);
            }
            risingCtx.stroke();

            // Player
            if (player.alive) {
                risingCtx.fillStyle = player.inWater ? '#FF6B6B' : '#4ECDC4';
                risingCtx.fillRect(player.x, player.y, player.width, player.height);
                risingCtx.strokeStyle = '#fff';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(player.x, player.y, player.width, player.height);

                // Eyes
                risingCtx.fillStyle = '#fff';
                risingCtx.fillRect(player.x + 8, player.y + 10, 5, 5);
                risingCtx.fillRect(player.x + 17, player.y + 10, 5, 5);
            } else {
                risingCtx.fillStyle = '#FF0000';
                risingCtx.font = '30px Arial';
                risingCtx.textAlign = 'center';
                risingCtx.fillText('DROWNED!', risingCanvas.width / 2, risingCanvas.height / 2);
                risingCtx.font = '16px Arial';
                risingCtx.fillText('Click Reset to try again', risingCanvas.width / 2, risingCanvas.height / 2 + 30);
            }

            // Info
            risingCtx.fillStyle = '#fff';
            risingCtx.font = '14px Arial';
            risingCtx.textAlign = 'left';
            risingCtx.fillText(`Water Level: ${Math.floor(risingWaterLevel)}`, 10, 20);
            risingCtx.fillText(`Player Status: ${player.alive ? (player.inWater ? 'In Water!' : 'Safe') : 'Drowned'}`, 10, 40);

            updateRisingWater();
            requestAnimationFrame(renderRisingWater);
        }

        renderRisingWater();

        // ===================================
        // DEMO 3: SPH PARTICLE-BASED WATER
        // ===================================

        const sphCanvas = document.getElementById('sphDemo');
        const sphCtx = sphCanvas.getContext('2d');

        const MAX_SPH_PARTICLES = 300;
        let sphParticles = [];
        let sphBarriers = [];
        let sphGravity = true;
        let sphViscosity = 0.5;
        let addingBarrier = false;

        class WaterParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.density = 0;
                this.pressure = 0;
                this.fx = 0;
                this.fy = 0;
                this.radius = 4;
            }

            update(particles, dt) {
                const h = 20; // Smoothing radius
                const k = 0.1; // Pressure constant
                const restDensity = 1.0;

                // Calculate density
                this.density = 0;
                particles.forEach(other => {
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h) {
                        const q = dist / h;
                        const kernel = (1 - q) * (1 - q);
                        this.density += kernel;
                    }
                });

                // Calculate pressure
                this.pressure = k * (this.density - restDensity);

                // Reset forces
                this.fx = 0;
                this.fy = 0;

                // Pressure force
                particles.forEach(other => {
                    if (other === this) return;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h && dist > 0.01 && this.density > 0.001) {
                        const q = dist / h;
                        const kernel = (1 - q);
                        const pressureForce = -kernel * (this.pressure + other.pressure) / (2 * this.density);

                        this.fx += pressureForce * (dx / dist);
                        this.fy += pressureForce * (dy / dist);
                    }
                });

                // Gravity
                if (sphGravity) {
                    this.fy += 10;
                }

                // Apply forces
                this.vx += this.fx * dt;
                this.vy += this.fy * dt;

                // Viscosity
                this.vx *= (1 - sphViscosity * 0.05);
                this.vy *= (1 - sphViscosity * 0.05);

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x > sphCanvas.width - this.radius) {
                    this.x = sphCanvas.width - this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy = -this.vy * 0.5;
                }
                if (this.y > sphCanvas.height - this.radius) {
                    this.y = sphCanvas.height - this.radius;
                    this.vy = -this.vy * 0.5;
                }

                // Barrier collisions
                sphBarriers.forEach(barrier => {
                    if (this.x > barrier.x && this.x < barrier.x + barrier.width &&
                        this.y > barrier.y && this.y < barrier.y + barrier.height) {
                        // Simple ejection
                        const dx = this.x - (barrier.x + barrier.width / 2);
                        const dy = this.y - (barrier.y + barrier.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.x += (dx / dist) * 5;
                            this.y += (dy / dist) * 5;
                        }
                        this.vx *= 0.3;
                        this.vy *= 0.3;
                    }
                });
            }

            draw(ctx) {
                const colorIntensity = Math.min(255, this.density * 100);
                ctx.fillStyle = `rgba(30, ${100 + colorIntensity}, ${200 + colorIntensity / 2}, 0.9)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        sphCanvas.addEventListener('click', (e) => {
            const rect = sphCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (addingBarrier) {
                sphBarriers.push({ x: x - 30, y: y - 10, width: 60, height: 20 });
            } else if (sphParticles.length < MAX_SPH_PARTICLES) {
                // Add cluster of particles (limited to prevent performance issues)
                const particlesToAdd = Math.min(20, MAX_SPH_PARTICLES - sphParticles.length);
                for (let i = 0; i < particlesToAdd; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20;
                    sphParticles.push(new WaterParticle(
                        x + Math.cos(angle) * radius,
                        y + Math.sin(angle) * radius
                    ));
                }
            }
        });

        document.getElementById('btnAddWater').addEventListener('click', () => {
            const particlesToAdd = Math.min(30, MAX_SPH_PARTICLES - sphParticles.length);
            for (let i = 0; i < particlesToAdd; i++) {
                sphParticles.push(new WaterParticle(
                    Math.random() * 200 + 300,
                    Math.random() * 100 + 50
                ));
            }
        });

        document.getElementById('btnAddBarrier').addEventListener('click', () => {
            addingBarrier = !addingBarrier;
        });

        document.getElementById('btnToggleGravity').addEventListener('click', () => {
            sphGravity = !sphGravity;
        });

        document.getElementById('btnResetSPH').addEventListener('click', () => {
            sphParticles = [];
            sphBarriers = [];
        });

        document.getElementById('sphViscosity').addEventListener('input', (e) => {
            sphViscosity = parseFloat(e.target.value);
            document.getElementById('sphViscValue').textContent = sphViscosity.toFixed(1);
        });

        function animateSPH() {
            sphCtx.fillStyle = '#0a0e1a';
            sphCtx.fillRect(0, 0, sphCanvas.width, sphCanvas.height);

            // Draw barriers
            sphCtx.fillStyle = '#666';
            sphBarriers.forEach(barrier => {
                sphCtx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
            });

            // Update and draw particles
            const dt = 0.1;
            sphParticles.forEach(p => p.update(sphParticles, dt));
            sphParticles.forEach(p => p.draw(sphCtx));

            // Info
            sphCtx.fillStyle = '#fff';
            sphCtx.font = '14px Arial';
            sphCtx.textAlign = 'left';
            sphCtx.fillText(`Particles: ${sphParticles.length}`, 10, 20);
            sphCtx.fillText(`Gravity: ${sphGravity ? 'ON' : 'OFF'}`, 10, 40);

            requestAnimationFrame(animateSPH);
        }

        animateSPH();

        // ===================================
        // DEMO 4: SIMPLIFIED FLOW MECHANIC
        // ===================================

        const puzzleCanvas = document.getElementById('flowPuzzleDemo');
        const puzzleCtx = puzzleCanvas.getContext('2d');

        let waterReleased = false;
        let addingPlatforms = false;
        let flowPlatforms = [];

        const bucket = { x: 650, y: 400, width: 100, height: 80, filled: 0 };
        const source = { x: 400, y: 50 };

        // Grid-based flow system
        const cellSize = 10;
        const cols = Math.floor(puzzleCanvas.width / cellSize);
        const rows = Math.floor(puzzleCanvas.height / cellSize);
        let waterGrid = [];
        let velocityGrid = [];

        // Initialize grids
        for (let i = 0; i < cols; i++) {
            waterGrid[i] = [];
            velocityGrid[i] = [];
            for (let j = 0; j < rows; j++) {
                waterGrid[i][j] = 0;
                velocityGrid[i][j] = { vx: 0, vy: 0 };
            }
        }

        // Check if cell is blocked by platform
        function isBlocked(gridX, gridY) {
            const x = gridX * cellSize;
            const y = gridY * cellSize;

            for (let platform of flowPlatforms) {
                if (x + cellSize > platform.x && x < platform.x + platform.width &&
                    y + cellSize > platform.y && y < platform.y + platform.height) {
                    return true;
                }
            }
            return false;
        }

        // Update water flow
        function updateFlow() {
            const newWater = [];
            for (let i = 0; i < cols; i++) {
                newWater[i] = [];
                for (let j = 0; j < rows; j++) {
                    newWater[i][j] = waterGrid[i][j];
                }
            }

            // Add water from source
            if (waterReleased) {
                const sourceGridX = Math.floor(source.x / cellSize);
                const sourceGridY = Math.floor(source.y / cellSize);
                for (let dx = -2; dx <= 2; dx++) {
                    const gx = sourceGridX + dx;
                    if (gx >= 0 && gx < cols && sourceGridY >= 0 && sourceGridY < rows) {
                        newWater[gx][sourceGridY] = Math.min(255, newWater[gx][sourceGridY] + 35);
                    }
                }
            }

            // Flow simulation - water flows down and spreads
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 5 && !isBlocked(i, j)) {
                        const amount = waterGrid[i][j];

                        // Try to flow down first
                        if (j < rows - 1 && !isBlocked(i, j + 1)) {
                            const flowDown = Math.min(amount * 0.5, 255 - newWater[i][j + 1]);
                            newWater[i][j] -= flowDown;
                            newWater[i][j + 1] += flowDown;
                        }

                        // Then spread sideways if there's water left
                        if (newWater[i][j] > 10) {
                            // Flow left
                            if (i > 0 && !isBlocked(i - 1, j)) {
                                const diff = (newWater[i][j] - newWater[i - 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i - 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i - 1][j] += flow;
                                }
                            }

                            // Flow right
                            if (i < cols - 1 && !isBlocked(i + 1, j)) {
                                const diff = (newWater[i][j] - newWater[i + 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i + 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i + 1][j] += flow;
                                }
                            }
                        }
                    }

                    // Check if water reached bucket
                    const x = i * cellSize;
                    const y = j * cellSize;
                    if (x > bucket.x && x < bucket.x + bucket.width &&
                        y > bucket.y && y < bucket.y + bucket.height) {
                        if (newWater[i][j] > 0) {
                            bucket.filled = Math.min(100, bucket.filled + newWater[i][j] * 0.01);
                            newWater[i][j] = 0;
                        }
                    }

                    // Evaporation at bottom
                    if (j === rows - 1 && newWater[i][j] > 0) {
                        newWater[i][j] *= 0.95;
                    }
                }
            }

            waterGrid = newWater;
        }

        // Draw water grid
        function drawWater(ctx) {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const amount = waterGrid[i][j];
                    if (amount > 3) {
                        // Much more visible water color
                        const intensity = Math.min(1, amount / 180);

                        // Bright cyan-blue water
                        const r = Math.floor(30 + intensity * 50);
                        const g = Math.floor(180 + intensity * 75);
                        const b = Math.floor(220 + intensity * 35);

                        // Higher base opacity
                        const alpha = Math.max(0.7, intensity);

                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                        // Add white highlights to make water more visible
                        if (amount > 50) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.4})`;
                            ctx.fillRect(i * cellSize + 1, j * cellSize + 1, cellSize - 2, cellSize - 2);
                        }

                        // Add shimmer effect
                        if (amount > 80 && Math.random() < 0.15) {
                            ctx.fillStyle = `rgba(200, 255, 255, 0.6)`;
                            const shimmerSize = cellSize * 0.6;
                            ctx.fillRect(
                                i * cellSize + (cellSize - shimmerSize) / 2,
                                j * cellSize + (cellSize - shimmerSize) / 2,
                                shimmerSize,
                                shimmerSize
                            );
                        }
                    }
                }
            }
        }

        puzzleCanvas.addEventListener('click', (e) => {
            if (!addingPlatforms) return;

            const rect = puzzleCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a platform
            flowPlatforms.push({
                x: x - 40,
                y: y,
                width: 80,
                height: 10
            });
        });

        document.getElementById('btnRelease').addEventListener('click', () => {
            waterReleased = !waterReleased;
            document.getElementById('btnRelease').textContent = waterReleased ? 'Stop Water' : 'Release Water';
        });

        document.getElementById('btnAddPlatform').addEventListener('click', (e) => {
            addingPlatforms = !addingPlatforms;
            e.target.textContent = addingPlatforms ? 'Stop Adding Platforms' : 'Add Platform (Blocks Water)';
            e.target.style.backgroundColor = addingPlatforms ? '#4CAF50' : '#4a5568';
        });

        document.getElementById('btnResetPuzzle').addEventListener('click', () => {
            waterReleased = false;
            flowPlatforms = [];
            bucket.filled = 0;
            // Reset water grid
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    waterGrid[i][j] = 0;
                }
            }
            document.getElementById('btnRelease').textContent = 'Release Water';
        });

        function animatePuzzle() {
            // Background - darker for better water contrast
            puzzleCtx.fillStyle = '#0a0e1a';
            puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);

            // Update and draw water flow
            updateFlow();
            drawWater(puzzleCtx);

            // Draw source
            puzzleCtx.fillStyle = '#4FC3F7';
            puzzleCtx.fillRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.strokeStyle = '#82CEFF';
            puzzleCtx.lineWidth = 2;
            puzzleCtx.strokeRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = 'bold 12px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('SOURCE', source.x, source.y + 5);

            // Draw platforms
            puzzleCtx.fillStyle = '#4a5568';
            flowPlatforms.forEach(platform => {
                puzzleCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                puzzleCtx.strokeStyle = '#718096';
                puzzleCtx.lineWidth = 2;
                puzzleCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Platform mode indicator
            if (addingPlatforms) {
                puzzleCtx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
                puzzleCtx.fillStyle = '#4CAF50';
                puzzleCtx.font = 'bold 20px Arial';
                puzzleCtx.textAlign = 'center';
                puzzleCtx.fillText('Click to add platforms', puzzleCanvas.width / 2, 30);
            }

            // Draw bucket
            puzzleCtx.strokeStyle = '#8B4513';
            puzzleCtx.lineWidth = 4;
            puzzleCtx.strokeRect(bucket.x, bucket.y, bucket.width, bucket.height);

            // Fill water in bucket
            puzzleCtx.fillStyle = 'rgba(30, 144, 255, 0.7)';
            const fillHeight = (bucket.filled / 100) * bucket.height;
            puzzleCtx.fillRect(bucket.x, bucket.y + bucket.height - fillHeight, bucket.width, fillHeight);

            // Bucket label
            puzzleCtx.fillStyle = '#FFD700';
            puzzleCtx.font = 'bold 14px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('BUCKET', bucket.x + bucket.width / 2, bucket.y - 5);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = '12px Arial';
            puzzleCtx.fillText(`${Math.floor(bucket.filled)}%`, bucket.x + bucket.width / 2, bucket.y + bucket.height / 2);

            // Calculate total water in system
            let totalWater = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 0) totalWater++;
                }
            }

            // Update status
            const bucketPercent = Math.floor(bucket.filled);
            if (bucket.filled >= 90) {
                document.getElementById('puzzleStatus').textContent = `üéâ Bucket Full! ${bucketPercent}%`;
            } else {
                document.getElementById('puzzleStatus').textContent = `Bucket: ${bucketPercent}% | Platforms: ${flowPlatforms.length} | Water Cells: ${totalWater}`;
            }

            requestAnimationFrame(animatePuzzle);
        }

        animatePuzzle();

        // ========================================
        // WIND SIMULATION DEMO
        // ========================================
        const windCanvas = document.getElementById('windCanvas');
        if (windCanvas) {
            const windCtx = windCanvas.getContext('2d');

            // Wind field settings
            const windGridSize = 20;
            const windCols = Math.ceil(windCanvas.width / windGridSize);
            const windRows = Math.ceil(windCanvas.height / windGridSize);

            let windVectors = [];
            let windParticles = [];
            let windGusts = [];
            let windTime = 0;
            let windStrength = 1.0;
            let turbulence = 0.5;
            let showVectors = false;

            // Initialize wind field
            for (let i = 0; i < windRows; i++) {
                windVectors[i] = [];
                for (let j = 0; j < windCols; j++) {
                    windVectors[i][j] = { x: 0, y: 0 };
                }
            }

            // Create particles
            for (let i = 0; i < 200; i++) {
                windParticles.push({
                    x: Math.random() * windCanvas.width,
                    y: Math.random() * windCanvas.height,
                    vx: 0,
                    vy: 0,
                    trail: []
                });
            }

            // Noise function
            function windNoise(x, y, t) {
                const n = Math.sin(x * 0.1 + t) * Math.cos(y * 0.1 + t * 0.7);
                return n * 0.5 + 0.5;
            }

            // Update wind field
            function updateWindField(dt) {
                windTime += dt * 0.001;

                for (let i = 0; i < windRows; i++) {
                    for (let j = 0; j < windCols; j++) {
                        // Base wind (left to right)
                        let wx = 1 * windStrength;
                        let wy = 0;

                        // Add turbulence
                        const noiseX = windNoise(j, i, windTime);
                        const noiseY = windNoise(j + 100, i + 100, windTime);
                        wx += (noiseX - 0.5) * turbulence * 2;
                        wy += (noiseY - 0.5) * turbulence * 2;

                        // Add gust effects
                        const x = j * windGridSize;
                        const y = i * windGridSize;
                        for (let gust of windGusts) {
                            const dx = x - gust.x;
                            const dy = y - gust.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < gust.radius) {
                                const influence = (1 - dist / gust.radius) * gust.strength;
                                const angle = Math.atan2(dy, dx);
                                wx += Math.cos(angle) * influence;
                                wy += Math.sin(angle) * influence;
                            }
                        }

                        windVectors[i][j] = { x: wx, y: wy };
                    }
                }

                // Decay gusts
                windGusts = windGusts.filter(g => {
                    g.strength *= 0.95;
                    return g.strength > 0.1;
                });
            }

            // Get wind at position
            function getWindAt(x, y) {
                const gridX = x / windGridSize;
                const gridY = y / windGridSize;
                const i = Math.floor(gridY);
                const j = Math.floor(gridX);

                if (i < 0 || i >= windRows - 1 || j < 0 || j >= windCols - 1) {
                    return { x: 0, y: 0 };
                }

                const fx = gridX - j;
                const fy = gridY - i;
                const v00 = windVectors[i][j];
                const v10 = windVectors[i][j + 1];
                const v01 = windVectors[i + 1][j];
                const v11 = windVectors[i + 1][j + 1];

                const wx = v00.x * (1 - fx) * (1 - fy) + v10.x * fx * (1 - fy) +
                           v01.x * (1 - fx) * fy + v11.x * fx * fy;
                const wy = v00.y * (1 - fx) * (1 - fy) + v10.y * fx * (1 - fy) +
                           v01.y * (1 - fx) * fy + v11.y * fx * fy;

                return { x: wx, y: wy };
            }

            // Update particles
            function updateWindParticles() {
                windParticles.forEach(p => {
                    const wind = getWindAt(p.x, p.y);
                    p.vx += wind.x * 0.5;
                    p.vy += wind.y * 0.5;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.x += p.vx;
                    p.y += p.vy;

                    // Wrap around
                    if (p.x < 0) p.x = windCanvas.width;
                    if (p.x > windCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = windCanvas.height;
                    if (p.y > windCanvas.height) p.y = 0;

                    p.trail.push({ x: p.x, y: p.y });
                    if (p.trail.length > 8) p.trail.shift();
                });
            }

            // Draw wind demo
            function drawWindDemo() {
                // Fade effect instead of clearing
                windCtx.fillStyle = 'rgba(26, 26, 26, 0.15)';
                windCtx.fillRect(0, 0, windCanvas.width, windCanvas.height);

                // Draw wind vectors if enabled
                if (showVectors) {
                    windCtx.lineWidth = 1;
                    for (let i = 0; i < windRows; i++) {
                        for (let j = 0; j < windCols; j++) {
                            const x = j * windGridSize + windGridSize / 2;
                            const y = i * windGridSize + windGridSize / 2;
                            const v = windVectors[i][j];
                            const mag = Math.sqrt(v.x * v.x + v.y * v.y);

                            windCtx.strokeStyle = `rgba(100, 200, 255, ${Math.min(0.4, mag * 0.15)})`;
                            windCtx.beginPath();
                            windCtx.moveTo(x, y);
                            windCtx.lineTo(x + v.x * 8, y + v.y * 8);
                            windCtx.stroke();

                            // Arrow head
                            const angle = Math.atan2(v.y, v.x);
                            const arrowX = x + v.x * 8;
                            const arrowY = y + v.y * 8;
                            windCtx.beginPath();
                            windCtx.moveTo(arrowX, arrowY);
                            windCtx.lineTo(arrowX - 5 * Math.cos(angle - Math.PI/6), arrowY - 5 * Math.sin(angle - Math.PI/6));
                            windCtx.moveTo(arrowX, arrowY);
                            windCtx.lineTo(arrowX - 5 * Math.cos(angle + Math.PI/6), arrowY - 5 * Math.sin(angle + Math.PI/6));
                            windCtx.stroke();
                        }
                    }
                }

                // Draw particles with glow
                windParticles.forEach(p => {
                    // Glow effect
                    const gradient = windCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 6);
                    gradient.addColorStop(0, 'rgba(150, 220, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');

                    windCtx.fillStyle = gradient;
                    windCtx.beginPath();
                    windCtx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    windCtx.fill();

                    // Core
                    windCtx.fillStyle = 'rgba(200, 240, 255, 0.9)';
                    windCtx.beginPath();
                    windCtx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    windCtx.fill();
                });
            }

            // Animation loop
            function animateWind() {
                updateWindField(16);
                updateWindParticles();
                drawWindDemo();
                requestAnimationFrame(animateWind);
            }

            // Controls
            document.getElementById('windStrengthSlider').addEventListener('input', (e) => {
                windStrength = parseFloat(e.target.value);
                document.getElementById('windStrengthDisplay').textContent = windStrength.toFixed(1);
            });

            document.getElementById('turbulenceSlider').addEventListener('input', (e) => {
                turbulence = parseFloat(e.target.value);
                document.getElementById('turbulenceDisplay').textContent = turbulence.toFixed(1);
            });

            document.getElementById('toggleWindVectors').addEventListener('click', () => {
                showVectors = !showVectors;
            });

            document.getElementById('resetWindDemo').addEventListener('click', () => {
                windGusts = [];
                windParticles.forEach(p => {
                    p.x = Math.random() * windCanvas.width;
                    p.y = Math.random() * windCanvas.height;
                    p.vx = 0;
                    p.vy = 0;
                    p.trail = [];
                });
            });

            windCanvas.addEventListener('click', (e) => {
                const rect = windCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                windGusts.push({ x, y, strength: 5, radius: 150 });
            });

            animateWind();
        }

        // ========================================
        // DESTRUCTIBLE TERRAIN DEMO
        // ========================================
        const terrainCanvas = document.getElementById('terrainCanvas');
        if (terrainCanvas) {
            const terrainCtx = terrainCanvas.getContext('2d');

            let terrainImageData = terrainCtx.createImageData(terrainCanvas.width, terrainCanvas.height);
            let explosionSize = 30;
            let balls = [];
            let isMouseDown = false;

            // Initialize terrain
            function initTerrain() {
                balls = [];
                terrainImageData = terrainCtx.createImageData(terrainCanvas.width, terrainCanvas.height);
                const data = terrainImageData.data;

                for (let y = 0; y < terrainCanvas.height; y++) {
                    for (let x = 0; x < terrainCanvas.width; x++) {
                        const idx = (y * terrainCanvas.width + x) * 4;

                        // Create layered terrain
                        if (y > 150 && y < 450) {
                            // Dirt layer
                            const noise = Math.sin(x * 0.05) * 10 + Math.cos(y * 0.03) * 5;
                            if (y + noise > 200) {
                                data[idx] = 139;     // R
                                data[idx + 1] = 90;  // G
                                data[idx + 2] = 43;  // B
                                data[idx + 3] = 255; // A
                            }
                        }
                    }
                }

                terrainCtx.putImageData(terrainImageData, 0, 0);
            }

            // Check if terrain exists at position
            function isTerrainAt(x, y) {
                if (x < 0 || x >= terrainCanvas.width || y < 0 || y >= terrainCanvas.height) return false;
                const idx = (Math.floor(y) * terrainCanvas.width + Math.floor(x)) * 4;
                return terrainImageData.data[idx + 3] > 0;
            }

            // Destroy terrain
            function destroyTerrain(x, y, radius) {
                const data = terrainImageData.data;

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const px = Math.floor(x + dx);
                            const py = Math.floor(y + dy);

                            if (px >= 0 && px < terrainCanvas.width && py >= 0 && py < terrainCanvas.height) {
                                const idx = (py * terrainCanvas.width + px) * 4;
                                data[idx + 3] = 0; // Make transparent
                            }
                        }
                    }
                }

                terrainCtx.putImageData(terrainImageData, 0, 0);
            }

            // Update balls
            function updateBalls() {
                balls.forEach((ball, index) => {
                    ball.vy += 0.5; // Gravity
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    // Check terrain collision
                    let collided = false;
                    for (let i = 0; i < 360; i += 30) {
                        const angle = i * Math.PI / 180;
                        const checkX = ball.x + Math.cos(angle) * ball.radius;
                        const checkY = ball.y + Math.sin(angle) * ball.radius;

                        if (isTerrainAt(checkX, checkY)) {
                            collided = true;
                            ball.vy *= -0.5;
                            ball.vx *= 0.9;
                            ball.y -= 2;
                            break;
                        }
                    }

                    // Remove balls that fall off screen
                    if (ball.y > terrainCanvas.height + 50) {
                        balls.splice(index, 1);
                    }
                });
            }

            // Draw terrain demo
            function drawTerrainDemo() {
                terrainCtx.fillStyle = '#0a0a0a';
                terrainCtx.fillRect(0, 0, terrainCanvas.width, terrainCanvas.height);

                // Draw terrain
                terrainCtx.putImageData(terrainImageData, 0, 0);

                // Draw balls
                balls.forEach(ball => {
                    terrainCtx.fillStyle = ball.color;
                    terrainCtx.beginPath();
                    terrainCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    terrainCtx.fill();

                    terrainCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    terrainCtx.stroke();
                });
            }

            // Animation loop
            function animateTerrain() {
                updateBalls();
                drawTerrainDemo();
                requestAnimationFrame(animateTerrain);
            }

            // Controls
            document.getElementById('explosionSizeSlider').addEventListener('input', (e) => {
                explosionSize = parseInt(e.target.value);
                document.getElementById('explosionSizeDisplay').textContent = explosionSize;
            });

            document.getElementById('addBall').addEventListener('click', () => {
                balls.push({
                    x: Math.random() * (terrainCanvas.width - 100) + 50,
                    y: 50,
                    vx: (Math.random() - 0.5) * 4,
                    vy: 0,
                    radius: 10 + Math.random() * 10,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            });

            document.getElementById('resetTerrain').addEventListener('click', () => {
                initTerrain();
            });

            terrainCanvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                const rect = terrainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                destroyTerrain(x, y, explosionSize);
            });

            terrainCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const rect = terrainCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    destroyTerrain(x, y, explosionSize);
                }
            });

            terrainCanvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            terrainCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
            });

            initTerrain();
            animateTerrain();
        }

        // ========================================
        // FIRE SPREAD & BURNING DEMO
        // ========================================
        const thermalCanvas = document.getElementById('thermalCanvas');
        if (thermalCanvas) {
            const thermalCtx = thermalCanvas.getContext('2d');

            const cellSize = 8;
            const cols = Math.floor(thermalCanvas.width / cellSize);
            const rows = Math.floor(thermalCanvas.height / cellSize);

            // Material types
            const MATERIALS = {
                EMPTY: { id: 0, name: 'Empty', flammable: false, color: '#1a1a1a' },
                WOOD: {
                    id: 1,
                    name: 'Wood',
                    flammable: true,
                    ignitionTemp: 180,
                    burnDuration: 150,
                    spreadChance: 0.35,
                    color: '#8B4513',
                    fireColor: '#FF6600'
                },
                GRASS: {
                    id: 2,
                    name: 'Grass',
                    flammable: true,
                    ignitionTemp: 140,
                    burnDuration: 60,
                    spreadChance: 0.65,
                    color: '#228B22',
                    fireColor: '#FF8800'
                },
                STONE: {
                    id: 3,
                    name: 'Stone',
                    flammable: false,
                    color: '#808080'
                },
                WATER: {
                    id: 4,
                    name: 'Water',
                    flammable: false,
                    extinguishes: true,
                    color: '#1E90FF'
                },
                ASH: {
                    id: 5,
                    name: 'Ash',
                    flammable: false,
                    color: '#3a3a3a'
                }
            };

            let grid = [];
            let particles = [];
            let currentMaterial = MATERIALS.WOOD;
            let placingMode = 'material'; // 'material' or 'fire'

            // Initialize grid with terrain
            function initGrid() {
                grid = [];
                particles = [];

                for (let i = 0; i < rows; i++) {
                    grid[i] = [];
                    for (let j = 0; j < cols; j++) {
                        // Generate simple terrain
                        let material = MATERIALS.EMPTY;

                        // Bottom layer: stone
                        if (i > rows - 8) {
                            material = MATERIALS.STONE;
                        }
                        // Grass layer on top of stone
                        else if (i > rows - 12 && i <= rows - 8) {
                            material = Math.random() < 0.7 ? MATERIALS.GRASS : MATERIALS.EMPTY;
                        }
                        // Random wood patches
                        else if (i > rows - 25 && Math.random() < 0.03) {
                            material = MATERIALS.WOOD;
                        }
                        // Small water pools
                        else if (i > rows - 10 && Math.random() < 0.005) {
                            material = MATERIALS.WATER;
                        }

                        grid[i][j] = {
                            material: material,
                            temperature: 20,
                            burning: false,
                            burnTime: 0
                        };
                    }
                }
            }

            // Fire spread logic
            function updateFire() {
                // Update burning cells
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const cell = grid[i][j];

                        if (cell.burning) {
                            cell.burnTime++;

                            // Try to spread to neighbors
                            if (Math.random() < 0.3) {
                                spreadFire(i, j);
                            }

                            // Generate smoke particles
                            if (Math.random() < 0.15) {
                                particles.push({
                                    x: j * cellSize + cellSize / 2 + (Math.random() - 0.5) * cellSize,
                                    y: i * cellSize + cellSize / 2,
                                    vx: (Math.random() - 0.5) * 0.5,
                                    vy: -0.5 - Math.random() * 1.5,
                                    life: 60 + Math.random() * 40,
                                    maxLife: 100,
                                    size: 2 + Math.random() * 3,
                                    type: Math.random() < 0.2 ? 'ember' : 'smoke'
                                });
                            }

                            // Check if burned out
                            if (cell.burnTime > cell.material.burnDuration) {
                                cell.burning = false;
                                cell.material = MATERIALS.ASH;
                                cell.temperature = 100;
                            }
                        } else {
                            // Cool down gradually
                            if (cell.temperature > 20) {
                                cell.temperature -= 0.5;
                            }
                        }
                    }
                }

                // Update particles
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.vy *= 0.98; // Slow down
                    return p.life > 0;
                });
            }

            // Spread fire to neighbors
            function spreadFire(i, j) {
                const neighbors = [
                    [i-1, j], [i+1, j], [i, j-1], [i, j+1],
                    [i-1, j-1], [i-1, j+1], [i+1, j-1], [i+1, j+1]
                ];

                for (const [ni, nj] of neighbors) {
                    if (ni < 0 || ni >= rows || nj < 0 || nj >= cols) continue;

                    const neighbor = grid[ni][nj];
                    const material = neighbor.material;

                    // Water extinguishes nearby fire
                    if (material.extinguishes) {
                        const source = grid[i][j];
                        if (source.burning && Math.random() < 0.1) {
                            source.burning = false;
                            source.temperature = 50;
                        }
                        continue;
                    }

                    // Spread to flammable materials
                    if (material.flammable && !neighbor.burning) {
                        // Heat the neighbor
                        neighbor.temperature += 30;

                        // Try to ignite
                        if (neighbor.temperature > material.ignitionTemp) {
                            if (Math.random() < material.spreadChance) {
                                neighbor.burning = true;
                                neighbor.burnTime = 0;
                            }
                        }
                    }
                }
            }

            // Draw the simulation
            function drawFireDemo() {
                // Clear canvas
                thermalCtx.fillStyle = '#0a0a0a';
                thermalCtx.fillRect(0, 0, thermalCanvas.width, thermalCanvas.height);

                // Draw grid
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const cell = grid[i][j];

                        if (cell.burning) {
                            // Burning animation - flicker between colors
                            const flicker = Math.random();
                            if (flicker < 0.3) {
                                thermalCtx.fillStyle = '#FF0000';
                            } else if (flicker < 0.6) {
                                thermalCtx.fillStyle = cell.material.fireColor || '#FF6600';
                            } else {
                                thermalCtx.fillStyle = '#FFAA00';
                            }
                        } else {
                            thermalCtx.fillStyle = cell.material.color;
                        }

                        thermalCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);

                        // Draw slight glow around hot cells
                        if (!cell.burning && cell.temperature > 100) {
                            const alpha = Math.min(0.4, (cell.temperature - 100) / 200);
                            thermalCtx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
                            thermalCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                        }
                    }
                }

                // Draw particles
                particles.forEach(p => {
                    const alpha = p.life / p.maxLife;

                    if (p.type === 'ember') {
                        thermalCtx.fillStyle = `rgba(255, 150, 50, ${alpha})`;
                    } else {
                        thermalCtx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.6})`;
                    }

                    thermalCtx.beginPath();
                    thermalCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    thermalCtx.fill();
                });
            }

            // Animation loop
            function animateFire() {
                updateFire();
                drawFireDemo();
                requestAnimationFrame(animateFire);
            }

            // Place material at position
            function placeMaterial(x, y, material, radius = 2) {
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const i = gridY + dy;
                        const j = gridX + dx;
                        if (i >= 0 && i < rows && j >= 0 && j < cols) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= radius) {
                                grid[i][j].material = material;
                                grid[i][j].burning = false;
                                grid[i][j].temperature = 20;
                                grid[i][j].burnTime = 0;
                            }
                        }
                    }
                }
            }

            // Ignite fire at position
            function igniteFire(x, y, radius = 1) {
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const i = gridY + dy;
                        const j = gridX + dx;
                        if (i >= 0 && i < rows && j >= 0 && j < cols) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= radius) {
                                const cell = grid[i][j];
                                if (cell.material.flammable) {
                                    cell.burning = true;
                                    cell.burnTime = 0;
                                    cell.temperature = 300;
                                }
                            }
                        }
                    }
                }
            }

            // Material selection buttons
            const materialButtons = {
                wood: document.getElementById('placeMaterial'),
                grass: document.getElementById('placeGrass'),
                stone: document.getElementById('placeStone'),
                water: document.getElementById('placeWater')
            };

            function setActiveMaterial(button, material) {
                // Remove active class from all
                Object.values(materialButtons).forEach(btn => {
                    btn.style.backgroundColor = '';
                    btn.style.fontWeight = '';
                });

                // Set active
                button.style.backgroundColor = '#2a2a2a';
                button.style.fontWeight = 'bold';
                currentMaterial = material;
                placingMode = 'material';
            }

            materialButtons.wood.addEventListener('click', () => {
                setActiveMaterial(materialButtons.wood, MATERIALS.WOOD);
            });

            materialButtons.grass.addEventListener('click', () => {
                setActiveMaterial(materialButtons.grass, MATERIALS.GRASS);
            });

            materialButtons.stone.addEventListener('click', () => {
                setActiveMaterial(materialButtons.stone, MATERIALS.STONE);
            });

            materialButtons.water.addEventListener('click', () => {
                setActiveMaterial(materialButtons.water, MATERIALS.WATER);
            });

            document.getElementById('ignite').addEventListener('click', () => {
                placingMode = 'fire';
                // Highlight ignite button
                Object.values(materialButtons).forEach(btn => {
                    btn.style.backgroundColor = '';
                    btn.style.fontWeight = '';
                });
                document.getElementById('ignite').style.backgroundColor = '#2a2a2a';
                document.getElementById('ignite').style.fontWeight = 'bold';
            });

            document.getElementById('resetThermal').addEventListener('click', () => {
                initGrid();
                setActiveMaterial(materialButtons.wood, MATERIALS.WOOD);
            });

            // Mouse interaction
            let isMouseDown = false;

            thermalCanvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                const rect = thermalCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (placingMode === 'fire') {
                    igniteFire(x, y, 2);
                } else {
                    placeMaterial(x, y, currentMaterial, 2);
                }
            });

            thermalCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const rect = thermalCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (placingMode === 'fire') {
                        igniteFire(x, y, 1);
                    } else {
                        placeMaterial(x, y, currentMaterial, 2);
                    }
                }
            });

            thermalCanvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            thermalCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
            });

            // Initialize
            initGrid();
            setActiveMaterial(materialButtons.wood, MATERIALS.WOOD);
            animateFire();
        }

    </script>
</body>
</html>
