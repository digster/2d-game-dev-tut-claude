<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üåä Simulation Systems</h1>
        <p class="subtitle">Advanced simulation techniques - Fluids, cloth, and realistic effects</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="expert.html" class="nav-button">Expert</a>
            <a href="simulation.html" class="nav-button active">Simulation</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#fluid-dynamics">Fluid Dynamics Simulation (Grid-Based)</a></li>
                <li><a href="#game-mechanics">Fluid Dynamics as Game Mechanics</a>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><a href="#game-mechanics">‚Üí Water Buoyancy & Floating Objects</a></li>
                        <li><a href="#game-mechanics">‚Üí Rising Water Challenge (Platformer)</a></li>
                        <li><a href="#game-mechanics">‚Üí Particle-Based Water (SPH)</a></li>
                        <li><a href="#game-mechanics">‚Üí Flow Direction & Collection</a></li>
                    </ul>
                </li>
                <li><a href="#wind-weather">Wind & Weather Systems</a></li>
                <li><a href="#destructible-terrain">Destructible Terrain</a></li>
                <li><a href="#thermal-simulation">Thermal Simulation</a></li>
            </ul>
        </div>

        <!-- FLUID DYNAMICS -->
        <div id="fluid-dynamics" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåä Fluid Dynamics Simulation</h2>

            <div class="concept-box">
                <h4>What is Fluid Simulation?</h4>
                <p>Fluid simulation recreates the behavior of liquids and gases - water splashing, smoke rising, or fire spreading. In games, we often use simplified models that look realistic without the massive computational cost of real physics.</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Instead of simulating individual water molecules, we divide space into a grid and calculate how properties like velocity, pressure, and density flow between neighboring cells.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Fluids Work: The Basics</h4>
                <p>Real fluids follow the <strong>Navier-Stokes equations</strong>, but don't worry - we'll break this down into simple concepts!</p>

                <ul>
                    <li><strong>Advection:</strong> Fluid carries things along with it (like a river carrying a leaf)</li>
                    <li><strong>Diffusion:</strong> Properties spread out over time (like ink dispersing in water)</li>
                    <li><strong>Pressure:</strong> Fluid pushes away from high-pressure areas</li>
                    <li><strong>Incompressibility:</strong> Liquid volume stays constant (water doesn't compress)</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Fluid Grid Setup</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Fluid simulation grid</span>
<span class="keyword">class</span> <span class="function">FluidGrid</span> {
    <span class="keyword">constructor</span>(width, height, scale) {
        <span class="keyword">this</span>.cols = Math.<span class="function">floor</span>(width / scale);
        <span class="keyword">this</span>.rows = Math.<span class="function">floor</span>(height / scale);
        <span class="keyword">this</span>.scale = scale;

        <span class="comment">// Create grids for velocity (in X and Y directions)</span>
        <span class="keyword">this</span>.vx = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Previous velocity (for stability)</span>
        <span class="keyword">this</span>.vx0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Density (for visualization - like dye in water)</span>
        <span class="keyword">this</span>.density = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.density0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
    }

    <span class="function">createGrid</span>() {
        <span class="keyword">const</span> grid = [];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
            grid[i] = <span class="keyword">new</span> <span class="function">Array</span>(<span class="keyword">this</span>.cols).<span class="function">fill</span>(<span class="number">0</span>);
        }
        <span class="keyword">return</span> grid;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Diffusion (Spreading)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Diffusion spreads values to neighbors
// Like heat spreading through metal or ink dispersing in water</span>
<span class="function">diffuse</span>(x, x0, diffusion, dt) {
    <span class="keyword">const</span> a = dt * diffusion * <span class="keyword">this</span>.cols * <span class="keyword">this</span>.rows;

    <span class="comment">// Gauss-Seidel iteration for stability</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                <span class="comment">// Average with neighbors, weighted by diffusion rate</span>
                x[i][j] = (x0[i][j] + a * (
                    x[i - <span class="number">1</span>][j] + x[i + <span class="number">1</span>][j] +
                    x[i][j - <span class="number">1</span>] + x[i][j + <span class="number">1</span>]
                )) / (<span class="number">1</span> + <span class="number">4</span> * a);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Diffusion:</h4>
                    <p>Think of a drop of food coloring in water. It starts concentrated, then slowly spreads out. Each cell shares a bit of its "stuff" with neighbors. The <code>diffusion</code> parameter controls how fast this happens.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Advection (Flow)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Advection moves values along the velocity field
// Like a river carrying leaves downstream</span>
<span class="function">advect</span>(d, d0, vx, vy, dt) {
    <span class="keyword">const</span> dt0 = dt * <span class="keyword">this</span>.cols;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            <span class="comment">// Trace backwards along velocity</span>
            <span class="keyword">let</span> x = j - dt0 * vx[i][j];
            <span class="keyword">let</span> y = i - dt0 * vy[i][j];

            <span class="comment">// Clamp to grid boundaries</span>
            x = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.cols - <span class="number">1.5</span>, x));
            y = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.rows - <span class="number">1.5</span>, y));

            <span class="comment">// Interpolate between grid cells</span>
            <span class="keyword">const</span> i0 = Math.<span class="function">floor</span>(y);
            <span class="keyword">const</span> i1 = i0 + <span class="number">1</span>;
            <span class="keyword">const</span> j0 = Math.<span class="function">floor</span>(x);
            <span class="keyword">const</span> j1 = j0 + <span class="number">1</span>;

            <span class="keyword">const</span> s1 = x - j0;
            <span class="keyword">const</span> s0 = <span class="number">1</span> - s1;
            <span class="keyword">const</span> t1 = y - i0;
            <span class="keyword">const</span> t0 = <span class="number">1</span> - t1;

            <span class="comment">// Bilinear interpolation</span>
            d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                      s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Advection:</h4>
                    <p>Imagine you drop dye in a moving river. The dye doesn't just sit there - it flows with the water. Advection does this: for each cell, we look backward along the velocity to see where the fluid came from, then bring that value forward.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Pressure & Incompressibility</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Project removes divergence (ensures fluid is incompressible)
// This is what makes fluid behave like liquid, not gas</span>
<span class="function">project</span>(vx, vy, p, div) {
    <span class="comment">// Calculate divergence (how much fluid is leaving each cell)</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            div[i][j] = -<span class="number">0.5</span> * (
                vx[i][j + <span class="number">1</span>] - vx[i][j - <span class="number">1</span>] +
                vy[i + <span class="number">1</span>][j] - vy[i - <span class="number">1</span>][j]
            ) / <span class="keyword">this</span>.cols;
            p[i][j] = <span class="number">0</span>;
        }
    }

    <span class="comment">// Solve for pressure using iterative method</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                p[i][j] = (div[i][j] +
                    p[i - <span class="number">1</span>][j] + p[i + <span class="number">1</span>][j] +
                    p[i][j - <span class="number">1</span>] + p[i][j + <span class="number">1</span>]
                ) / <span class="number">4</span>;
            }
        }
    }

    <span class="comment">// Subtract pressure gradient from velocity</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            vx[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i][j + <span class="number">1</span>] - p[i][j - <span class="number">1</span>]);
            vy[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i + <span class="number">1</span>][j] - p[i - <span class="number">1</span>][j]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pressure:</h4>
                    <p>Water doesn't compress easily. If too much water flows into a cell, pressure builds up and pushes it out to neighbors. This step ensures the simulation stays physically plausible - the same amount of fluid stays in the system.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Complete Simulation Step</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Main simulation step - call this every frame</span>
<span class="function">step</span>(dt = <span class="number">0.016</span>) {
    <span class="keyword">const</span> visc = <span class="number">0.0001</span>;  <span class="comment">// Viscosity (thickness of fluid)</span>
    <span class="keyword">const</span> diff = <span class="number">0.0001</span>;  <span class="comment">// Diffusion rate</span>

    <span class="comment">// 1. Diffuse velocity (friction between fluid layers)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, visc, dt);
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, visc, dt);

    <span class="comment">// 2. Project (fix velocity to be incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 3. Advect velocity (velocity moves itself)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);

    <span class="comment">// 4. Project again (ensure still incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 5. Diffuse density (dye spreads out)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, diff, dt);

    <span class="comment">// 6. Advect density (velocity carries dye along)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, <span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, dt);

    <span class="comment">// 7. Fade density over time (optional, for visual effect)</span>
    <span class="keyword">this</span>.<span class="function">fadeDensity</span>(<span class="number">0.99</span>);
}

<span class="function">fadeDensity</span>(fadeRate) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++) {
            <span class="keyword">this</span>.density[i][j] *= fadeRate;
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Fluid Simulation</h3>
            <div class="example-box">
                <strong>üñ±Ô∏è How to Use:</strong> Click and drag on the canvas below to add fluid and watch it flow! Try different presets and features below.
            </div>
            <div class="diagram">
                <canvas id="fluidDemo" width="800" height="600" style="border: 1px solid #444;"></canvas>
            </div>

            <div class="controls" style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px;">
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Presets:</strong>
                    <button id="btnWater">üíß Water</button>
                    <button id="btnSmoke">üí® Smoke</button>
                    <button id="btnInk">üñãÔ∏è Ink</button>
                    <button id="btnHoney">üçØ Honey</button>
                    <button id="btnGas">‚òÅÔ∏è Gas</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Features:</strong>
                    <button id="btnVelocity">Show Velocity Field</button>
                    <button id="btnAddObstacle">Add Obstacle (Click Canvas)</button>
                    <button id="btnClearObstacles">Clear Obstacles</button>
                    <button id="btnContinuousSource">Continuous Source</button>
                    <button id="btnWind">Toggle Wind</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Quick Switch:</strong>
                    <button id="btnColorDefault">üíß Water</button>
                    <button id="btnColorRainbow">üåà Ink</button>
                    <button id="btnColorFire">üçØ Honey</button>
                    <button id="btnColorBlue">‚òÅÔ∏è Gas</button>
                    <button id="btnClearFluid">üóëÔ∏è Clear All</button>
                </div>

                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <label>
                        Viscosity: <input type="range" id="viscSlider" min="0" max="0.002" step="0.0001" value="0.0001">
                        <span id="viscValue">0.0001</span>
                    </label>
                    <label>
                        Diffusion: <input type="range" id="diffSlider" min="0" max="0.001" step="0.0001" value="0.0001">
                        <span id="diffValue">0.0001</span>
                    </label>
                    <label>
                        Fade Rate: <input type="range" id="fadeSlider" min="0.9" max="1" step="0.01" value="0.99">
                        <span id="fadeValue">0.99</span>
                    </label>
                </div>
            </div>

            <div class="info-display" id="fluidInfo" style="margin-top: 10px;">
                Current Mode: Free Draw | Click and drag to add fluid
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üé® Try These Examples (Each Material Looks Completely Different!):</h4>
                <ol>
                    <li><strong>üíß Water (Clear Blue):</strong> Flows freely with a cyan-blue transparent appearance. Great for water effects!</li>
                    <li><strong>üí® Smoke (Gray Wisps):</strong> Soft gray with glow effect that rises upward. Click "Continuous Source" to see it billow!</li>
                    <li><strong>üñãÔ∏è Ink (Rainbow Colors):</strong> Vibrant multicolored fluid that creates beautiful psychedelic patterns</li>
                    <li><strong>üçØ Honey (Golden Amber):</strong> Rich golden color, very thick and viscous - watch it pour slowly!</li>
                    <li><strong>‚òÅÔ∏è Gas (Green-Yellow):</strong> Light greenish with glow, disperses quickly and rises slightly</li>
                    <li><strong>Add Obstacles:</strong> Try any material with obstacles to see realistic flow patterns!</li>
                </ol>
            </div>

            <div class="example-box" style="margin-top: 20px;">
                <h4>‚öôÔ∏è Understanding the Parameters:</h4>
                <ul>
                    <li><strong>Viscosity:</strong> How "thick" the fluid is
                        <ul>
                            <li>Low (0.00001) = Water, gas - flows freely</li>
                            <li>High (0.001) = Honey, syrup - very thick and slow</li>
                        </ul>
                    </li>
                    <li><strong>Diffusion:</strong> How fast properties spread out
                        <ul>
                            <li>Low = Fluid stays concentrated</li>
                            <li>High = Fluid disperses quickly like smoke or gas</li>
                        </ul>
                    </li>
                    <li><strong>Fade Rate:</strong> How quickly density disappears
                        <ul>
                            <li>0.95 = Fades very quickly (good for gas effects)</li>
                            <li>0.999 = Stays visible for a long time (good for permanent liquids)</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üéØ Visual Features & Material Properties:</h4>
                <ul>
                    <li><strong>Material-Specific Colors:</strong> Each material has unique colors, transparency, and background
                        <ul>
                            <li>üíß <strong>Water:</strong> Cyan-blue on dark blue background (70% opacity)</li>
                            <li>üí® <strong>Smoke:</strong> Soft gray with glow effect on dark gray bg (50% opacity)</li>
                            <li>üñãÔ∏è <strong>Ink:</strong> Rainbow gradient on black background (90% opacity)</li>
                            <li>üçØ <strong>Honey:</strong> Golden amber on brown background (85% opacity)</li>
                            <li>‚òÅÔ∏è <strong>Gas:</strong> Green-yellow with glow on greenish bg (40% opacity)</li>
                        </ul>
                    </li>
                    <li><strong>Velocity Field:</strong> White arrows showing fluid movement direction and speed</li>
                    <li><strong>Obstacles:</strong> Gray barriers that create realistic flow patterns around them</li>
                    <li><strong>Continuous Source:</strong> Constant fluid stream from top center</li>
                    <li><strong>Wind/Buoyancy:</strong> Upward force (automatic for smoke and gas)</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üéÆ Game Usage:</strong> Fluid simulation is perfect for water effects, smoke, fire, magic spells, and atmospheric effects. Adjust grid resolution for performance - smaller grids run faster but look less detailed.
            </div>

            <div class="example-box">
                <h4>‚ö° Performance Tips:</h4>
                <ul>
                    <li><strong>Grid Size:</strong> Use smaller grids (32x32 or 64x64) for real-time games</li>
                    <li><strong>Iterations:</strong> Reduce iteration count (10-15) if too slow</li>
                    <li><strong>GPU:</strong> Consider WebGL shaders for large simulations</li>
                    <li><strong>Hybrid:</strong> Combine simple particle systems with fluid for best visual/performance ratio</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>üìö Further Reading:</h4>
                <ul>
                    <li><strong>Navier-Stokes Equations:</strong> The full physics of fluid motion</li>
                    <li><strong>Jos Stam's "Stable Fluids":</strong> The paper this technique is based on</li>
                    <li><strong>SPH (Smoothed Particle Hydrodynamics):</strong> Alternative particle-based approach</li>
                    <li><strong>Level Set Methods:</strong> For tracking fluid surfaces</li>
                </ul>
            </div>
        </div>

        <!-- GAME MECHANICS DEMOS -->
        <div id="game-mechanics" class="section">
            <h2>üéÆ Fluid Dynamics as Game Mechanics</h2>
            <p>Let's see how fluid simulation translates into actual playable game mechanics!</p>

            <!-- Demo 1: Water Buoyancy -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>1. üåä Water Buoyancy & Floating Objects</h3>
                <p>Objects float or sink based on their density. This is used in games for boats, swimming mechanics, and physics puzzles.</p>

                <div class="diagram">
                    <canvas id="buoyancyDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddBox">Add Box (Floats)</button>
                    <button id="btnAddStone">Add Stone (Sinks)</button>
                    <button id="btnAddBall">Add Ball (Bounces)</button>
                    <button id="btnDrain">Drain Water</button>
                    <button id="btnFill">Fill Water</button>
                    <button id="btnResetBuoyancy">Reset</button>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to drop objects! Lighter objects float, heavier ones sink. Watch buoyancy forces in action!
                </div>
            </div>

            <!-- Demo 2: Rising Water Level -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>2. ‚è´ Rising Water Challenge</h3>
                <p>Classic escape mechanic - water rises and the player must climb to safety! Used in platformers and puzzle games.</p>

                <div class="diagram">
                    <canvas id="risingWaterDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnStartRising">Start Water Rising</button>
                    <button id="btnStopRising">Stop</button>
                    <button id="btnResetRising">Reset Level</button>
                    <span style="margin-left: 20px;">Use Arrow Keys to move the player</span>
                </div>
                <div class="info-display" id="risingWaterInfo" style="margin-top: 10px;">
                    Climb the platforms before the water reaches you! Player moves slower in water.
                </div>
            </div>

            <!-- Demo 3: Particle-Based Water (SPH) -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>3. üíß Particle-Based Water (SPH)</h3>
                <p>Smoothed Particle Hydrodynamics - each water particle interacts with neighbors. Great for splash effects and destructible water.</p>

                <div class="diagram">
                    <canvas id="sphDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddWater">Add Water Particles</button>
                    <button id="btnAddBarrier">Add Barrier (Click Canvas)</button>
                    <button id="btnToggleGravity">Toggle Gravity</button>
                    <button id="btnResetSPH">Reset</button>
                    <label>
                        Viscosity: <input type="range" id="sphViscosity" min="0.1" max="1" step="0.1" value="0.5">
                        <span id="sphViscValue">0.5</span>
                    </label>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to add water particles. They attract each other and flow like real liquid!
                </div>
            </div>

            <!-- Demo 4: Flow-Based Puzzle -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>4. üß© Flow Direction Mechanic (Simplified)</h3>
                <p>Water flows downward but can be redirected. This demo shows the concept behind puzzle games like "Where's My Water?" - simplified for clarity.</p>

                <div class="diagram">
                    <canvas id="flowPuzzleDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnRelease">Release Water</button>
                    <button id="btnAddPlatform">Add Platform (Blocks Water)</button>
                    <button id="btnResetPuzzle">Reset</button>
                    <span style="margin-left: 20px; font-weight: bold;" id="puzzleStatus">Watch water flow and collect</span>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click "Release Water" to start. Water flows down naturally and fills the bucket. Click "Add Platform" then click canvas to block water flow.
                </div>

                <div class="key-point" style="margin-top: 15px;">
                    <strong>üí° Implementation Note:</strong> Full pipe-routing puzzles require complex pathfinding logic. This simplified demo shows the core concept: water as particles that follow simple rules (gravity + obstacles). For production games, consider using:
                    <ul style="margin-top: 5px;">
                        <li>Grid-based flow fields for directing water</li>
                        <li>Waypoint systems for pipe networks</li>
                        <li>Simplified particle systems for visual effects</li>
                    </ul>
                </div>
            </div>

            <div class="key-point" style="margin-top: 30px;">
                <strong>üí° Design Tip:</strong> Different fluid representations work for different game types:
                <ul style="margin-top: 10px;">
                    <li><strong>Grid-based (Navier-Stokes):</strong> Best for atmospheric effects, smoke, gas - continuous fields</li>
                    <li><strong>Particle-based (SPH):</strong> Best for interactive water, splashes, destruction - discrete elements</li>
                    <li><strong>Simplified/Fake:</strong> Best for performance-critical games - rising water levels, flow direction only</li>
                </ul>
            </div>
        </div>

        <!-- WIND/WEATHER SYSTEMS -->
        <div id="wind-weather" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üå¨Ô∏è Wind & Weather Systems</h2>

            <div class="concept-box">
                <h4>What is a Wind System?</h4>
                <p>Wind systems simulate invisible forces that affect objects in your game world - like leaves blowing in the breeze, projectiles being deflected, or a character's cape flowing. In games like Zelda: Breath of the Wild or Genshin Impact, wind isn't just visual - it's a gameplay mechanic!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Wind is just a vector field - at every point in space, there's a force vector pushing objects in a direction. We can make this field dynamic, turbulent, and interactive to create realistic weather effects.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Wind Works</h4>
                <p>Think of wind as an invisible river of air flowing through your game world:</p>

                <ul>
                    <li><strong>Vector Field:</strong> Each point in space has a wind direction and strength</li>
                    <li><strong>Turbulence:</strong> Random fluctuations make wind feel natural, not mechanical</li>
                    <li><strong>Obstacles:</strong> Wind flows around objects and creates sheltered areas</li>
                    <li><strong>Gusts:</strong> Temporary increases in wind strength create dynamic effects</li>
                </ul>
            </div>

            <!-- Interactive Demo: Wind Particles -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üçÉ Interactive Demo: Wind Field Visualization</h3>
                <p>Watch particles flow through a dynamic wind field! Click to create wind gusts.</p>

                <div class="diagram">
                    <canvas id="windCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <label>Wind Strength: <span id="windStrengthDisplay">1.0</span></label>
                    <input type="range" id="windStrengthSlider" min="0" max="3" step="0.1" value="1.0">
                    <label>Turbulence: <span id="turbulenceDisplay">0.5</span></label>
                    <input type="range" id="turbulenceSlider" min="0" max="2" step="0.1" value="0.5">
                    <button id="toggleWindVectors">Toggle Wind Vectors</button>
                    <button id="resetWindDemo">Reset</button>
                </div>
                <div class="info-display">
                    Click anywhere to create a wind gust! Watch particles flow with the wind.
                </div>
            </div>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li>Wind is a <strong>vector field</strong> - force at every point in space</li>
                    <li>Use <strong>noise functions</strong> for natural, flowing turbulence</li>
                    <li><strong>Grid-based calculation</strong> + interpolation = smooth, efficient wind</li>
                    <li><strong>Gusts</strong> add dynamic, interactive gameplay opportunities</li>
                    <li>Wind can be both <strong>aesthetic</strong> (particles, effects) and <strong>mechanical</strong> (gameplay)</li>
                </ul>
            </div>
        </div>

        <!-- DESTRUCTIBLE TERRAIN -->
        <div id="destructible-terrain" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üí• Destructible Terrain</h2>

            <div class="concept-box">
                <h4>What is Destructible Terrain?</h4>
                <p>Destructible terrain lets players break, dig, or reshape the game world. Think of games like Minecraft (block-based destruction), Worms (pixel-perfect terrain removal), or Red Faction (realistic structural damage). It's a powerful mechanic that gives players agency and creates emergent gameplay!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Represent terrain as a grid of cells or pixels. When something damages terrain, remove or modify those cells, then update physics and visuals accordingly. The challenge is making this fast and fun!
                </div>
            </div>

            <div class="concept-box">
                <h4>Three Approaches to Destructible Terrain</h4>

                <ul>
                    <li><strong>Grid/Voxel Based:</strong> World divided into blocks (like Minecraft)
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Fast collision detection</li>
                            <li>Easy to implement</li>
                            <li>Looks blocky unless cells are tiny</li>
                        </ul>
                    </li>
                    <li><strong>Pixel/Bitmap Based:</strong> Every pixel can be destroyed (like Worms)
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Smooth, organic destruction</li>
                            <li>Perfect for 2D games</li>
                            <li>More complex collision detection</li>
                        </ul>
                    </li>
                    <li><strong>Chunk/Region Based:</strong> Pre-made destructible pieces
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>Controlled destruction (buildings collapsing)</li>
                            <li>Can look very realistic</li>
                            <li>Limited interactivity</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üéÆ Game Applications:</h4>
                <ul>
                    <li><strong>Mining/Digging games:</strong> Terraria, Dig Dug - core gameplay loop</li>
                    <li><strong>Strategy games:</strong> Worms, Scorched Earth - terrain affects tactics</li>
                    <li><strong>Puzzle games:</strong> Remove terrain to guide objects to goals</li>
                    <li><strong>Destruction games:</strong> Red Faction, Battlefield - environmental damage</li>
                    <li><strong>Platformers:</strong> Breakable floors, walls create shortcuts</li>
                </ul>
            </div>

            <!-- Interactive Demo: Destructible Terrain -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üí• Interactive Demo: Pixel-Based Destructible Terrain</h3>
                <p>Click and drag to destroy terrain! Drop balls to see physics interact with the destroyed areas.</p>

                <div class="diagram">
                    <canvas id="terrainCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <label>Explosion Size: <span id="explosionSizeDisplay">30</span></label>
                    <input type="range" id="explosionSizeSlider" min="10" max="80" step="5" value="30">
                    <button id="addBall">Drop Ball</button>
                    <button id="resetTerrain">Reset Terrain</button>
                </div>
                <div class="info-display">
                    Click and drag to destroy terrain! Watch physics objects interact with the destruction.
                </div>
            </div>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li><strong>Grid-based</strong> is easiest to implement and fastest for collision</li>
                    <li><strong>Pixel-based</strong> looks smoother but needs spatial partitioning for performance</li>
                    <li>Always <strong>update both visual and collision</strong> representations together</li>
                    <li><strong>Add particle effects</strong> when terrain breaks for satisfying feedback</li>
                    <li>Consider <strong>regrowth or repair</strong> mechanics to prevent terrain depletion</li>
                </ul>
            </div>
        </div>

        <!-- THERMAL SIMULATION -->
        <div id="thermal-simulation" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üî• Thermal Simulation</h2>

            <div class="concept-box">
                <h4>What is Thermal Simulation?</h4>
                <p>Thermal simulation models heat spreading through your game world. Fire spreads to nearby flammable objects, ice melts near heat sources, or lava creates danger zones. Games like Minecraft (fire spread), Don't Starve (temperature mechanics), and Oxygen Not Included (complex heat systems) use these mechanics!</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Just like fluid simulation, we use a grid where each cell has a temperature value. Heat flows from hot cells to cold cells over time (thermal diffusion), and temperature affects object behavior - things melt, burn, or freeze!
                </div>
            </div>

            <div class="concept-box">
                <h4>How Heat Works in Games</h4>
                <p>Think of heat like water flowing downhill - it naturally spreads from hot to cold:</p>

                <ul>
                    <li><strong>Conduction:</strong> Heat spreads to neighboring cells (like a metal rod heating up)</li>
                    <li><strong>Sources & Sinks:</strong> Fire adds heat, ice absorbs it</li>
                    <li><strong>Material Properties:</strong> Some materials conduct heat faster than others</li>
                    <li><strong>Thresholds:</strong> At certain temperatures, state changes happen (water‚Üísteam, ice‚Üíwater)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üéÆ Game Applications:</h4>
                <ul>
                    <li><strong>Fire spread mechanics:</strong> Forest fires, burning buildings spread to nearby objects</li>
                    <li><strong>Survival games:</strong> Stay warm near fires, avoid freezing in cold areas</li>
                    <li><strong>Puzzle mechanics:</strong> Melt ice to reveal paths, cool lava to cross it</li>
                    <li><strong>Combat systems:</strong> Fire spells create lingering heat zones, ice spells freeze water</li>
                    <li><strong>Resource management:</strong> Ovens, furnaces need fuel and time to heat up</li>
                </ul>
            </div>

            <!-- Interactive Demo: Thermal Simulation -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>üî• Interactive Demo: Heat Spreading & Fire</h3>
                <p>Click to add heat sources! Watch heat spread through the grid and ignite flammable materials.</p>

                <div class="diagram">
                    <canvas id="thermalCanvas" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="addFire">Add Fire (Click Canvas)</button>
                    <button id="addIce">Add Ice (Click Canvas)</button>
                    <label>Diffusion Rate: <span id="diffusionDisplay">0.5</span></label>
                    <input type="range" id="diffusionSlider" min="0.1" max="1.0" step="0.1" value="0.5">
                    <button id="resetThermal">Reset</button>
                </div>
                <div class="info-display">
                    Red = Hot, Blue = Cold. Watch heat spread naturally from hot to cold areas!
                </div>
            </div>

            <div class="key-point">
                <strong>üéØ Key Takeaways:</strong>
                <ul>
                    <li>Temperature is just another <strong>grid-based property</strong> like fluid density</li>
                    <li>Use <strong>diffusion algorithms</strong> to spread heat naturally between cells</li>
                    <li><strong>Material properties</strong> control how fast heat spreads (conductivity)</li>
                    <li><strong>State changes</strong> at temperature thresholds create interesting gameplay</li>
                    <li>Combine with <strong>other systems</strong> (fire + wind = spreading fire in wind direction!)</li>
                </ul>
            </div>
        </div>

        <!-- Scroll to Top Button -->
        <div class="scroll-to-top" id="scrollToTop">‚Üë</div>
    </div>

    <script>
        // Scroll to top functionality
        const scrollToTopBtn = document.getElementById('scrollToTop');

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.style.opacity = '1';
            } else {
                scrollToTopBtn.style.opacity = '0';
            }
        });

        scrollToTopBtn.style.opacity = '0';
        scrollToTopBtn.style.transition = 'opacity 0.3s';

        // ===================================
        // FLUID SIMULATION DEMO
        // ===================================

        // Ensure DOM is loaded
        const canvas = document.getElementById('fluidDemo');
        const ctx = canvas.getContext('2d');

        if (!canvas || !ctx) {
            console.error('Canvas not found!');
        } else {

        class FluidGrid {
            constructor(width, height, scale) {
                this.cols = Math.floor(width / scale);
                this.rows = Math.floor(height / scale);
                this.scale = scale;

                this.vx = this.createGrid();
                this.vy = this.createGrid();
                this.vx0 = this.createGrid();
                this.vy0 = this.createGrid();

                this.density = this.createGrid();
                this.density0 = this.createGrid();

                // For projection
                this.p = this.createGrid();
                this.div = this.createGrid();

                // Obstacles (1 = blocked, 0 = free)
                this.obstacles = this.createGrid();

                // Settings
                this.visc = 0.0001;
                this.diff = 0.0001;
                this.fadeRate = 0.99;

                // Visual settings
                this.colorMode = 'default';
                this.showVelocity = false;
                this.material = 'water'; // water, smoke, ink, honey, gas

                // Wind/gravity
                this.windX = 0;
                this.windY = 0;
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.rows; i++) {
                    grid[i] = new Array(this.cols).fill(0);
                }
                return grid;
            }

            diffuse(x, x0, diffusion, dt) {
                const a = dt * diffusion * this.cols * this.rows;

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            if (this.obstacles[i][j] === 1) continue;

                            x[i][j] = (x0[i][j] + a * (
                                x[i - 1][j] + x[i + 1][j] +
                                x[i][j - 1] + x[i][j + 1]
                            )) / (1 + 4 * a);
                        }
                    }
                    this.setBoundary(0, x);
                }
            }

            advect(d, d0, vx, vy, dt) {
                const dt0 = dt * this.cols;

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        if (this.obstacles[i][j] === 1) {
                            d[i][j] = 0;
                            continue;
                        }

                        let x = j - dt0 * vx[i][j];
                        let y = i - dt0 * vy[i][j];

                        x = Math.max(0.5, Math.min(this.cols - 1.5, x));
                        y = Math.max(0.5, Math.min(this.rows - 1.5, y));

                        const i0 = Math.floor(y);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(x);
                        const j1 = j0 + 1;

                        const s1 = x - j0;
                        const s0 = 1 - s1;
                        const t1 = y - i0;
                        const t0 = 1 - t1;

                        d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                                  s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
                    }
                }
                this.setBoundary(0, d);
            }

            project(vx, vy, p, div) {
                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        div[i][j] = -0.5 * (
                            vx[i][j + 1] - vx[i][j - 1] +
                            vy[i + 1][j] - vy[i - 1][j]
                        ) / this.cols;
                        p[i][j] = 0;
                    }
                }
                this.setBoundary(0, div);
                this.setBoundary(0, p);

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            p[i][j] = (div[i][j] +
                                p[i - 1][j] + p[i + 1][j] +
                                p[i][j - 1] + p[i][j + 1]
                            ) / 4;
                        }
                    }
                    this.setBoundary(0, p);
                }

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        vx[i][j] -= 0.5 * this.cols * (p[i][j + 1] - p[i][j - 1]);
                        vy[i][j] -= 0.5 * this.cols * (p[i + 1][j] - p[i - 1][j]);
                    }
                }
                this.setBoundary(1, vx);
                this.setBoundary(2, vy);
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.rows - 1; i++) {
                    x[i][0] = b === 1 ? -x[i][1] : x[i][1];
                    x[i][this.cols - 1] = b === 1 ? -x[i][this.cols - 2] : x[i][this.cols - 2];
                }
                for (let j = 1; j < this.cols - 1; j++) {
                    x[0][j] = b === 2 ? -x[1][j] : x[1][j];
                    x[this.rows - 1][j] = b === 2 ? -x[this.rows - 2][j] : x[this.rows - 2][j];
                }

                x[0][0] = 0.5 * (x[1][0] + x[0][1]);
                x[0][this.cols - 1] = 0.5 * (x[1][this.cols - 1] + x[0][this.cols - 2]);
                x[this.rows - 1][0] = 0.5 * (x[this.rows - 2][0] + x[this.rows - 1][1]);
                x[this.rows - 1][this.cols - 1] = 0.5 * (x[this.rows - 2][this.cols - 1] + x[this.rows - 1][this.cols - 2]);
            }

            step(dt = 0.016) {
                // Apply wind/gravity
                if (this.windX !== 0 || this.windY !== 0) {
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            this.vx[i][j] += this.windX * dt * 10;
                            this.vy[i][j] += this.windY * dt * 10;
                        }
                    }
                }

                // Swap arrays
                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.diffuse(this.vx, this.vx0, this.visc, dt);
                this.diffuse(this.vy, this.vy0, this.visc, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.advect(this.vx, this.vx0, this.vx0, this.vy0, dt);
                this.advect(this.vy, this.vy0, this.vx0, this.vy0, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.density0, this.density] = [this.density, this.density0];

                this.diffuse(this.density, this.density0, this.diff, dt);

                [this.density0, this.density] = [this.density, this.density0];

                this.advect(this.density, this.density0, this.vx, this.vy, dt);

                this.fadeDensity(this.fadeRate);
            }

            fadeDensity(fadeRate) {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.density[i][j] *= fadeRate;
                    }
                }
            }

            addDensity(x, y, amount) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.density[i][j] += amount;
                }
            }

            addVelocity(x, y, vx, vy) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.vx[i][j] += vx;
                    this.vy[i][j] += vy;
                }
            }

            addObstacle(x, y, radius = 3) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);

                for (let di = -radius; di <= radius; di++) {
                    for (let dj = -radius; dj <= radius; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                            if (di * di + dj * dj <= radius * radius) {
                                this.obstacles[ni][nj] = 1;
                            }
                        }
                    }
                }
            }

            clearObstacles() {
                this.obstacles = this.createGrid();
            }

            getColor(density) {
                const d = Math.min(255, Math.floor(density));
                const alpha = Math.min(1, d / 255);

                // Material-specific colors with very distinct appearances
                switch(this.material) {
                    case 'water':
                        // Clear blue water with cyan highlights
                        const waterBlue = Math.floor(150 + (d / 255) * 105);
                        const waterGreen = Math.floor(100 + (d / 255) * 100);
                        return `rgba(30, ${waterGreen}, ${waterBlue}, ${alpha * 0.7})`;

                    case 'smoke':
                        // Gray smoke with slight transparency
                        const smokeGray = Math.floor(100 + (d / 255) * 155);
                        return `rgba(${smokeGray}, ${smokeGray}, ${smokeGray + 20}, ${alpha * 0.5})`;

                    case 'ink':
                        // Vibrant rainbow colors based on density
                        const inkHue = (d / 255) * 360;
                        return `hsla(${inkHue}, 100%, 60%, ${alpha * 0.9})`;

                    case 'honey':
                        // Golden/amber honey color
                        const honeyR = Math.floor(200 + (d / 255) * 55);
                        const honeyG = Math.floor(140 + (d / 255) * 50);
                        const honeyB = Math.floor(20 + (d / 255) * 20);
                        return `rgba(${honeyR}, ${honeyG}, ${honeyB}, ${alpha * 0.85})`;

                    case 'gas':
                        // Light green/yellow gas
                        const gasR = Math.floor(150 + (d / 255) * 80);
                        const gasG = Math.floor(200 + (d / 255) * 55);
                        const gasB = Math.floor(100 + (d / 255) * 60);
                        return `rgba(${gasR}, ${gasG}, ${gasB}, ${alpha * 0.4})`;

                    default:
                        return `rgba(${d}, ${d * 0.5}, ${255 - d}, ${d / 255})`;
                }
            }

            render(ctx) {
                // Background color based on material
                switch(this.material) {
                    case 'water':
                        ctx.fillStyle = '#001020'; // Deep blue-black
                        break;
                    case 'smoke':
                        ctx.fillStyle = '#0a0a0a'; // Dark gray
                        break;
                    case 'honey':
                        ctx.fillStyle = '#1a0f00'; // Dark brown
                        break;
                    case 'gas':
                        ctx.fillStyle = '#0a1008'; // Dark greenish
                        break;
                    default:
                        ctx.fillStyle = '#000';
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw fluid density with glow effect for some materials
                const needsGlow = (this.material === 'gas' || this.material === 'smoke');

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const d = this.density[i][j];
                        if (d > 0) {
                            ctx.fillStyle = this.getColor(d);

                            // Add glow effect for smoke and gas
                            if (needsGlow && d > 50) {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.getColor(d);
                            } else {
                                ctx.shadowBlur = 0;
                            }

                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                ctx.shadowBlur = 0;

                // Draw obstacles
                ctx.fillStyle = '#666';
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.obstacles[i][j] === 1) {
                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                // Draw velocity field
                if (this.showVelocity) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;

                    const step = 4; // Show every 4th cell
                    for (let i = 0; i < this.rows; i += step) {
                        for (let j = 0; j < this.cols; j += step) {
                            const vx = this.vx[i][j];
                            const vy = this.vy[i][j];
                            const mag = Math.sqrt(vx * vx + vy * vy);

                            if (mag > 0.1) {
                                const x = j * this.scale + this.scale / 2;
                                const y = i * this.scale + this.scale / 2;
                                const scale = 5;

                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + vx * scale, y + vy * scale);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
        }

        const fluid = new FluidGrid(canvas.width, canvas.height, 8);

        // Initialize canvas with black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let addingObstacles = false;
        let continuousSource = false;
        let sourceX = canvas.width / 2;
        let sourceY = 50;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            prevMouseX = e.clientX - rect.left;
            prevMouseY = e.clientY - rect.top;

            if (addingObstacles) {
                fluid.addObstacle(prevMouseX, prevMouseY);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (addingObstacles) {
                    fluid.addObstacle(x, y);
                } else {
                    const vx = (x - prevMouseX) * 10;
                    const vy = (y - prevMouseY) * 10;

                    fluid.addDensity(x, y, 200);
                    fluid.addVelocity(x, y, vx, vy);
                }

                prevMouseX = x;
                prevMouseY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // ===================================
        // PRESET BUTTONS
        // ===================================

        document.getElementById('btnWater').addEventListener('click', () => {
            fluid.visc = 0.0001;
            fluid.diff = 0.0001;
            fluid.fadeRate = 0.99;
            fluid.material = 'water';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üíß Water - Clear blue liquid, low viscosity');
        });

        document.getElementById('btnSmoke').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.0005;
            fluid.fadeRate = 0.97;
            fluid.material = 'smoke';
            fluid.windY = -0.8; // Strong upward buoyancy
            updateSliders();
            updateInfo('üí® Smoke - Gray wisps that rise upward with buoyancy');
        });

        document.getElementById('btnInk').addEventListener('click', () => {
            fluid.visc = 0.0002;
            fluid.diff = 0.0003;
            fluid.fadeRate = 0.995;
            fluid.material = 'ink';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üñãÔ∏è Ink - Vibrant rainbow colors, medium viscosity');
        });

        document.getElementById('btnHoney').addEventListener('click', () => {
            fluid.visc = 0.0015;
            fluid.diff = 0.00003;
            fluid.fadeRate = 0.999;
            fluid.material = 'honey';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üçØ Honey - Golden amber, very thick and viscous');
        });

        document.getElementById('btnGas').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.001;
            fluid.fadeRate = 0.94;
            fluid.material = 'gas';
            fluid.windY = -0.3;
            updateSliders();
            updateInfo('‚òÅÔ∏è Gas - Light green/yellow, disperses quickly');
        });

        // ===================================
        // FEATURE BUTTONS
        // ===================================

        document.getElementById('btnVelocity').addEventListener('click', () => {
            fluid.showVelocity = !fluid.showVelocity;
            updateInfo(fluid.showVelocity ? 'Velocity field shown' : 'Velocity field hidden');
        });

        document.getElementById('btnAddObstacle').addEventListener('click', () => {
            addingObstacles = !addingObstacles;
            updateInfo(addingObstacles ? 'Click canvas to add obstacles' : 'Obstacle mode disabled');
        });

        document.getElementById('btnClearObstacles').addEventListener('click', () => {
            fluid.clearObstacles();
            updateInfo('Obstacles cleared');
        });

        document.getElementById('btnContinuousSource').addEventListener('click', () => {
            continuousSource = !continuousSource;
            updateInfo(continuousSource ? 'Continuous source enabled at top center' : 'Continuous source disabled');
        });

        document.getElementById('btnWind').addEventListener('click', () => {
            if (fluid.windY === 0) {
                fluid.windY = -0.5;
                updateInfo('Wind enabled - Upward force');
            } else {
                fluid.windY = 0;
                updateInfo('Wind disabled');
            }
        });

        // ===================================
        // COLOR MODE BUTTONS
        // ===================================

        document.getElementById('btnColorDefault').addEventListener('click', () => {
            fluid.material = 'water';
            updateInfo('Material changed to Water (blue)');
        });

        document.getElementById('btnColorRainbow').addEventListener('click', () => {
            fluid.material = 'ink';
            updateInfo('Material changed to Ink (rainbow)');
        });

        document.getElementById('btnColorFire').addEventListener('click', () => {
            fluid.material = 'honey';
            updateInfo('Material changed to Honey (golden/amber)');
        });

        document.getElementById('btnColorBlue').addEventListener('click', () => {
            fluid.material = 'gas';
            updateInfo('Material changed to Gas (green/yellow)');
        });

        document.getElementById('btnClearFluid').addEventListener('click', () => {
            fluid.density = fluid.createGrid();
            fluid.vx = fluid.createGrid();
            fluid.vy = fluid.createGrid();
            fluid.windX = 0;
            fluid.windY = 0;
            continuousSource = false;
            updateInfo('Fluid cleared');
        });

        // ===================================
        // SLIDERS
        // ===================================

        const viscSlider = document.getElementById('viscSlider');
        const viscValue = document.getElementById('viscValue');
        const diffSlider = document.getElementById('diffSlider');
        const diffValue = document.getElementById('diffValue');
        const fadeSlider = document.getElementById('fadeSlider');
        const fadeValue = document.getElementById('fadeValue');

        viscSlider.addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            viscValue.textContent = fluid.visc.toFixed(4);
        });

        diffSlider.addEventListener('input', (e) => {
            fluid.diff = parseFloat(e.target.value);
            diffValue.textContent = fluid.diff.toFixed(4);
        });

        fadeSlider.addEventListener('input', (e) => {
            fluid.fadeRate = parseFloat(e.target.value);
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        });

        function updateSliders() {
            viscSlider.value = fluid.visc;
            viscValue.textContent = fluid.visc.toFixed(4);
            diffSlider.value = fluid.diff;
            diffValue.textContent = fluid.diff.toFixed(4);
            fadeSlider.value = fluid.fadeRate;
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        }

        function updateInfo(message) {
            document.getElementById('fluidInfo').textContent = message;
        }

        function animate() {
            // Add continuous source if enabled
            if (continuousSource) {
                fluid.addDensity(sourceX, sourceY, 100);
                fluid.addVelocity(sourceX, sourceY, 0, 2);
            }

            fluid.step();
            fluid.render(ctx);
            requestAnimationFrame(animate);
        }

        animate();
        } // End canvas check

        // ===================================
        // DEMO 1: BUOYANCY SIMULATION
        // ===================================

        const buoyancyCanvas = document.getElementById('buoyancyDemo');
        const buoyancyCtx = buoyancyCanvas.getContext('2d');

        let waterLevel = 350;
        const targetWaterLevel = 350;
        let objects = [];

        class PhysicsObject {
            constructor(x, y, width, height, density, color, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.density = density; // kg/m¬≥
                this.color = color;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.mass = width * height * density / 1000;
                this.onGround = false;
            }

            update(dt) {
                const gravity = 800; // pixels/s¬≤
                const waterDensity = 1.0;
                const airResistance = 0.02;
                const waterResistance = 0.1;

                // Check if submerged
                const bottomY = this.y + this.height;
                const topY = this.y;

                let submergedHeight = 0;
                if (bottomY > waterLevel && topY < waterLevel) {
                    submergedHeight = bottomY - waterLevel;
                } else if (topY >= waterLevel) {
                    submergedHeight = this.height;
                }

                const submergedFraction = submergedHeight / this.height;

                // Buoyancy force (Archimedes' principle)
                const buoyancyForce = submergedFraction * this.width * this.height * waterDensity * gravity / 1000;

                // Net force
                const gravityForce = this.mass * gravity;
                let netForce = gravityForce - buoyancyForce;

                // Apply force
                this.vy += (netForce / this.mass) * dt;

                // Resistance
                if (submergedFraction > 0) {
                    this.vx *= (1 - waterResistance);
                    this.vy *= (1 - waterResistance);
                } else {
                    this.vx *= (1 - airResistance);
                    this.vy *= (1 - airResistance);
                }

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < 0) {
                    this.x = 0;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x + this.width > buoyancyCanvas.width) {
                    this.x = buoyancyCanvas.width - this.width;
                    this.vx = -this.vx * 0.5;
                }

                // Floor
                if (this.y + this.height > buoyancyCanvas.height) {
                    this.y = buoyancyCanvas.height - this.height;
                    this.vy = -this.vy * 0.3;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Draw type label
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x + this.width / 2, this.y + this.height / 2 + 4);
            }
        }

        buoyancyCanvas.addEventListener('click', (e) => {
            const rect = buoyancyCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a random object at click position
            const types = ['box', 'stone', 'ball'];
            const type = types[Math.floor(Math.random() * types.length)];

            if (type === 'box') {
                objects.push(new PhysicsObject(x - 20, y - 20, 40, 40, 0.5, '#8B4513', 'BOX'));
            } else if (type === 'stone') {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 2.5, '#555', 'STONE'));
            } else {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 0.3, '#FF6B6B', 'BALL'));
            }
        });

        document.getElementById('btnAddBox').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 40, 40, 0.5, '#8B4513', 'BOX'));
        });

        document.getElementById('btnAddStone').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 2.5, '#555', 'STONE'));
        });

        document.getElementById('btnAddBall').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 0.3, '#FF6B6B', 'BALL'));
        });

        document.getElementById('btnDrain').addEventListener('click', () => {
            waterLevel = Math.max(waterLevel - 100, 500);
        });

        document.getElementById('btnFill').addEventListener('click', () => {
            waterLevel = Math.max(waterLevel - 100, 200);
        });

        document.getElementById('btnResetBuoyancy').addEventListener('click', () => {
            objects = [];
            waterLevel = 350;
        });

        function animateBuoyancy() {
            // Clear
            buoyancyCtx.fillStyle = '#1a1a2e';
            buoyancyCtx.fillRect(0, 0, buoyancyCanvas.width, buoyancyCanvas.height);

            // Draw water
            buoyancyCtx.fillStyle = 'rgba(30, 144, 255, 0.6)';
            buoyancyCtx.fillRect(0, waterLevel, buoyancyCanvas.width, buoyancyCanvas.height - waterLevel);

            // Draw water surface
            buoyancyCtx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            buoyancyCtx.lineWidth = 3;
            buoyancyCtx.beginPath();
            buoyancyCtx.moveTo(0, waterLevel);
            buoyancyCtx.lineTo(buoyancyCanvas.width, waterLevel);
            buoyancyCtx.stroke();

            // Update and draw objects
            objects.forEach(obj => {
                obj.update(0.016);
                obj.draw(buoyancyCtx);
            });

            // Draw info
            buoyancyCtx.fillStyle = '#fff';
            buoyancyCtx.font = '14px Arial';
            buoyancyCtx.textAlign = 'left';
            buoyancyCtx.fillText(`Water Level: ${Math.floor(waterLevel)}px`, 10, 20);
            buoyancyCtx.fillText(`Objects: ${objects.length}`, 10, 40);

            requestAnimationFrame(animateBuoyancy);
        }

        animateBuoyancy();

        // ===================================
        // DEMO 2: RISING WATER CHALLENGE
        // ===================================

        const risingCanvas = document.getElementById('risingWaterDemo');
        const risingCtx = risingCanvas.getContext('2d');

        let risingWaterLevel = 500;
        let isRising = false;
        let player = {
            x: 100,
            y: 400,
            width: 30,
            height: 40,
            vx: 0,
            vy: 0,
            onGround: false,
            inWater: false,
            alive: true
        };

        const platforms = [
            { x: 50, y: 450, width: 150, height: 20 },
            { x: 250, y: 380, width: 120, height: 20 },
            { x: 420, y: 310, width: 140, height: 20 },
            { x: 600, y: 240, width: 150, height: 20 },
            { x: 200, y: 170, width: 200, height: 20 },
            { x: 450, y: 100, width: 300, height: 20 },
        ];

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.getElementById('btnStartRising').addEventListener('click', () => {
            isRising = true;
        });

        document.getElementById('btnStopRising').addEventListener('click', () => {
            isRising = false;
        });

        document.getElementById('btnResetRising').addEventListener('click', () => {
            risingWaterLevel = 500;
            isRising = false;
            player = {
                x: 100,
                y: 400,
                width: 30,
                height: 40,
                vx: 0,
                vy: 0,
                onGround: false,
                inWater: false,
                alive: true
            };
        });

        function updateRisingWater() {
            if (!player.alive) return;

            const speed = player.inWater ? 3 : 5;
            const jumpPower = player.inWater ? -8 : -12;

            // Movement
            if (keys['ArrowLeft']) player.vx = -speed;
            else if (keys['ArrowRight']) player.vx = speed;
            else player.vx *= 0.8;

            // Jump
            if (keys['ArrowUp'] && player.onGround) {
                player.vy = jumpPower;
            }

            // Gravity
            const gravity = player.inWater ? 0.3 : 0.5;
            player.vy += gravity;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // Check water
            player.inWater = (player.y + player.height) > risingWaterLevel;

            // Collisions with platforms
            player.onGround = false;
            platforms.forEach(platform => {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.vy >= 0) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }
            });

            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > risingCanvas.width) player.x = risingCanvas.width - player.width;

            // Check if drowned
            if (player.y > risingWaterLevel) {
                player.alive = false;
            }

            // Check if safe
            if (player.y < 50 && risingWaterLevel < 100) {
                document.getElementById('risingWaterInfo').textContent = 'üéâ You escaped! You win!';
            }

            // Rise water
            if (isRising && risingWaterLevel > 0) {
                risingWaterLevel -= 0.5;
            }
        }

        function renderRisingWater() {
            // Background
            risingCtx.fillStyle = '#16213e';
            risingCtx.fillRect(0, 0, risingCanvas.width, risingCanvas.height);

            // Platforms
            risingCtx.fillStyle = '#4a5568';
            platforms.forEach(platform => {
                risingCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                risingCtx.strokeStyle = '#718096';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Water
            risingCtx.fillStyle = 'rgba(30, 100, 200, 0.7)';
            risingCtx.fillRect(0, risingWaterLevel, risingCanvas.width, risingCanvas.height - risingWaterLevel);

            // Water surface animation
            risingCtx.strokeStyle = 'rgba(100, 180, 255, 0.9)';
            risingCtx.lineWidth = 3;
            risingCtx.beginPath();
            const time = Date.now() / 200;
            for (let x = 0; x < risingCanvas.width; x += 5) {
                const wave = Math.sin(x / 30 + time) * 3;
                risingCtx.lineTo(x, risingWaterLevel + wave);
            }
            risingCtx.stroke();

            // Player
            if (player.alive) {
                risingCtx.fillStyle = player.inWater ? '#FF6B6B' : '#4ECDC4';
                risingCtx.fillRect(player.x, player.y, player.width, player.height);
                risingCtx.strokeStyle = '#fff';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(player.x, player.y, player.width, player.height);

                // Eyes
                risingCtx.fillStyle = '#fff';
                risingCtx.fillRect(player.x + 8, player.y + 10, 5, 5);
                risingCtx.fillRect(player.x + 17, player.y + 10, 5, 5);
            } else {
                risingCtx.fillStyle = '#FF0000';
                risingCtx.font = '30px Arial';
                risingCtx.textAlign = 'center';
                risingCtx.fillText('DROWNED!', risingCanvas.width / 2, risingCanvas.height / 2);
                risingCtx.font = '16px Arial';
                risingCtx.fillText('Click Reset to try again', risingCanvas.width / 2, risingCanvas.height / 2 + 30);
            }

            // Info
            risingCtx.fillStyle = '#fff';
            risingCtx.font = '14px Arial';
            risingCtx.textAlign = 'left';
            risingCtx.fillText(`Water Level: ${Math.floor(risingWaterLevel)}`, 10, 20);
            risingCtx.fillText(`Player Status: ${player.alive ? (player.inWater ? 'In Water!' : 'Safe') : 'Drowned'}`, 10, 40);

            updateRisingWater();
            requestAnimationFrame(renderRisingWater);
        }

        renderRisingWater();

        // ===================================
        // DEMO 3: SPH PARTICLE-BASED WATER
        // ===================================

        const sphCanvas = document.getElementById('sphDemo');
        const sphCtx = sphCanvas.getContext('2d');

        let sphParticles = [];
        let sphBarriers = [];
        let sphGravity = true;
        let sphViscosity = 0.5;
        let addingBarrier = false;

        class WaterParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.density = 0;
                this.pressure = 0;
                this.fx = 0;
                this.fy = 0;
                this.radius = 4;
            }

            update(particles, dt) {
                const h = 20; // Smoothing radius
                const k = 0.1; // Pressure constant
                const restDensity = 1.0;

                // Calculate density
                this.density = 0;
                particles.forEach(other => {
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h) {
                        const q = dist / h;
                        const kernel = (1 - q) * (1 - q);
                        this.density += kernel;
                    }
                });

                // Calculate pressure
                this.pressure = k * (this.density - restDensity);

                // Reset forces
                this.fx = 0;
                this.fy = 0;

                // Pressure force
                particles.forEach(other => {
                    if (other === this) return;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h && dist > 0.01) {
                        const q = dist / h;
                        const kernel = (1 - q);
                        const pressureForce = -kernel * (this.pressure + other.pressure) / (2 * this.density);

                        this.fx += pressureForce * (dx / dist);
                        this.fy += pressureForce * (dy / dist);
                    }
                });

                // Gravity
                if (sphGravity) {
                    this.fy += 10;
                }

                // Apply forces
                this.vx += this.fx * dt;
                this.vy += this.fy * dt;

                // Viscosity
                this.vx *= (1 - sphViscosity * 0.05);
                this.vy *= (1 - sphViscosity * 0.05);

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x > sphCanvas.width - this.radius) {
                    this.x = sphCanvas.width - this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy = -this.vy * 0.5;
                }
                if (this.y > sphCanvas.height - this.radius) {
                    this.y = sphCanvas.height - this.radius;
                    this.vy = -this.vy * 0.5;
                }

                // Barrier collisions
                sphBarriers.forEach(barrier => {
                    if (this.x > barrier.x && this.x < barrier.x + barrier.width &&
                        this.y > barrier.y && this.y < barrier.y + barrier.height) {
                        // Simple ejection
                        const dx = this.x - (barrier.x + barrier.width / 2);
                        const dy = this.y - (barrier.y + barrier.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.x += (dx / dist) * 5;
                            this.y += (dy / dist) * 5;
                        }
                        this.vx *= 0.3;
                        this.vy *= 0.3;
                    }
                });
            }

            draw(ctx) {
                const colorIntensity = Math.min(255, this.density * 100);
                ctx.fillStyle = `rgba(30, ${100 + colorIntensity}, ${200 + colorIntensity / 2}, 0.9)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        sphCanvas.addEventListener('click', (e) => {
            const rect = sphCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (addingBarrier) {
                sphBarriers.push({ x: x - 30, y: y - 10, width: 60, height: 20 });
            } else {
                // Add cluster of particles
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20;
                    sphParticles.push(new WaterParticle(
                        x + Math.cos(angle) * radius,
                        y + Math.sin(angle) * radius
                    ));
                }
            }
        });

        document.getElementById('btnAddWater').addEventListener('click', () => {
            for (let i = 0; i < 30; i++) {
                sphParticles.push(new WaterParticle(
                    Math.random() * 200 + 300,
                    Math.random() * 100 + 50
                ));
            }
        });

        document.getElementById('btnAddBarrier').addEventListener('click', () => {
            addingBarrier = !addingBarrier;
        });

        document.getElementById('btnToggleGravity').addEventListener('click', () => {
            sphGravity = !sphGravity;
        });

        document.getElementById('btnResetSPH').addEventListener('click', () => {
            sphParticles = [];
            sphBarriers = [];
        });

        document.getElementById('sphViscosity').addEventListener('input', (e) => {
            sphViscosity = parseFloat(e.target.value);
            document.getElementById('sphViscValue').textContent = sphViscosity.toFixed(1);
        });

        function animateSPH() {
            sphCtx.fillStyle = '#0a0e1a';
            sphCtx.fillRect(0, 0, sphCanvas.width, sphCanvas.height);

            // Draw barriers
            sphCtx.fillStyle = '#666';
            sphBarriers.forEach(barrier => {
                sphCtx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
            });

            // Update and draw particles
            const dt = 0.1;
            sphParticles.forEach(p => p.update(sphParticles, dt));
            sphParticles.forEach(p => p.draw(sphCtx));

            // Info
            sphCtx.fillStyle = '#fff';
            sphCtx.font = '14px Arial';
            sphCtx.textAlign = 'left';
            sphCtx.fillText(`Particles: ${sphParticles.length}`, 10, 20);
            sphCtx.fillText(`Gravity: ${sphGravity ? 'ON' : 'OFF'}`, 10, 40);

            requestAnimationFrame(animateSPH);
        }

        animateSPH();

        // ===================================
        // DEMO 4: SIMPLIFIED FLOW MECHANIC
        // ===================================

        const puzzleCanvas = document.getElementById('flowPuzzleDemo');
        const puzzleCtx = puzzleCanvas.getContext('2d');

        let waterReleased = false;
        let addingPlatforms = false;
        let flowPlatforms = [];

        const bucket = { x: 650, y: 400, width: 100, height: 80, filled: 0 };
        const source = { x: 400, y: 50 };

        // Grid-based flow system
        const cellSize = 10;
        const cols = Math.floor(puzzleCanvas.width / cellSize);
        const rows = Math.floor(puzzleCanvas.height / cellSize);
        let waterGrid = [];
        let velocityGrid = [];

        // Initialize grids
        for (let i = 0; i < cols; i++) {
            waterGrid[i] = [];
            velocityGrid[i] = [];
            for (let j = 0; j < rows; j++) {
                waterGrid[i][j] = 0;
                velocityGrid[i][j] = { vx: 0, vy: 0 };
            }
        }

        // Check if cell is blocked by platform
        function isBlocked(gridX, gridY) {
            const x = gridX * cellSize;
            const y = gridY * cellSize;

            for (let platform of flowPlatforms) {
                if (x + cellSize > platform.x && x < platform.x + platform.width &&
                    y + cellSize > platform.y && y < platform.y + platform.height) {
                    return true;
                }
            }
            return false;
        }

        // Update water flow
        function updateFlow() {
            const newWater = [];
            for (let i = 0; i < cols; i++) {
                newWater[i] = [];
                for (let j = 0; j < rows; j++) {
                    newWater[i][j] = waterGrid[i][j];
                }
            }

            // Add water from source
            if (waterReleased) {
                const sourceGridX = Math.floor(source.x / cellSize);
                const sourceGridY = Math.floor(source.y / cellSize);
                for (let dx = -2; dx <= 2; dx++) {
                    const gx = sourceGridX + dx;
                    if (gx >= 0 && gx < cols && sourceGridY >= 0 && sourceGridY < rows) {
                        newWater[gx][sourceGridY] = Math.min(255, newWater[gx][sourceGridY] + 35);
                    }
                }
            }

            // Flow simulation - water flows down and spreads
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 5 && !isBlocked(i, j)) {
                        const amount = waterGrid[i][j];

                        // Try to flow down first
                        if (j < rows - 1 && !isBlocked(i, j + 1)) {
                            const flowDown = Math.min(amount * 0.5, 255 - newWater[i][j + 1]);
                            newWater[i][j] -= flowDown;
                            newWater[i][j + 1] += flowDown;
                        }

                        // Then spread sideways if there's water left
                        if (newWater[i][j] > 10) {
                            // Flow left
                            if (i > 0 && !isBlocked(i - 1, j)) {
                                const diff = (newWater[i][j] - newWater[i - 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i - 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i - 1][j] += flow;
                                }
                            }

                            // Flow right
                            if (i < cols - 1 && !isBlocked(i + 1, j)) {
                                const diff = (newWater[i][j] - newWater[i + 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i + 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i + 1][j] += flow;
                                }
                            }
                        }
                    }

                    // Check if water reached bucket
                    const x = i * cellSize;
                    const y = j * cellSize;
                    if (x > bucket.x && x < bucket.x + bucket.width &&
                        y > bucket.y && y < bucket.y + bucket.height) {
                        if (newWater[i][j] > 0) {
                            bucket.filled = Math.min(100, bucket.filled + newWater[i][j] * 0.01);
                            newWater[i][j] = 0;
                        }
                    }

                    // Evaporation at bottom
                    if (j === rows - 1 && newWater[i][j] > 0) {
                        newWater[i][j] *= 0.95;
                    }
                }
            }

            waterGrid = newWater;
        }

        // Draw water grid
        function drawWater(ctx) {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const amount = waterGrid[i][j];
                    if (amount > 3) {
                        // Much more visible water color
                        const intensity = Math.min(1, amount / 180);

                        // Bright cyan-blue water
                        const r = Math.floor(30 + intensity * 50);
                        const g = Math.floor(180 + intensity * 75);
                        const b = Math.floor(220 + intensity * 35);

                        // Higher base opacity
                        const alpha = Math.max(0.7, intensity);

                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                        // Add white highlights to make water more visible
                        if (amount > 50) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.4})`;
                            ctx.fillRect(i * cellSize + 1, j * cellSize + 1, cellSize - 2, cellSize - 2);
                        }

                        // Add shimmer effect
                        if (amount > 80 && Math.random() < 0.15) {
                            ctx.fillStyle = `rgba(200, 255, 255, 0.6)`;
                            const shimmerSize = cellSize * 0.6;
                            ctx.fillRect(
                                i * cellSize + (cellSize - shimmerSize) / 2,
                                j * cellSize + (cellSize - shimmerSize) / 2,
                                shimmerSize,
                                shimmerSize
                            );
                        }
                    }
                }
            }
        }

        puzzleCanvas.addEventListener('click', (e) => {
            if (!addingPlatforms) return;

            const rect = puzzleCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a platform
            flowPlatforms.push({
                x: x - 40,
                y: y,
                width: 80,
                height: 10
            });
        });

        document.getElementById('btnRelease').addEventListener('click', () => {
            waterReleased = !waterReleased;
            document.getElementById('btnRelease').textContent = waterReleased ? 'Stop Water' : 'Release Water';
        });

        document.getElementById('btnAddPlatform').addEventListener('click', (e) => {
            addingPlatforms = !addingPlatforms;
            e.target.textContent = addingPlatforms ? 'Stop Adding Platforms' : 'Add Platform (Blocks Water)';
            e.target.style.backgroundColor = addingPlatforms ? '#4CAF50' : '#4a5568';
        });

        document.getElementById('btnResetPuzzle').addEventListener('click', () => {
            waterReleased = false;
            flowPlatforms = [];
            bucket.filled = 0;
            // Reset water grid
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    waterGrid[i][j] = 0;
                }
            }
            document.getElementById('btnRelease').textContent = 'Release Water';
        });

        function animatePuzzle() {
            // Background - darker for better water contrast
            puzzleCtx.fillStyle = '#0a0e1a';
            puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);

            // Update and draw water flow
            updateFlow();
            drawWater(puzzleCtx);

            // Draw source
            puzzleCtx.fillStyle = '#4FC3F7';
            puzzleCtx.fillRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.strokeStyle = '#82CEFF';
            puzzleCtx.lineWidth = 2;
            puzzleCtx.strokeRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = 'bold 12px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('SOURCE', source.x, source.y + 5);

            // Draw platforms
            puzzleCtx.fillStyle = '#4a5568';
            flowPlatforms.forEach(platform => {
                puzzleCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                puzzleCtx.strokeStyle = '#718096';
                puzzleCtx.lineWidth = 2;
                puzzleCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Platform mode indicator
            if (addingPlatforms) {
                puzzleCtx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
                puzzleCtx.fillStyle = '#4CAF50';
                puzzleCtx.font = 'bold 20px Arial';
                puzzleCtx.textAlign = 'center';
                puzzleCtx.fillText('Click to add platforms', puzzleCanvas.width / 2, 30);
            }

            // Draw bucket
            puzzleCtx.strokeStyle = '#8B4513';
            puzzleCtx.lineWidth = 4;
            puzzleCtx.strokeRect(bucket.x, bucket.y, bucket.width, bucket.height);

            // Fill water in bucket
            puzzleCtx.fillStyle = 'rgba(30, 144, 255, 0.7)';
            const fillHeight = (bucket.filled / 100) * bucket.height;
            puzzleCtx.fillRect(bucket.x, bucket.y + bucket.height - fillHeight, bucket.width, fillHeight);

            // Bucket label
            puzzleCtx.fillStyle = '#FFD700';
            puzzleCtx.font = 'bold 14px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('BUCKET', bucket.x + bucket.width / 2, bucket.y - 5);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = '12px Arial';
            puzzleCtx.fillText(`${Math.floor(bucket.filled)}%`, bucket.x + bucket.width / 2, bucket.y + bucket.height / 2);

            // Calculate total water in system
            let totalWater = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 0) totalWater++;
                }
            }

            // Update status
            const bucketPercent = Math.floor(bucket.filled);
            if (bucket.filled >= 90) {
                document.getElementById('puzzleStatus').textContent = `üéâ Bucket Full! ${bucketPercent}%`;
            } else {
                document.getElementById('puzzleStatus').textContent = `Bucket: ${bucketPercent}% | Platforms: ${flowPlatforms.length} | Water Cells: ${totalWater}`;
            }

            requestAnimationFrame(animatePuzzle);
        }

        animatePuzzle();

        // ========================================
        // WIND SIMULATION DEMO
        // ========================================
        const windCanvas = document.getElementById('windCanvas');
        if (windCanvas) {
            const windCtx = windCanvas.getContext('2d');

            // Wind field settings
            const windGridSize = 20;
            const windCols = Math.ceil(windCanvas.width / windGridSize);
            const windRows = Math.ceil(windCanvas.height / windGridSize);

            let windVectors = [];
            let windParticles = [];
            let windGusts = [];
            let windTime = 0;
            let windStrength = 1.0;
            let turbulence = 0.5;
            let showVectors = false;

            // Initialize wind field
            for (let i = 0; i < windRows; i++) {
                windVectors[i] = [];
                for (let j = 0; j < windCols; j++) {
                    windVectors[i][j] = { x: 0, y: 0 };
                }
            }

            // Create particles
            for (let i = 0; i < 200; i++) {
                windParticles.push({
                    x: Math.random() * windCanvas.width,
                    y: Math.random() * windCanvas.height,
                    vx: 0,
                    vy: 0,
                    trail: []
                });
            }

            // Noise function
            function windNoise(x, y, t) {
                const n = Math.sin(x * 0.1 + t) * Math.cos(y * 0.1 + t * 0.7);
                return n * 0.5 + 0.5;
            }

            // Update wind field
            function updateWindField(dt) {
                windTime += dt * 0.001;

                for (let i = 0; i < windRows; i++) {
                    for (let j = 0; j < windCols; j++) {
                        // Base wind (left to right)
                        let wx = 1 * windStrength;
                        let wy = 0;

                        // Add turbulence
                        const noiseX = windNoise(j, i, windTime);
                        const noiseY = windNoise(j + 100, i + 100, windTime);
                        wx += (noiseX - 0.5) * turbulence * 2;
                        wy += (noiseY - 0.5) * turbulence * 2;

                        // Add gust effects
                        const x = j * windGridSize;
                        const y = i * windGridSize;
                        for (let gust of windGusts) {
                            const dx = x - gust.x;
                            const dy = y - gust.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < gust.radius) {
                                const influence = (1 - dist / gust.radius) * gust.strength;
                                const angle = Math.atan2(dy, dx);
                                wx += Math.cos(angle) * influence;
                                wy += Math.sin(angle) * influence;
                            }
                        }

                        windVectors[i][j] = { x: wx, y: wy };
                    }
                }

                // Decay gusts
                windGusts = windGusts.filter(g => {
                    g.strength *= 0.95;
                    return g.strength > 0.1;
                });
            }

            // Get wind at position
            function getWindAt(x, y) {
                const gridX = x / windGridSize;
                const gridY = y / windGridSize;
                const i = Math.floor(gridY);
                const j = Math.floor(gridX);

                if (i < 0 || i >= windRows - 1 || j < 0 || j >= windCols - 1) {
                    return { x: 0, y: 0 };
                }

                const fx = gridX - j;
                const fy = gridY - i;
                const v00 = windVectors[i][j];
                const v10 = windVectors[i][j + 1];
                const v01 = windVectors[i + 1][j];
                const v11 = windVectors[i + 1][j + 1];

                const wx = v00.x * (1 - fx) * (1 - fy) + v10.x * fx * (1 - fy) +
                           v01.x * (1 - fx) * fy + v11.x * fx * fy;
                const wy = v00.y * (1 - fx) * (1 - fy) + v10.y * fx * (1 - fy) +
                           v01.y * (1 - fx) * fy + v11.y * fx * fy;

                return { x: wx, y: wy };
            }

            // Update particles
            function updateWindParticles() {
                windParticles.forEach(p => {
                    const wind = getWindAt(p.x, p.y);
                    p.vx += wind.x * 0.5;
                    p.vy += wind.y * 0.5;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.x += p.vx;
                    p.y += p.vy;

                    // Wrap around
                    if (p.x < 0) p.x = windCanvas.width;
                    if (p.x > windCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = windCanvas.height;
                    if (p.y > windCanvas.height) p.y = 0;

                    p.trail.push({ x: p.x, y: p.y });
                    if (p.trail.length > 8) p.trail.shift();
                });
            }

            // Draw wind demo
            function drawWindDemo() {
                // Fade effect instead of clearing
                windCtx.fillStyle = 'rgba(26, 26, 26, 0.15)';
                windCtx.fillRect(0, 0, windCanvas.width, windCanvas.height);

                // Draw wind vectors if enabled
                if (showVectors) {
                    windCtx.lineWidth = 1;
                    for (let i = 0; i < windRows; i++) {
                        for (let j = 0; j < windCols; j++) {
                            const x = j * windGridSize + windGridSize / 2;
                            const y = i * windGridSize + windGridSize / 2;
                            const v = windVectors[i][j];
                            const mag = Math.sqrt(v.x * v.x + v.y * v.y);

                            windCtx.strokeStyle = `rgba(100, 200, 255, ${Math.min(0.4, mag * 0.15)})`;
                            windCtx.beginPath();
                            windCtx.moveTo(x, y);
                            windCtx.lineTo(x + v.x * 8, y + v.y * 8);
                            windCtx.stroke();

                            // Arrow head
                            const angle = Math.atan2(v.y, v.x);
                            const arrowX = x + v.x * 8;
                            const arrowY = y + v.y * 8;
                            windCtx.beginPath();
                            windCtx.moveTo(arrowX, arrowY);
                            windCtx.lineTo(arrowX - 5 * Math.cos(angle - Math.PI/6), arrowY - 5 * Math.sin(angle - Math.PI/6));
                            windCtx.moveTo(arrowX, arrowY);
                            windCtx.lineTo(arrowX - 5 * Math.cos(angle + Math.PI/6), arrowY - 5 * Math.sin(angle + Math.PI/6));
                            windCtx.stroke();
                        }
                    }
                }

                // Draw particles with glow
                windParticles.forEach(p => {
                    // Glow effect
                    const gradient = windCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 6);
                    gradient.addColorStop(0, 'rgba(150, 220, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(100, 200, 255, 0)');

                    windCtx.fillStyle = gradient;
                    windCtx.beginPath();
                    windCtx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    windCtx.fill();

                    // Core
                    windCtx.fillStyle = 'rgba(200, 240, 255, 0.9)';
                    windCtx.beginPath();
                    windCtx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    windCtx.fill();
                });
            }

            // Animation loop
            function animateWind() {
                updateWindField(16);
                updateWindParticles();
                drawWindDemo();
                requestAnimationFrame(animateWind);
            }

            // Controls
            document.getElementById('windStrengthSlider').addEventListener('input', (e) => {
                windStrength = parseFloat(e.target.value);
                document.getElementById('windStrengthDisplay').textContent = windStrength.toFixed(1);
            });

            document.getElementById('turbulenceSlider').addEventListener('input', (e) => {
                turbulence = parseFloat(e.target.value);
                document.getElementById('turbulenceDisplay').textContent = turbulence.toFixed(1);
            });

            document.getElementById('toggleWindVectors').addEventListener('click', () => {
                showVectors = !showVectors;
            });

            document.getElementById('resetWindDemo').addEventListener('click', () => {
                windGusts = [];
                windParticles.forEach(p => {
                    p.x = Math.random() * windCanvas.width;
                    p.y = Math.random() * windCanvas.height;
                    p.vx = 0;
                    p.vy = 0;
                    p.trail = [];
                });
            });

            windCanvas.addEventListener('click', (e) => {
                const rect = windCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                windGusts.push({ x, y, strength: 5, radius: 150 });
            });

            animateWind();
        }

        // ========================================
        // DESTRUCTIBLE TERRAIN DEMO
        // ========================================
        const terrainCanvas = document.getElementById('terrainCanvas');
        if (terrainCanvas) {
            const terrainCtx = terrainCanvas.getContext('2d');

            let terrainImageData = terrainCtx.createImageData(terrainCanvas.width, terrainCanvas.height);
            let explosionSize = 30;
            let balls = [];
            let isMouseDown = false;

            // Initialize terrain
            function initTerrain() {
                balls = [];
                terrainImageData = terrainCtx.createImageData(terrainCanvas.width, terrainCanvas.height);
                const data = terrainImageData.data;

                for (let y = 0; y < terrainCanvas.height; y++) {
                    for (let x = 0; x < terrainCanvas.width; x++) {
                        const idx = (y * terrainCanvas.width + x) * 4;

                        // Create layered terrain
                        if (y > 150 && y < 450) {
                            // Dirt layer
                            const noise = Math.sin(x * 0.05) * 10 + Math.cos(y * 0.03) * 5;
                            if (y + noise > 200) {
                                data[idx] = 139;     // R
                                data[idx + 1] = 90;  // G
                                data[idx + 2] = 43;  // B
                                data[idx + 3] = 255; // A
                            }
                        }
                    }
                }

                terrainCtx.putImageData(terrainImageData, 0, 0);
            }

            // Check if terrain exists at position
            function isTerrainAt(x, y) {
                if (x < 0 || x >= terrainCanvas.width || y < 0 || y >= terrainCanvas.height) return false;
                const idx = (Math.floor(y) * terrainCanvas.width + Math.floor(x)) * 4;
                return terrainImageData.data[idx + 3] > 0;
            }

            // Destroy terrain
            function destroyTerrain(x, y, radius) {
                const data = terrainImageData.data;

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const px = Math.floor(x + dx);
                            const py = Math.floor(y + dy);

                            if (px >= 0 && px < terrainCanvas.width && py >= 0 && py < terrainCanvas.height) {
                                const idx = (py * terrainCanvas.width + px) * 4;
                                data[idx + 3] = 0; // Make transparent
                            }
                        }
                    }
                }

                terrainCtx.putImageData(terrainImageData, 0, 0);
            }

            // Update balls
            function updateBalls() {
                balls.forEach((ball, index) => {
                    ball.vy += 0.5; // Gravity
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    // Check terrain collision
                    let collided = false;
                    for (let i = 0; i < 360; i += 30) {
                        const angle = i * Math.PI / 180;
                        const checkX = ball.x + Math.cos(angle) * ball.radius;
                        const checkY = ball.y + Math.sin(angle) * ball.radius;

                        if (isTerrainAt(checkX, checkY)) {
                            collided = true;
                            ball.vy *= -0.5;
                            ball.vx *= 0.9;
                            ball.y -= 2;
                            break;
                        }
                    }

                    // Remove balls that fall off screen
                    if (ball.y > terrainCanvas.height + 50) {
                        balls.splice(index, 1);
                    }
                });
            }

            // Draw terrain demo
            function drawTerrainDemo() {
                terrainCtx.fillStyle = '#0a0a0a';
                terrainCtx.fillRect(0, 0, terrainCanvas.width, terrainCanvas.height);

                // Draw terrain
                terrainCtx.putImageData(terrainImageData, 0, 0);

                // Draw balls
                balls.forEach(ball => {
                    terrainCtx.fillStyle = ball.color;
                    terrainCtx.beginPath();
                    terrainCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    terrainCtx.fill();

                    terrainCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    terrainCtx.stroke();
                });
            }

            // Animation loop
            function animateTerrain() {
                updateBalls();
                drawTerrainDemo();
                requestAnimationFrame(animateTerrain);
            }

            // Controls
            document.getElementById('explosionSizeSlider').addEventListener('input', (e) => {
                explosionSize = parseInt(e.target.value);
                document.getElementById('explosionSizeDisplay').textContent = explosionSize;
            });

            document.getElementById('addBall').addEventListener('click', () => {
                balls.push({
                    x: Math.random() * (terrainCanvas.width - 100) + 50,
                    y: 50,
                    vx: (Math.random() - 0.5) * 4,
                    vy: 0,
                    radius: 10 + Math.random() * 10,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            });

            document.getElementById('resetTerrain').addEventListener('click', () => {
                initTerrain();
            });

            terrainCanvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                const rect = terrainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                destroyTerrain(x, y, explosionSize);
            });

            terrainCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const rect = terrainCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    destroyTerrain(x, y, explosionSize);
                }
            });

            terrainCanvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            terrainCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
            });

            initTerrain();
            animateTerrain();
        }

        // ========================================
        // THERMAL SIMULATION DEMO
        // ========================================
        const thermalCanvas = document.getElementById('thermalCanvas');
        if (thermalCanvas) {
            const thermalCtx = thermalCanvas.getContext('2d');

            const cellSize = 8;
            const cols = Math.floor(thermalCanvas.width / cellSize);
            const rows = Math.floor(thermalCanvas.height / cellSize);

            let heatGrid = [];
            let diffusionRate = 0.5;
            let addingFire = false;
            let addingIce = false;

            // Initialize heat grid
            function initHeatGrid() {
                heatGrid = [];
                for (let i = 0; i < rows; i++) {
                    heatGrid[i] = [];
                    for (let j = 0; j < cols; j++) {
                        heatGrid[i][j] = 20; // Room temperature
                    }
                }
            }

            // Update heat diffusion
            function updateHeat() {
                const newHeat = [];

                for (let i = 0; i < rows; i++) {
                    newHeat[i] = [];
                    for (let j = 0; j < cols; j++) {
                        newHeat[i][j] = heatGrid[i][j];
                    }
                }

                // Diffusion
                for (let i = 1; i < rows - 1; i++) {
                    for (let j = 1; j < cols - 1; j++) {
                        const avg = (
                            heatGrid[i - 1][j] + heatGrid[i + 1][j] +
                            heatGrid[i][j - 1] + heatGrid[i][j + 1]
                        ) / 4;

                        newHeat[i][j] = heatGrid[i][j] + (avg - heatGrid[i][j]) * diffusionRate * 0.1;

                        // Cool down over time (ambient cooling)
                        if (newHeat[i][j] > 20) {
                            newHeat[i][j] -= 0.1;
                        } else if (newHeat[i][j] < 20) {
                            newHeat[i][j] += 0.1;
                        }
                    }
                }

                heatGrid = newHeat;
            }

            // Draw thermal demo
            function drawThermalDemo() {
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const temp = heatGrid[i][j];

                        // Color based on temperature
                        let r, g, b;
                        if (temp < 20) {
                            // Cold - blue
                            const t = temp / 20;
                            r = 0;
                            g = Math.floor(t * 100);
                            b = Math.floor(150 + t * 105);
                        } else if (temp < 50) {
                            // Cool to warm
                            const t = (temp - 20) / 30;
                            r = Math.floor(t * 150);
                            g = Math.floor(100 + t * 100);
                            b = Math.floor(150 * (1 - t));
                        } else if (temp < 100) {
                            // Warm to hot
                            const t = (temp - 50) / 50;
                            r = Math.floor(150 + t * 105);
                            g = Math.floor(200 * (1 - t * 0.5));
                            b = 0;
                        } else {
                            // Very hot - white/yellow
                            const t = Math.min(1, (temp - 100) / 100);
                            r = 255;
                            g = Math.floor(200 + t * 55);
                            b = Math.floor(t * 100);
                        }

                        thermalCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        thermalCtx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Animation loop
            function animateThermal() {
                updateHeat();
                drawThermalDemo();
                requestAnimationFrame(animateThermal);
            }

            // Add heat at position
            function addHeat(x, y, amount) {
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);

                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const i = gridY + dy;
                        const j = gridX + dx;
                        if (i >= 0 && i < rows && j >= 0 && j < cols) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= 2) {
                                heatGrid[i][j] += amount * (1 - dist / 2);
                                heatGrid[i][j] = Math.max(-50, Math.min(300, heatGrid[i][j]));
                            }
                        }
                    }
                }
            }

            // Controls
            document.getElementById('diffusionSlider').addEventListener('input', (e) => {
                diffusionRate = parseFloat(e.target.value);
                document.getElementById('diffusionDisplay').textContent = diffusionRate.toFixed(1);
            });

            document.getElementById('addFire').addEventListener('click', () => {
                addingFire = !addingFire;
                addingIce = false;
                document.getElementById('addFire').textContent = addingFire ? 'Adding Fire (Click to Stop)' : 'Add Fire (Click Canvas)';
                document.getElementById('addIce').textContent = 'Add Ice (Click Canvas)';
            });

            document.getElementById('addIce').addEventListener('click', () => {
                addingIce = !addingIce;
                addingFire = false;
                document.getElementById('addIce').textContent = addingIce ? 'Adding Ice (Click to Stop)' : 'Add Ice (Click Canvas)';
                document.getElementById('addFire').textContent = 'Add Fire (Click Canvas)';
            });

            document.getElementById('resetThermal').addEventListener('click', () => {
                initHeatGrid();
                addingFire = false;
                addingIce = false;
                document.getElementById('addFire').textContent = 'Add Fire (Click Canvas)';
                document.getElementById('addIce').textContent = 'Add Ice (Click Canvas)';
            });

            thermalCanvas.addEventListener('click', (e) => {
                const rect = thermalCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (addingFire) {
                    addHeat(x, y, 100);
                } else if (addingIce) {
                    addHeat(x, y, -100);
                }
            });

            thermalCanvas.addEventListener('mousemove', (e) => {
                if (addingFire || addingIce) {
                    const rect = thermalCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (addingFire) {
                        addHeat(x, y, 10);
                    } else if (addingIce) {
                        addHeat(x, y, -10);
                    }
                }
            });

            initHeatGrid();
            animateThermal();
        }

    </script>
</body>
</html>
