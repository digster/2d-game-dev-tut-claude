<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation - Game Dev Math Guide</title>
    <link rel="stylesheet" href="shared/styles.css">
</head>
<body>
    <div class="container">
        <h1>üåä Simulation Systems</h1>
        <p class="subtitle">Advanced simulation techniques - Fluids, cloth, and realistic effects</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="expert.html" class="nav-button">Expert</a>
            <a href="simulation.html" class="nav-button active">Simulation</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Topics in This Guide</div>
            <ul>
                <li><a href="#fluid-dynamics">Fluid Dynamics Simulation (Grid-Based)</a></li>
                <li><a href="#game-mechanics">Fluid Dynamics as Game Mechanics</a>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><a href="#game-mechanics">‚Üí Water Buoyancy & Floating Objects</a></li>
                        <li><a href="#game-mechanics">‚Üí Rising Water Challenge (Platformer)</a></li>
                        <li><a href="#game-mechanics">‚Üí Particle-Based Water (SPH)</a></li>
                        <li><a href="#game-mechanics">‚Üí Flow Direction & Collection</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- FLUID DYNAMICS -->
        <div id="fluid-dynamics" class="section">
            <span class="level-indicator level-expert">EXPERT</span>
            <h2>üåä Fluid Dynamics Simulation</h2>

            <div class="concept-box">
                <h4>What is Fluid Simulation?</h4>
                <p>Fluid simulation recreates the behavior of liquids and gases - water splashing, smoke rising, or fire spreading. In games, we often use simplified models that look realistic without the massive computational cost of real physics.</p>

                <div class="key-point">
                    <strong>üí° Core Idea:</strong> Instead of simulating individual water molecules, we divide space into a grid and calculate how properties like velocity, pressure, and density flow between neighboring cells.
                </div>
            </div>

            <div class="concept-box">
                <h4>How Fluids Work: The Basics</h4>
                <p>Real fluids follow the <strong>Navier-Stokes equations</strong>, but don't worry - we'll break this down into simple concepts!</p>

                <ul>
                    <li><strong>Advection:</strong> Fluid carries things along with it (like a river carrying a leaf)</li>
                    <li><strong>Diffusion:</strong> Properties spread out over time (like ink dispersing in water)</li>
                    <li><strong>Pressure:</strong> Fluid pushes away from high-pressure areas</li>
                    <li><strong>Incompressibility:</strong> Liquid volume stays constant (water doesn't compress)</li>
                </ul>
            </div>

            <details>
                <summary>üìù Click to see: Fluid Grid Setup</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Fluid simulation grid</span>
<span class="keyword">class</span> <span class="function">FluidGrid</span> {
    <span class="keyword">constructor</span>(width, height, scale) {
        <span class="keyword">this</span>.cols = Math.<span class="function">floor</span>(width / scale);
        <span class="keyword">this</span>.rows = Math.<span class="function">floor</span>(height / scale);
        <span class="keyword">this</span>.scale = scale;

        <span class="comment">// Create grids for velocity (in X and Y directions)</span>
        <span class="keyword">this</span>.vx = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Previous velocity (for stability)</span>
        <span class="keyword">this</span>.vx0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.vy0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();

        <span class="comment">// Density (for visualization - like dye in water)</span>
        <span class="keyword">this</span>.density = <span class="keyword">this</span>.<span class="function">createGrid</span>();
        <span class="keyword">this</span>.density0 = <span class="keyword">this</span>.<span class="function">createGrid</span>();
    }

    <span class="function">createGrid</span>() {
        <span class="keyword">const</span> grid = [];
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
            grid[i] = <span class="keyword">new</span> <span class="function">Array</span>(<span class="keyword">this</span>.cols).<span class="function">fill</span>(<span class="number">0</span>);
        }
        <span class="keyword">return</span> grid;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Diffusion (Spreading)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Diffusion spreads values to neighbors
// Like heat spreading through metal or ink dispersing in water</span>
<span class="function">diffuse</span>(x, x0, diffusion, dt) {
    <span class="keyword">const</span> a = dt * diffusion * <span class="keyword">this</span>.cols * <span class="keyword">this</span>.rows;

    <span class="comment">// Gauss-Seidel iteration for stability</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                <span class="comment">// Average with neighbors, weighted by diffusion rate</span>
                x[i][j] = (x0[i][j] + a * (
                    x[i - <span class="number">1</span>][j] + x[i + <span class="number">1</span>][j] +
                    x[i][j - <span class="number">1</span>] + x[i][j + <span class="number">1</span>]
                )) / (<span class="number">1</span> + <span class="number">4</span> * a);
            }
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Diffusion:</h4>
                    <p>Think of a drop of food coloring in water. It starts concentrated, then slowly spreads out. Each cell shares a bit of its "stuff" with neighbors. The <code>diffusion</code> parameter controls how fast this happens.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Advection (Flow)</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Advection moves values along the velocity field
// Like a river carrying leaves downstream</span>
<span class="function">advect</span>(d, d0, vx, vy, dt) {
    <span class="keyword">const</span> dt0 = dt * <span class="keyword">this</span>.cols;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            <span class="comment">// Trace backwards along velocity</span>
            <span class="keyword">let</span> x = j - dt0 * vx[i][j];
            <span class="keyword">let</span> y = i - dt0 * vy[i][j];

            <span class="comment">// Clamp to grid boundaries</span>
            x = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.cols - <span class="number">1.5</span>, x));
            y = Math.<span class="function">max</span>(<span class="number">0.5</span>, Math.<span class="function">min</span>(<span class="keyword">this</span>.rows - <span class="number">1.5</span>, y));

            <span class="comment">// Interpolate between grid cells</span>
            <span class="keyword">const</span> i0 = Math.<span class="function">floor</span>(y);
            <span class="keyword">const</span> i1 = i0 + <span class="number">1</span>;
            <span class="keyword">const</span> j0 = Math.<span class="function">floor</span>(x);
            <span class="keyword">const</span> j1 = j0 + <span class="number">1</span>;

            <span class="keyword">const</span> s1 = x - j0;
            <span class="keyword">const</span> s0 = <span class="number">1</span> - s1;
            <span class="keyword">const</span> t1 = y - i0;
            <span class="keyword">const</span> t0 = <span class="number">1</span> - t1;

            <span class="comment">// Bilinear interpolation</span>
            d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                      s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Advection:</h4>
                    <p>Imagine you drop dye in a moving river. The dye doesn't just sit there - it flows with the water. Advection does this: for each cell, we look backward along the velocity to see where the fluid came from, then bring that value forward.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Pressure & Incompressibility</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Project removes divergence (ensures fluid is incompressible)
// This is what makes fluid behave like liquid, not gas</span>
<span class="function">project</span>(vx, vy, p, div) {
    <span class="comment">// Calculate divergence (how much fluid is leaving each cell)</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            div[i][j] = -<span class="number">0.5</span> * (
                vx[i][j + <span class="number">1</span>] - vx[i][j - <span class="number">1</span>] +
                vy[i + <span class="number">1</span>][j] - vy[i - <span class="number">1</span>][j]
            ) / <span class="keyword">this</span>.cols;
            p[i][j] = <span class="number">0</span>;
        }
    }

    <span class="comment">// Solve for pressure using iterative method</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> iter = <span class="number">0</span>; iter &lt; <span class="number">20</span>; iter++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
                p[i][j] = (div[i][j] +
                    p[i - <span class="number">1</span>][j] + p[i + <span class="number">1</span>][j] +
                    p[i][j - <span class="number">1</span>] + p[i][j + <span class="number">1</span>]
                ) / <span class="number">4</span>;
            }
        }
    }

    <span class="comment">// Subtract pressure gradient from velocity</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.rows - <span class="number">1</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="keyword">this</span>.cols - <span class="number">1</span>; j++) {
            vx[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i][j + <span class="number">1</span>] - p[i][j - <span class="number">1</span>]);
            vy[i][j] -= <span class="number">0.5</span> * <span class="keyword">this</span>.cols * (p[i + <span class="number">1</span>][j] - p[i - <span class="number">1</span>][j]);
        }
    }
}</code></pre>
                </div>

                <div class="example-box">
                    <h4>üí° Understanding Pressure:</h4>
                    <p>Water doesn't compress easily. If too much water flows into a cell, pressure builds up and pushes it out to neighbors. This step ensures the simulation stays physically plausible - the same amount of fluid stays in the system.</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Complete Simulation Step</summary>
                <div class="code-container">
                    <pre><code><span class="comment">// Main simulation step - call this every frame</span>
<span class="function">step</span>(dt = <span class="number">0.016</span>) {
    <span class="keyword">const</span> visc = <span class="number">0.0001</span>;  <span class="comment">// Viscosity (thickness of fluid)</span>
    <span class="keyword">const</span> diff = <span class="number">0.0001</span>;  <span class="comment">// Diffusion rate</span>

    <span class="comment">// 1. Diffuse velocity (friction between fluid layers)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, visc, dt);
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, visc, dt);

    <span class="comment">// 2. Project (fix velocity to be incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 3. Advect velocity (velocity moves itself)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.vy, <span class="keyword">this</span>.vy0, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0, dt);

    <span class="comment">// 4. Project again (ensure still incompressible)</span>
    <span class="keyword">this</span>.<span class="function">project</span>(<span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, <span class="keyword">this</span>.vx0, <span class="keyword">this</span>.vy0);

    <span class="comment">// 5. Diffuse density (dye spreads out)</span>
    <span class="keyword">this</span>.<span class="function">diffuse</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, diff, dt);

    <span class="comment">// 6. Advect density (velocity carries dye along)</span>
    <span class="keyword">this</span>.<span class="function">advect</span>(<span class="keyword">this</span>.density, <span class="keyword">this</span>.density0, <span class="keyword">this</span>.vx, <span class="keyword">this</span>.vy, dt);

    <span class="comment">// 7. Fade density over time (optional, for visual effect)</span>
    <span class="keyword">this</span>.<span class="function">fadeDensity</span>(<span class="number">0.99</span>);
}

<span class="function">fadeDensity</span>(fadeRate) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++) {
        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++) {
            <span class="keyword">this</span>.density[i][j] *= fadeRate;
        }
    }
}</code></pre>
                </div>
            </details>

            <h3>Interactive Demo: Fluid Simulation</h3>
            <div class="example-box">
                <strong>üñ±Ô∏è How to Use:</strong> Click and drag on the canvas below to add fluid and watch it flow! Try different presets and features below.
            </div>
            <div class="diagram">
                <canvas id="fluidDemo" width="800" height="600" style="border: 1px solid #444;"></canvas>
            </div>

            <div class="controls" style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px;">
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Presets:</strong>
                    <button id="btnWater">üíß Water</button>
                    <button id="btnSmoke">üí® Smoke</button>
                    <button id="btnInk">üñãÔ∏è Ink</button>
                    <button id="btnHoney">üçØ Honey</button>
                    <button id="btnGas">‚òÅÔ∏è Gas</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Features:</strong>
                    <button id="btnVelocity">Show Velocity Field</button>
                    <button id="btnAddObstacle">Add Obstacle (Click Canvas)</button>
                    <button id="btnClearObstacles">Clear Obstacles</button>
                    <button id="btnContinuousSource">Continuous Source</button>
                    <button id="btnWind">Toggle Wind</button>
                </div>

                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <strong>Quick Switch:</strong>
                    <button id="btnColorDefault">üíß Water</button>
                    <button id="btnColorRainbow">üåà Ink</button>
                    <button id="btnColorFire">üçØ Honey</button>
                    <button id="btnColorBlue">‚òÅÔ∏è Gas</button>
                    <button id="btnClearFluid">üóëÔ∏è Clear All</button>
                </div>

                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <label>
                        Viscosity: <input type="range" id="viscSlider" min="0" max="0.002" step="0.0001" value="0.0001">
                        <span id="viscValue">0.0001</span>
                    </label>
                    <label>
                        Diffusion: <input type="range" id="diffSlider" min="0" max="0.001" step="0.0001" value="0.0001">
                        <span id="diffValue">0.0001</span>
                    </label>
                    <label>
                        Fade Rate: <input type="range" id="fadeSlider" min="0.9" max="1" step="0.01" value="0.99">
                        <span id="fadeValue">0.99</span>
                    </label>
                </div>
            </div>

            <div class="info-display" id="fluidInfo" style="margin-top: 10px;">
                Current Mode: Free Draw | Click and drag to add fluid
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üé® Try These Examples (Each Material Looks Completely Different!):</h4>
                <ol>
                    <li><strong>üíß Water (Clear Blue):</strong> Flows freely with a cyan-blue transparent appearance. Great for water effects!</li>
                    <li><strong>üí® Smoke (Gray Wisps):</strong> Soft gray with glow effect that rises upward. Click "Continuous Source" to see it billow!</li>
                    <li><strong>üñãÔ∏è Ink (Rainbow Colors):</strong> Vibrant multicolored fluid that creates beautiful psychedelic patterns</li>
                    <li><strong>üçØ Honey (Golden Amber):</strong> Rich golden color, very thick and viscous - watch it pour slowly!</li>
                    <li><strong>‚òÅÔ∏è Gas (Green-Yellow):</strong> Light greenish with glow, disperses quickly and rises slightly</li>
                    <li><strong>Add Obstacles:</strong> Try any material with obstacles to see realistic flow patterns!</li>
                </ol>
            </div>

            <div class="example-box" style="margin-top: 20px;">
                <h4>‚öôÔ∏è Understanding the Parameters:</h4>
                <ul>
                    <li><strong>Viscosity:</strong> How "thick" the fluid is
                        <ul>
                            <li>Low (0.00001) = Water, gas - flows freely</li>
                            <li>High (0.001) = Honey, syrup - very thick and slow</li>
                        </ul>
                    </li>
                    <li><strong>Diffusion:</strong> How fast properties spread out
                        <ul>
                            <li>Low = Fluid stays concentrated</li>
                            <li>High = Fluid disperses quickly like smoke or gas</li>
                        </ul>
                    </li>
                    <li><strong>Fade Rate:</strong> How quickly density disappears
                        <ul>
                            <li>0.95 = Fades very quickly (good for gas effects)</li>
                            <li>0.999 = Stays visible for a long time (good for permanent liquids)</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="concept-box" style="margin-top: 20px;">
                <h4>üéØ Visual Features & Material Properties:</h4>
                <ul>
                    <li><strong>Material-Specific Colors:</strong> Each material has unique colors, transparency, and background
                        <ul>
                            <li>üíß <strong>Water:</strong> Cyan-blue on dark blue background (70% opacity)</li>
                            <li>üí® <strong>Smoke:</strong> Soft gray with glow effect on dark gray bg (50% opacity)</li>
                            <li>üñãÔ∏è <strong>Ink:</strong> Rainbow gradient on black background (90% opacity)</li>
                            <li>üçØ <strong>Honey:</strong> Golden amber on brown background (85% opacity)</li>
                            <li>‚òÅÔ∏è <strong>Gas:</strong> Green-yellow with glow on greenish bg (40% opacity)</li>
                        </ul>
                    </li>
                    <li><strong>Velocity Field:</strong> White arrows showing fluid movement direction and speed</li>
                    <li><strong>Obstacles:</strong> Gray barriers that create realistic flow patterns around them</li>
                    <li><strong>Continuous Source:</strong> Constant fluid stream from top center</li>
                    <li><strong>Wind/Buoyancy:</strong> Upward force (automatic for smoke and gas)</li>
                </ul>
            </div>

            <div class="key-point">
                <strong>üéÆ Game Usage:</strong> Fluid simulation is perfect for water effects, smoke, fire, magic spells, and atmospheric effects. Adjust grid resolution for performance - smaller grids run faster but look less detailed.
            </div>

            <div class="example-box">
                <h4>‚ö° Performance Tips:</h4>
                <ul>
                    <li><strong>Grid Size:</strong> Use smaller grids (32x32 or 64x64) for real-time games</li>
                    <li><strong>Iterations:</strong> Reduce iteration count (10-15) if too slow</li>
                    <li><strong>GPU:</strong> Consider WebGL shaders for large simulations</li>
                    <li><strong>Hybrid:</strong> Combine simple particle systems with fluid for best visual/performance ratio</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>üìö Further Reading:</h4>
                <ul>
                    <li><strong>Navier-Stokes Equations:</strong> The full physics of fluid motion</li>
                    <li><strong>Jos Stam's "Stable Fluids":</strong> The paper this technique is based on</li>
                    <li><strong>SPH (Smoothed Particle Hydrodynamics):</strong> Alternative particle-based approach</li>
                    <li><strong>Level Set Methods:</strong> For tracking fluid surfaces</li>
                </ul>
            </div>
        </div>

        <!-- GAME MECHANICS DEMOS -->
        <div id="game-mechanics" class="section">
            <h2>üéÆ Fluid Dynamics as Game Mechanics</h2>
            <p>Let's see how fluid simulation translates into actual playable game mechanics!</p>

            <!-- Demo 1: Water Buoyancy -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>1. üåä Water Buoyancy & Floating Objects</h3>
                <p>Objects float or sink based on their density. This is used in games for boats, swimming mechanics, and physics puzzles.</p>

                <div class="diagram">
                    <canvas id="buoyancyDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddBox">Add Box (Floats)</button>
                    <button id="btnAddStone">Add Stone (Sinks)</button>
                    <button id="btnAddBall">Add Ball (Bounces)</button>
                    <button id="btnDrain">Drain Water</button>
                    <button id="btnFill">Fill Water</button>
                    <button id="btnResetBuoyancy">Reset</button>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to drop objects! Lighter objects float, heavier ones sink. Watch buoyancy forces in action!
                </div>
            </div>

            <!-- Demo 2: Rising Water Level -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>2. ‚è´ Rising Water Challenge</h3>
                <p>Classic escape mechanic - water rises and the player must climb to safety! Used in platformers and puzzle games.</p>

                <div class="diagram">
                    <canvas id="risingWaterDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnStartRising">Start Water Rising</button>
                    <button id="btnStopRising">Stop</button>
                    <button id="btnResetRising">Reset Level</button>
                    <span style="margin-left: 20px;">Use Arrow Keys to move the player</span>
                </div>
                <div class="info-display" id="risingWaterInfo" style="margin-top: 10px;">
                    Climb the platforms before the water reaches you! Player moves slower in water.
                </div>
            </div>

            <!-- Demo 3: Particle-Based Water (SPH) -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>3. üíß Particle-Based Water (SPH)</h3>
                <p>Smoothed Particle Hydrodynamics - each water particle interacts with neighbors. Great for splash effects and destructible water.</p>

                <div class="diagram">
                    <canvas id="sphDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnAddWater">Add Water Particles</button>
                    <button id="btnAddBarrier">Add Barrier (Click Canvas)</button>
                    <button id="btnToggleGravity">Toggle Gravity</button>
                    <button id="btnResetSPH">Reset</button>
                    <label>
                        Viscosity: <input type="range" id="sphViscosity" min="0.1" max="1" step="0.1" value="0.5">
                        <span id="sphViscValue">0.5</span>
                    </label>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click to add water particles. They attract each other and flow like real liquid!
                </div>
            </div>

            <!-- Demo 4: Flow-Based Puzzle -->
            <div class="concept-box" style="margin-top: 30px;">
                <h3>4. üß© Flow Direction Mechanic (Simplified)</h3>
                <p>Water flows downward but can be redirected. This demo shows the concept behind puzzle games like "Where's My Water?" - simplified for clarity.</p>

                <div class="diagram">
                    <canvas id="flowPuzzleDemo" width="800" height="500"></canvas>
                </div>
                <div class="controls">
                    <button id="btnRelease">Release Water</button>
                    <button id="btnAddPlatform">Add Platform (Blocks Water)</button>
                    <button id="btnResetPuzzle">Reset</button>
                    <span style="margin-left: 20px; font-weight: bold;" id="puzzleStatus">Watch water flow and collect</span>
                </div>
                <div class="info-display" style="margin-top: 10px;">
                    Click "Release Water" to start. Water flows down naturally and fills the bucket. Click "Add Platform" then click canvas to block water flow.
                </div>

                <div class="key-point" style="margin-top: 15px;">
                    <strong>üí° Implementation Note:</strong> Full pipe-routing puzzles require complex pathfinding logic. This simplified demo shows the core concept: water as particles that follow simple rules (gravity + obstacles). For production games, consider using:
                    <ul style="margin-top: 5px;">
                        <li>Grid-based flow fields for directing water</li>
                        <li>Waypoint systems for pipe networks</li>
                        <li>Simplified particle systems for visual effects</li>
                    </ul>
                </div>
            </div>

            <div class="key-point" style="margin-top: 30px;">
                <strong>üí° Design Tip:</strong> Different fluid representations work for different game types:
                <ul style="margin-top: 10px;">
                    <li><strong>Grid-based (Navier-Stokes):</strong> Best for atmospheric effects, smoke, gas - continuous fields</li>
                    <li><strong>Particle-based (SPH):</strong> Best for interactive water, splashes, destruction - discrete elements</li>
                    <li><strong>Simplified/Fake:</strong> Best for performance-critical games - rising water levels, flow direction only</li>
                </ul>
            </div>
        </div>

        <!-- Scroll to Top Button -->
        <div class="scroll-to-top" id="scrollToTop">‚Üë</div>
    </div>

    <script>
        // Scroll to top functionality
        const scrollToTopBtn = document.getElementById('scrollToTop');

        scrollToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopBtn.style.opacity = '1';
            } else {
                scrollToTopBtn.style.opacity = '0';
            }
        });

        scrollToTopBtn.style.opacity = '0';
        scrollToTopBtn.style.transition = 'opacity 0.3s';

        // ===================================
        // FLUID SIMULATION DEMO
        // ===================================

        // Ensure DOM is loaded
        const canvas = document.getElementById('fluidDemo');
        const ctx = canvas.getContext('2d');

        if (!canvas || !ctx) {
            console.error('Canvas not found!');
        } else {

        class FluidGrid {
            constructor(width, height, scale) {
                this.cols = Math.floor(width / scale);
                this.rows = Math.floor(height / scale);
                this.scale = scale;

                this.vx = this.createGrid();
                this.vy = this.createGrid();
                this.vx0 = this.createGrid();
                this.vy0 = this.createGrid();

                this.density = this.createGrid();
                this.density0 = this.createGrid();

                // For projection
                this.p = this.createGrid();
                this.div = this.createGrid();

                // Obstacles (1 = blocked, 0 = free)
                this.obstacles = this.createGrid();

                // Settings
                this.visc = 0.0001;
                this.diff = 0.0001;
                this.fadeRate = 0.99;

                // Visual settings
                this.colorMode = 'default';
                this.showVelocity = false;
                this.material = 'water'; // water, smoke, ink, honey, gas

                // Wind/gravity
                this.windX = 0;
                this.windY = 0;
            }

            createGrid() {
                const grid = [];
                for (let i = 0; i < this.rows; i++) {
                    grid[i] = new Array(this.cols).fill(0);
                }
                return grid;
            }

            diffuse(x, x0, diffusion, dt) {
                const a = dt * diffusion * this.cols * this.rows;

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            if (this.obstacles[i][j] === 1) continue;

                            x[i][j] = (x0[i][j] + a * (
                                x[i - 1][j] + x[i + 1][j] +
                                x[i][j - 1] + x[i][j + 1]
                            )) / (1 + 4 * a);
                        }
                    }
                    this.setBoundary(0, x);
                }
            }

            advect(d, d0, vx, vy, dt) {
                const dt0 = dt * this.cols;

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        if (this.obstacles[i][j] === 1) {
                            d[i][j] = 0;
                            continue;
                        }

                        let x = j - dt0 * vx[i][j];
                        let y = i - dt0 * vy[i][j];

                        x = Math.max(0.5, Math.min(this.cols - 1.5, x));
                        y = Math.max(0.5, Math.min(this.rows - 1.5, y));

                        const i0 = Math.floor(y);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(x);
                        const j1 = j0 + 1;

                        const s1 = x - j0;
                        const s0 = 1 - s1;
                        const t1 = y - i0;
                        const t0 = 1 - t1;

                        d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i1][j0]) +
                                  s1 * (t0 * d0[i0][j1] + t1 * d0[i1][j1]);
                    }
                }
                this.setBoundary(0, d);
            }

            project(vx, vy, p, div) {
                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        div[i][j] = -0.5 * (
                            vx[i][j + 1] - vx[i][j - 1] +
                            vy[i + 1][j] - vy[i - 1][j]
                        ) / this.cols;
                        p[i][j] = 0;
                    }
                }
                this.setBoundary(0, div);
                this.setBoundary(0, p);

                for (let iter = 0; iter < 20; iter++) {
                    for (let i = 1; i < this.rows - 1; i++) {
                        for (let j = 1; j < this.cols - 1; j++) {
                            p[i][j] = (div[i][j] +
                                p[i - 1][j] + p[i + 1][j] +
                                p[i][j - 1] + p[i][j + 1]
                            ) / 4;
                        }
                    }
                    this.setBoundary(0, p);
                }

                for (let i = 1; i < this.rows - 1; i++) {
                    for (let j = 1; j < this.cols - 1; j++) {
                        vx[i][j] -= 0.5 * this.cols * (p[i][j + 1] - p[i][j - 1]);
                        vy[i][j] -= 0.5 * this.cols * (p[i + 1][j] - p[i - 1][j]);
                    }
                }
                this.setBoundary(1, vx);
                this.setBoundary(2, vy);
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.rows - 1; i++) {
                    x[i][0] = b === 1 ? -x[i][1] : x[i][1];
                    x[i][this.cols - 1] = b === 1 ? -x[i][this.cols - 2] : x[i][this.cols - 2];
                }
                for (let j = 1; j < this.cols - 1; j++) {
                    x[0][j] = b === 2 ? -x[1][j] : x[1][j];
                    x[this.rows - 1][j] = b === 2 ? -x[this.rows - 2][j] : x[this.rows - 2][j];
                }

                x[0][0] = 0.5 * (x[1][0] + x[0][1]);
                x[0][this.cols - 1] = 0.5 * (x[1][this.cols - 1] + x[0][this.cols - 2]);
                x[this.rows - 1][0] = 0.5 * (x[this.rows - 2][0] + x[this.rows - 1][1]);
                x[this.rows - 1][this.cols - 1] = 0.5 * (x[this.rows - 2][this.cols - 1] + x[this.rows - 1][this.cols - 2]);
            }

            step(dt = 0.016) {
                // Apply wind/gravity
                if (this.windX !== 0 || this.windY !== 0) {
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            this.vx[i][j] += this.windX * dt * 10;
                            this.vy[i][j] += this.windY * dt * 10;
                        }
                    }
                }

                // Swap arrays
                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.diffuse(this.vx, this.vx0, this.visc, dt);
                this.diffuse(this.vy, this.vy0, this.visc, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.vx0, this.vx] = [this.vx, this.vx0];
                [this.vy0, this.vy] = [this.vy, this.vy0];

                this.advect(this.vx, this.vx0, this.vx0, this.vy0, dt);
                this.advect(this.vy, this.vy0, this.vx0, this.vy0, dt);

                this.project(this.vx, this.vy, this.vx0, this.vy0);

                [this.density0, this.density] = [this.density, this.density0];

                this.diffuse(this.density, this.density0, this.diff, dt);

                [this.density0, this.density] = [this.density, this.density0];

                this.advect(this.density, this.density0, this.vx, this.vy, dt);

                this.fadeDensity(this.fadeRate);
            }

            fadeDensity(fadeRate) {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        this.density[i][j] *= fadeRate;
                    }
                }
            }

            addDensity(x, y, amount) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.density[i][j] += amount;
                }
            }

            addVelocity(x, y, vx, vy) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols) {
                    this.vx[i][j] += vx;
                    this.vy[i][j] += vy;
                }
            }

            addObstacle(x, y, radius = 3) {
                const i = Math.floor(y / this.scale);
                const j = Math.floor(x / this.scale);

                for (let di = -radius; di <= radius; di++) {
                    for (let dj = -radius; dj <= radius; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                            if (di * di + dj * dj <= radius * radius) {
                                this.obstacles[ni][nj] = 1;
                            }
                        }
                    }
                }
            }

            clearObstacles() {
                this.obstacles = this.createGrid();
            }

            getColor(density) {
                const d = Math.min(255, Math.floor(density));
                const alpha = Math.min(1, d / 255);

                // Material-specific colors with very distinct appearances
                switch(this.material) {
                    case 'water':
                        // Clear blue water with cyan highlights
                        const waterBlue = Math.floor(150 + (d / 255) * 105);
                        const waterGreen = Math.floor(100 + (d / 255) * 100);
                        return `rgba(30, ${waterGreen}, ${waterBlue}, ${alpha * 0.7})`;

                    case 'smoke':
                        // Gray smoke with slight transparency
                        const smokeGray = Math.floor(100 + (d / 255) * 155);
                        return `rgba(${smokeGray}, ${smokeGray}, ${smokeGray + 20}, ${alpha * 0.5})`;

                    case 'ink':
                        // Vibrant rainbow colors based on density
                        const inkHue = (d / 255) * 360;
                        return `hsla(${inkHue}, 100%, 60%, ${alpha * 0.9})`;

                    case 'honey':
                        // Golden/amber honey color
                        const honeyR = Math.floor(200 + (d / 255) * 55);
                        const honeyG = Math.floor(140 + (d / 255) * 50);
                        const honeyB = Math.floor(20 + (d / 255) * 20);
                        return `rgba(${honeyR}, ${honeyG}, ${honeyB}, ${alpha * 0.85})`;

                    case 'gas':
                        // Light green/yellow gas
                        const gasR = Math.floor(150 + (d / 255) * 80);
                        const gasG = Math.floor(200 + (d / 255) * 55);
                        const gasB = Math.floor(100 + (d / 255) * 60);
                        return `rgba(${gasR}, ${gasG}, ${gasB}, ${alpha * 0.4})`;

                    default:
                        return `rgba(${d}, ${d * 0.5}, ${255 - d}, ${d / 255})`;
                }
            }

            render(ctx) {
                // Background color based on material
                switch(this.material) {
                    case 'water':
                        ctx.fillStyle = '#001020'; // Deep blue-black
                        break;
                    case 'smoke':
                        ctx.fillStyle = '#0a0a0a'; // Dark gray
                        break;
                    case 'honey':
                        ctx.fillStyle = '#1a0f00'; // Dark brown
                        break;
                    case 'gas':
                        ctx.fillStyle = '#0a1008'; // Dark greenish
                        break;
                    default:
                        ctx.fillStyle = '#000';
                }
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw fluid density with glow effect for some materials
                const needsGlow = (this.material === 'gas' || this.material === 'smoke');

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const d = this.density[i][j];
                        if (d > 0) {
                            ctx.fillStyle = this.getColor(d);

                            // Add glow effect for smoke and gas
                            if (needsGlow && d > 50) {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.getColor(d);
                            } else {
                                ctx.shadowBlur = 0;
                            }

                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                ctx.shadowBlur = 0;

                // Draw obstacles
                ctx.fillStyle = '#666';
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.obstacles[i][j] === 1) {
                            ctx.fillRect(j * this.scale, i * this.scale, this.scale, this.scale);
                        }
                    }
                }

                // Draw velocity field
                if (this.showVelocity) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;

                    const step = 4; // Show every 4th cell
                    for (let i = 0; i < this.rows; i += step) {
                        for (let j = 0; j < this.cols; j += step) {
                            const vx = this.vx[i][j];
                            const vy = this.vy[i][j];
                            const mag = Math.sqrt(vx * vx + vy * vy);

                            if (mag > 0.1) {
                                const x = j * this.scale + this.scale / 2;
                                const y = i * this.scale + this.scale / 2;
                                const scale = 5;

                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + vx * scale, y + vy * scale);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
        }

        const fluid = new FluidGrid(canvas.width, canvas.height, 8);

        // Initialize canvas with black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let addingObstacles = false;
        let continuousSource = false;
        let sourceX = canvas.width / 2;
        let sourceY = 50;

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            prevMouseX = e.clientX - rect.left;
            prevMouseY = e.clientY - rect.top;

            if (addingObstacles) {
                fluid.addObstacle(prevMouseX, prevMouseY);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (addingObstacles) {
                    fluid.addObstacle(x, y);
                } else {
                    const vx = (x - prevMouseX) * 10;
                    const vy = (y - prevMouseY) * 10;

                    fluid.addDensity(x, y, 200);
                    fluid.addVelocity(x, y, vx, vy);
                }

                prevMouseX = x;
                prevMouseY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // ===================================
        // PRESET BUTTONS
        // ===================================

        document.getElementById('btnWater').addEventListener('click', () => {
            fluid.visc = 0.0001;
            fluid.diff = 0.0001;
            fluid.fadeRate = 0.99;
            fluid.material = 'water';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üíß Water - Clear blue liquid, low viscosity');
        });

        document.getElementById('btnSmoke').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.0005;
            fluid.fadeRate = 0.97;
            fluid.material = 'smoke';
            fluid.windY = -0.8; // Strong upward buoyancy
            updateSliders();
            updateInfo('üí® Smoke - Gray wisps that rise upward with buoyancy');
        });

        document.getElementById('btnInk').addEventListener('click', () => {
            fluid.visc = 0.0002;
            fluid.diff = 0.0003;
            fluid.fadeRate = 0.995;
            fluid.material = 'ink';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üñãÔ∏è Ink - Vibrant rainbow colors, medium viscosity');
        });

        document.getElementById('btnHoney').addEventListener('click', () => {
            fluid.visc = 0.0015;
            fluid.diff = 0.00003;
            fluid.fadeRate = 0.999;
            fluid.material = 'honey';
            fluid.windY = 0;
            updateSliders();
            updateInfo('üçØ Honey - Golden amber, very thick and viscous');
        });

        document.getElementById('btnGas').addEventListener('click', () => {
            fluid.visc = 0.00001;
            fluid.diff = 0.001;
            fluid.fadeRate = 0.94;
            fluid.material = 'gas';
            fluid.windY = -0.3;
            updateSliders();
            updateInfo('‚òÅÔ∏è Gas - Light green/yellow, disperses quickly');
        });

        // ===================================
        // FEATURE BUTTONS
        // ===================================

        document.getElementById('btnVelocity').addEventListener('click', () => {
            fluid.showVelocity = !fluid.showVelocity;
            updateInfo(fluid.showVelocity ? 'Velocity field shown' : 'Velocity field hidden');
        });

        document.getElementById('btnAddObstacle').addEventListener('click', () => {
            addingObstacles = !addingObstacles;
            updateInfo(addingObstacles ? 'Click canvas to add obstacles' : 'Obstacle mode disabled');
        });

        document.getElementById('btnClearObstacles').addEventListener('click', () => {
            fluid.clearObstacles();
            updateInfo('Obstacles cleared');
        });

        document.getElementById('btnContinuousSource').addEventListener('click', () => {
            continuousSource = !continuousSource;
            updateInfo(continuousSource ? 'Continuous source enabled at top center' : 'Continuous source disabled');
        });

        document.getElementById('btnWind').addEventListener('click', () => {
            if (fluid.windY === 0) {
                fluid.windY = -0.5;
                updateInfo('Wind enabled - Upward force');
            } else {
                fluid.windY = 0;
                updateInfo('Wind disabled');
            }
        });

        // ===================================
        // COLOR MODE BUTTONS
        // ===================================

        document.getElementById('btnColorDefault').addEventListener('click', () => {
            fluid.material = 'water';
            updateInfo('Material changed to Water (blue)');
        });

        document.getElementById('btnColorRainbow').addEventListener('click', () => {
            fluid.material = 'ink';
            updateInfo('Material changed to Ink (rainbow)');
        });

        document.getElementById('btnColorFire').addEventListener('click', () => {
            fluid.material = 'honey';
            updateInfo('Material changed to Honey (golden/amber)');
        });

        document.getElementById('btnColorBlue').addEventListener('click', () => {
            fluid.material = 'gas';
            updateInfo('Material changed to Gas (green/yellow)');
        });

        document.getElementById('btnClearFluid').addEventListener('click', () => {
            fluid.density = fluid.createGrid();
            fluid.vx = fluid.createGrid();
            fluid.vy = fluid.createGrid();
            fluid.windX = 0;
            fluid.windY = 0;
            continuousSource = false;
            updateInfo('Fluid cleared');
        });

        // ===================================
        // SLIDERS
        // ===================================

        const viscSlider = document.getElementById('viscSlider');
        const viscValue = document.getElementById('viscValue');
        const diffSlider = document.getElementById('diffSlider');
        const diffValue = document.getElementById('diffValue');
        const fadeSlider = document.getElementById('fadeSlider');
        const fadeValue = document.getElementById('fadeValue');

        viscSlider.addEventListener('input', (e) => {
            fluid.visc = parseFloat(e.target.value);
            viscValue.textContent = fluid.visc.toFixed(4);
        });

        diffSlider.addEventListener('input', (e) => {
            fluid.diff = parseFloat(e.target.value);
            diffValue.textContent = fluid.diff.toFixed(4);
        });

        fadeSlider.addEventListener('input', (e) => {
            fluid.fadeRate = parseFloat(e.target.value);
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        });

        function updateSliders() {
            viscSlider.value = fluid.visc;
            viscValue.textContent = fluid.visc.toFixed(4);
            diffSlider.value = fluid.diff;
            diffValue.textContent = fluid.diff.toFixed(4);
            fadeSlider.value = fluid.fadeRate;
            fadeValue.textContent = fluid.fadeRate.toFixed(2);
        }

        function updateInfo(message) {
            document.getElementById('fluidInfo').textContent = message;
        }

        function animate() {
            // Add continuous source if enabled
            if (continuousSource) {
                fluid.addDensity(sourceX, sourceY, 100);
                fluid.addVelocity(sourceX, sourceY, 0, 2);
            }

            fluid.step();
            fluid.render(ctx);
            requestAnimationFrame(animate);
        }

        animate();
        } // End canvas check

        // ===================================
        // DEMO 1: BUOYANCY SIMULATION
        // ===================================

        const buoyancyCanvas = document.getElementById('buoyancyDemo');
        const buoyancyCtx = buoyancyCanvas.getContext('2d');

        let waterLevel = 350;
        const targetWaterLevel = 350;
        let objects = [];

        class PhysicsObject {
            constructor(x, y, width, height, density, color, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.density = density; // kg/m¬≥
                this.color = color;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.mass = width * height * density / 1000;
                this.onGround = false;
            }

            update(dt) {
                const gravity = 800; // pixels/s¬≤
                const waterDensity = 1.0;
                const airResistance = 0.02;
                const waterResistance = 0.1;

                // Check if submerged
                const bottomY = this.y + this.height;
                const topY = this.y;

                let submergedHeight = 0;
                if (bottomY > waterLevel && topY < waterLevel) {
                    submergedHeight = bottomY - waterLevel;
                } else if (topY >= waterLevel) {
                    submergedHeight = this.height;
                }

                const submergedFraction = submergedHeight / this.height;

                // Buoyancy force (Archimedes' principle)
                const buoyancyForce = submergedFraction * this.width * this.height * waterDensity * gravity / 1000;

                // Net force
                const gravityForce = this.mass * gravity;
                let netForce = gravityForce - buoyancyForce;

                // Apply force
                this.vy += (netForce / this.mass) * dt;

                // Resistance
                if (submergedFraction > 0) {
                    this.vx *= (1 - waterResistance);
                    this.vy *= (1 - waterResistance);
                } else {
                    this.vx *= (1 - airResistance);
                    this.vy *= (1 - airResistance);
                }

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < 0) {
                    this.x = 0;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x + this.width > buoyancyCanvas.width) {
                    this.x = buoyancyCanvas.width - this.width;
                    this.vx = -this.vx * 0.5;
                }

                // Floor
                if (this.y + this.height > buoyancyCanvas.height) {
                    this.y = buoyancyCanvas.height - this.height;
                    this.vy = -this.vy * 0.3;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Draw type label
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x + this.width / 2, this.y + this.height / 2 + 4);
            }
        }

        buoyancyCanvas.addEventListener('click', (e) => {
            const rect = buoyancyCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a random object at click position
            const types = ['box', 'stone', 'ball'];
            const type = types[Math.floor(Math.random() * types.length)];

            if (type === 'box') {
                objects.push(new PhysicsObject(x - 20, y - 20, 40, 40, 0.5, '#8B4513', 'BOX'));
            } else if (type === 'stone') {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 2.5, '#555', 'STONE'));
            } else {
                objects.push(new PhysicsObject(x - 15, y - 15, 30, 30, 0.3, '#FF6B6B', 'BALL'));
            }
        });

        document.getElementById('btnAddBox').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 40, 40, 0.5, '#8B4513', 'BOX'));
        });

        document.getElementById('btnAddStone').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 2.5, '#555', 'STONE'));
        });

        document.getElementById('btnAddBall').addEventListener('click', () => {
            objects.push(new PhysicsObject(Math.random() * 700 + 50, 50, 30, 30, 0.3, '#FF6B6B', 'BALL'));
        });

        document.getElementById('btnDrain').addEventListener('click', () => {
            waterLevel = Math.max(waterLevel - 100, 500);
        });

        document.getElementById('btnFill').addEventListener('click', () => {
            waterLevel = Math.max(waterLevel - 100, 200);
        });

        document.getElementById('btnResetBuoyancy').addEventListener('click', () => {
            objects = [];
            waterLevel = 350;
        });

        function animateBuoyancy() {
            // Clear
            buoyancyCtx.fillStyle = '#1a1a2e';
            buoyancyCtx.fillRect(0, 0, buoyancyCanvas.width, buoyancyCanvas.height);

            // Draw water
            buoyancyCtx.fillStyle = 'rgba(30, 144, 255, 0.6)';
            buoyancyCtx.fillRect(0, waterLevel, buoyancyCanvas.width, buoyancyCanvas.height - waterLevel);

            // Draw water surface
            buoyancyCtx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            buoyancyCtx.lineWidth = 3;
            buoyancyCtx.beginPath();
            buoyancyCtx.moveTo(0, waterLevel);
            buoyancyCtx.lineTo(buoyancyCanvas.width, waterLevel);
            buoyancyCtx.stroke();

            // Update and draw objects
            objects.forEach(obj => {
                obj.update(0.016);
                obj.draw(buoyancyCtx);
            });

            // Draw info
            buoyancyCtx.fillStyle = '#fff';
            buoyancyCtx.font = '14px Arial';
            buoyancyCtx.textAlign = 'left';
            buoyancyCtx.fillText(`Water Level: ${Math.floor(waterLevel)}px`, 10, 20);
            buoyancyCtx.fillText(`Objects: ${objects.length}`, 10, 40);

            requestAnimationFrame(animateBuoyancy);
        }

        animateBuoyancy();

        // ===================================
        // DEMO 2: RISING WATER CHALLENGE
        // ===================================

        const risingCanvas = document.getElementById('risingWaterDemo');
        const risingCtx = risingCanvas.getContext('2d');

        let risingWaterLevel = 500;
        let isRising = false;
        let player = {
            x: 100,
            y: 400,
            width: 30,
            height: 40,
            vx: 0,
            vy: 0,
            onGround: false,
            inWater: false,
            alive: true
        };

        const platforms = [
            { x: 50, y: 450, width: 150, height: 20 },
            { x: 250, y: 380, width: 120, height: 20 },
            { x: 420, y: 310, width: 140, height: 20 },
            { x: 600, y: 240, width: 150, height: 20 },
            { x: 200, y: 170, width: 200, height: 20 },
            { x: 450, y: 100, width: 300, height: 20 },
        ];

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        document.getElementById('btnStartRising').addEventListener('click', () => {
            isRising = true;
        });

        document.getElementById('btnStopRising').addEventListener('click', () => {
            isRising = false;
        });

        document.getElementById('btnResetRising').addEventListener('click', () => {
            risingWaterLevel = 500;
            isRising = false;
            player = {
                x: 100,
                y: 400,
                width: 30,
                height: 40,
                vx: 0,
                vy: 0,
                onGround: false,
                inWater: false,
                alive: true
            };
        });

        function updateRisingWater() {
            if (!player.alive) return;

            const speed = player.inWater ? 3 : 5;
            const jumpPower = player.inWater ? -8 : -12;

            // Movement
            if (keys['ArrowLeft']) player.vx = -speed;
            else if (keys['ArrowRight']) player.vx = speed;
            else player.vx *= 0.8;

            // Jump
            if (keys['ArrowUp'] && player.onGround) {
                player.vy = jumpPower;
            }

            // Gravity
            const gravity = player.inWater ? 0.3 : 0.5;
            player.vy += gravity;

            // Update position
            player.x += player.vx;
            player.y += player.vy;

            // Check water
            player.inWater = (player.y + player.height) > risingWaterLevel;

            // Collisions with platforms
            player.onGround = false;
            platforms.forEach(platform => {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.vy >= 0) {
                    player.y = platform.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }
            });

            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > risingCanvas.width) player.x = risingCanvas.width - player.width;

            // Check if drowned
            if (player.y > risingWaterLevel) {
                player.alive = false;
            }

            // Check if safe
            if (player.y < 50 && risingWaterLevel < 100) {
                document.getElementById('risingWaterInfo').textContent = 'üéâ You escaped! You win!';
            }

            // Rise water
            if (isRising && risingWaterLevel > 0) {
                risingWaterLevel -= 0.5;
            }
        }

        function renderRisingWater() {
            // Background
            risingCtx.fillStyle = '#16213e';
            risingCtx.fillRect(0, 0, risingCanvas.width, risingCanvas.height);

            // Platforms
            risingCtx.fillStyle = '#4a5568';
            platforms.forEach(platform => {
                risingCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                risingCtx.strokeStyle = '#718096';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Water
            risingCtx.fillStyle = 'rgba(30, 100, 200, 0.7)';
            risingCtx.fillRect(0, risingWaterLevel, risingCanvas.width, risingCanvas.height - risingWaterLevel);

            // Water surface animation
            risingCtx.strokeStyle = 'rgba(100, 180, 255, 0.9)';
            risingCtx.lineWidth = 3;
            risingCtx.beginPath();
            const time = Date.now() / 200;
            for (let x = 0; x < risingCanvas.width; x += 5) {
                const wave = Math.sin(x / 30 + time) * 3;
                risingCtx.lineTo(x, risingWaterLevel + wave);
            }
            risingCtx.stroke();

            // Player
            if (player.alive) {
                risingCtx.fillStyle = player.inWater ? '#FF6B6B' : '#4ECDC4';
                risingCtx.fillRect(player.x, player.y, player.width, player.height);
                risingCtx.strokeStyle = '#fff';
                risingCtx.lineWidth = 2;
                risingCtx.strokeRect(player.x, player.y, player.width, player.height);

                // Eyes
                risingCtx.fillStyle = '#fff';
                risingCtx.fillRect(player.x + 8, player.y + 10, 5, 5);
                risingCtx.fillRect(player.x + 17, player.y + 10, 5, 5);
            } else {
                risingCtx.fillStyle = '#FF0000';
                risingCtx.font = '30px Arial';
                risingCtx.textAlign = 'center';
                risingCtx.fillText('DROWNED!', risingCanvas.width / 2, risingCanvas.height / 2);
                risingCtx.font = '16px Arial';
                risingCtx.fillText('Click Reset to try again', risingCanvas.width / 2, risingCanvas.height / 2 + 30);
            }

            // Info
            risingCtx.fillStyle = '#fff';
            risingCtx.font = '14px Arial';
            risingCtx.textAlign = 'left';
            risingCtx.fillText(`Water Level: ${Math.floor(risingWaterLevel)}`, 10, 20);
            risingCtx.fillText(`Player Status: ${player.alive ? (player.inWater ? 'In Water!' : 'Safe') : 'Drowned'}`, 10, 40);

            updateRisingWater();
            requestAnimationFrame(renderRisingWater);
        }

        renderRisingWater();

        // ===================================
        // DEMO 3: SPH PARTICLE-BASED WATER
        // ===================================

        const sphCanvas = document.getElementById('sphDemo');
        const sphCtx = sphCanvas.getContext('2d');

        let sphParticles = [];
        let sphBarriers = [];
        let sphGravity = true;
        let sphViscosity = 0.5;
        let addingBarrier = false;

        class WaterParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.density = 0;
                this.pressure = 0;
                this.fx = 0;
                this.fy = 0;
                this.radius = 4;
            }

            update(particles, dt) {
                const h = 20; // Smoothing radius
                const k = 0.1; // Pressure constant
                const restDensity = 1.0;

                // Calculate density
                this.density = 0;
                particles.forEach(other => {
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h) {
                        const q = dist / h;
                        const kernel = (1 - q) * (1 - q);
                        this.density += kernel;
                    }
                });

                // Calculate pressure
                this.pressure = k * (this.density - restDensity);

                // Reset forces
                this.fx = 0;
                this.fy = 0;

                // Pressure force
                particles.forEach(other => {
                    if (other === this) return;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < h && dist > 0.01) {
                        const q = dist / h;
                        const kernel = (1 - q);
                        const pressureForce = -kernel * (this.pressure + other.pressure) / (2 * this.density);

                        this.fx += pressureForce * (dx / dist);
                        this.fy += pressureForce * (dy / dist);
                    }
                });

                // Gravity
                if (sphGravity) {
                    this.fy += 10;
                }

                // Apply forces
                this.vx += this.fx * dt;
                this.vy += this.fy * dt;

                // Viscosity
                this.vx *= (1 - sphViscosity * 0.05);
                this.vy *= (1 - sphViscosity * 0.05);

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Boundaries
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.x > sphCanvas.width - this.radius) {
                    this.x = sphCanvas.width - this.radius;
                    this.vx = -this.vx * 0.5;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy = -this.vy * 0.5;
                }
                if (this.y > sphCanvas.height - this.radius) {
                    this.y = sphCanvas.height - this.radius;
                    this.vy = -this.vy * 0.5;
                }

                // Barrier collisions
                sphBarriers.forEach(barrier => {
                    if (this.x > barrier.x && this.x < barrier.x + barrier.width &&
                        this.y > barrier.y && this.y < barrier.y + barrier.height) {
                        // Simple ejection
                        const dx = this.x - (barrier.x + barrier.width / 2);
                        const dy = this.y - (barrier.y + barrier.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.x += (dx / dist) * 5;
                            this.y += (dy / dist) * 5;
                        }
                        this.vx *= 0.3;
                        this.vy *= 0.3;
                    }
                });
            }

            draw(ctx) {
                const colorIntensity = Math.min(255, this.density * 100);
                ctx.fillStyle = `rgba(30, ${100 + colorIntensity}, ${200 + colorIntensity / 2}, 0.9)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        sphCanvas.addEventListener('click', (e) => {
            const rect = sphCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (addingBarrier) {
                sphBarriers.push({ x: x - 30, y: y - 10, width: 60, height: 20 });
            } else {
                // Add cluster of particles
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20;
                    sphParticles.push(new WaterParticle(
                        x + Math.cos(angle) * radius,
                        y + Math.sin(angle) * radius
                    ));
                }
            }
        });

        document.getElementById('btnAddWater').addEventListener('click', () => {
            for (let i = 0; i < 30; i++) {
                sphParticles.push(new WaterParticle(
                    Math.random() * 200 + 300,
                    Math.random() * 100 + 50
                ));
            }
        });

        document.getElementById('btnAddBarrier').addEventListener('click', () => {
            addingBarrier = !addingBarrier;
        });

        document.getElementById('btnToggleGravity').addEventListener('click', () => {
            sphGravity = !sphGravity;
        });

        document.getElementById('btnResetSPH').addEventListener('click', () => {
            sphParticles = [];
            sphBarriers = [];
        });

        document.getElementById('sphViscosity').addEventListener('input', (e) => {
            sphViscosity = parseFloat(e.target.value);
            document.getElementById('sphViscValue').textContent = sphViscosity.toFixed(1);
        });

        function animateSPH() {
            sphCtx.fillStyle = '#0a0e1a';
            sphCtx.fillRect(0, 0, sphCanvas.width, sphCanvas.height);

            // Draw barriers
            sphCtx.fillStyle = '#666';
            sphBarriers.forEach(barrier => {
                sphCtx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
            });

            // Update and draw particles
            const dt = 0.1;
            sphParticles.forEach(p => p.update(sphParticles, dt));
            sphParticles.forEach(p => p.draw(sphCtx));

            // Info
            sphCtx.fillStyle = '#fff';
            sphCtx.font = '14px Arial';
            sphCtx.textAlign = 'left';
            sphCtx.fillText(`Particles: ${sphParticles.length}`, 10, 20);
            sphCtx.fillText(`Gravity: ${sphGravity ? 'ON' : 'OFF'}`, 10, 40);

            requestAnimationFrame(animateSPH);
        }

        animateSPH();

        // ===================================
        // DEMO 4: SIMPLIFIED FLOW MECHANIC
        // ===================================

        const puzzleCanvas = document.getElementById('flowPuzzleDemo');
        const puzzleCtx = puzzleCanvas.getContext('2d');

        let waterReleased = false;
        let addingPlatforms = false;
        let flowPlatforms = [];

        const bucket = { x: 650, y: 400, width: 100, height: 80, filled: 0 };
        const source = { x: 400, y: 50 };

        // Grid-based flow system
        const cellSize = 10;
        const cols = Math.floor(puzzleCanvas.width / cellSize);
        const rows = Math.floor(puzzleCanvas.height / cellSize);
        let waterGrid = [];
        let velocityGrid = [];

        // Initialize grids
        for (let i = 0; i < cols; i++) {
            waterGrid[i] = [];
            velocityGrid[i] = [];
            for (let j = 0; j < rows; j++) {
                waterGrid[i][j] = 0;
                velocityGrid[i][j] = { vx: 0, vy: 0 };
            }
        }

        // Check if cell is blocked by platform
        function isBlocked(gridX, gridY) {
            const x = gridX * cellSize;
            const y = gridY * cellSize;

            for (let platform of flowPlatforms) {
                if (x + cellSize > platform.x && x < platform.x + platform.width &&
                    y + cellSize > platform.y && y < platform.y + platform.height) {
                    return true;
                }
            }
            return false;
        }

        // Update water flow
        function updateFlow() {
            const newWater = [];
            for (let i = 0; i < cols; i++) {
                newWater[i] = [];
                for (let j = 0; j < rows; j++) {
                    newWater[i][j] = waterGrid[i][j];
                }
            }

            // Add water from source
            if (waterReleased) {
                const sourceGridX = Math.floor(source.x / cellSize);
                const sourceGridY = Math.floor(source.y / cellSize);
                for (let dx = -2; dx <= 2; dx++) {
                    const gx = sourceGridX + dx;
                    if (gx >= 0 && gx < cols && sourceGridY >= 0 && sourceGridY < rows) {
                        newWater[gx][sourceGridY] = Math.min(255, newWater[gx][sourceGridY] + 35);
                    }
                }
            }

            // Flow simulation - water flows down and spreads
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 5 && !isBlocked(i, j)) {
                        const amount = waterGrid[i][j];

                        // Try to flow down first
                        if (j < rows - 1 && !isBlocked(i, j + 1)) {
                            const flowDown = Math.min(amount * 0.5, 255 - newWater[i][j + 1]);
                            newWater[i][j] -= flowDown;
                            newWater[i][j + 1] += flowDown;
                        }

                        // Then spread sideways if there's water left
                        if (newWater[i][j] > 10) {
                            // Flow left
                            if (i > 0 && !isBlocked(i - 1, j)) {
                                const diff = (newWater[i][j] - newWater[i - 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i - 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i - 1][j] += flow;
                                }
                            }

                            // Flow right
                            if (i < cols - 1 && !isBlocked(i + 1, j)) {
                                const diff = (newWater[i][j] - newWater[i + 1][j]) * 0.15;
                                if (diff > 0) {
                                    const flow = Math.min(diff, 255 - newWater[i + 1][j]);
                                    newWater[i][j] -= flow;
                                    newWater[i + 1][j] += flow;
                                }
                            }
                        }
                    }

                    // Check if water reached bucket
                    const x = i * cellSize;
                    const y = j * cellSize;
                    if (x > bucket.x && x < bucket.x + bucket.width &&
                        y > bucket.y && y < bucket.y + bucket.height) {
                        if (newWater[i][j] > 0) {
                            bucket.filled = Math.min(100, bucket.filled + newWater[i][j] * 0.01);
                            newWater[i][j] = 0;
                        }
                    }

                    // Evaporation at bottom
                    if (j === rows - 1 && newWater[i][j] > 0) {
                        newWater[i][j] *= 0.95;
                    }
                }
            }

            waterGrid = newWater;
        }

        // Draw water grid
        function drawWater(ctx) {
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const amount = waterGrid[i][j];
                    if (amount > 3) {
                        // Much more visible water color
                        const intensity = Math.min(1, amount / 180);

                        // Bright cyan-blue water
                        const r = Math.floor(30 + intensity * 50);
                        const g = Math.floor(180 + intensity * 75);
                        const b = Math.floor(220 + intensity * 35);

                        // Higher base opacity
                        const alpha = Math.max(0.7, intensity);

                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                        // Add white highlights to make water more visible
                        if (amount > 50) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.4})`;
                            ctx.fillRect(i * cellSize + 1, j * cellSize + 1, cellSize - 2, cellSize - 2);
                        }

                        // Add shimmer effect
                        if (amount > 80 && Math.random() < 0.15) {
                            ctx.fillStyle = `rgba(200, 255, 255, 0.6)`;
                            const shimmerSize = cellSize * 0.6;
                            ctx.fillRect(
                                i * cellSize + (cellSize - shimmerSize) / 2,
                                j * cellSize + (cellSize - shimmerSize) / 2,
                                shimmerSize,
                                shimmerSize
                            );
                        }
                    }
                }
            }
        }

        puzzleCanvas.addEventListener('click', (e) => {
            if (!addingPlatforms) return;

            const rect = puzzleCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add a platform
            flowPlatforms.push({
                x: x - 40,
                y: y,
                width: 80,
                height: 10
            });
        });

        document.getElementById('btnRelease').addEventListener('click', () => {
            waterReleased = !waterReleased;
            document.getElementById('btnRelease').textContent = waterReleased ? 'Stop Water' : 'Release Water';
        });

        document.getElementById('btnAddPlatform').addEventListener('click', (e) => {
            addingPlatforms = !addingPlatforms;
            e.target.textContent = addingPlatforms ? 'Stop Adding Platforms' : 'Add Platform (Blocks Water)';
            e.target.style.backgroundColor = addingPlatforms ? '#4CAF50' : '#4a5568';
        });

        document.getElementById('btnResetPuzzle').addEventListener('click', () => {
            waterReleased = false;
            flowPlatforms = [];
            bucket.filled = 0;
            // Reset water grid
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    waterGrid[i][j] = 0;
                }
            }
            document.getElementById('btnRelease').textContent = 'Release Water';
        });

        function animatePuzzle() {
            // Background - darker for better water contrast
            puzzleCtx.fillStyle = '#0a0e1a';
            puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);

            // Update and draw water flow
            updateFlow();
            drawWater(puzzleCtx);

            // Draw source
            puzzleCtx.fillStyle = '#4FC3F7';
            puzzleCtx.fillRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.strokeStyle = '#82CEFF';
            puzzleCtx.lineWidth = 2;
            puzzleCtx.strokeRect(source.x - 25, source.y - 15, 50, 30);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = 'bold 12px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('SOURCE', source.x, source.y + 5);

            // Draw platforms
            puzzleCtx.fillStyle = '#4a5568';
            flowPlatforms.forEach(platform => {
                puzzleCtx.fillRect(platform.x, platform.y, platform.width, platform.height);
                puzzleCtx.strokeStyle = '#718096';
                puzzleCtx.lineWidth = 2;
                puzzleCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Platform mode indicator
            if (addingPlatforms) {
                puzzleCtx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                puzzleCtx.fillRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
                puzzleCtx.fillStyle = '#4CAF50';
                puzzleCtx.font = 'bold 20px Arial';
                puzzleCtx.textAlign = 'center';
                puzzleCtx.fillText('Click to add platforms', puzzleCanvas.width / 2, 30);
            }

            // Draw bucket
            puzzleCtx.strokeStyle = '#8B4513';
            puzzleCtx.lineWidth = 4;
            puzzleCtx.strokeRect(bucket.x, bucket.y, bucket.width, bucket.height);

            // Fill water in bucket
            puzzleCtx.fillStyle = 'rgba(30, 144, 255, 0.7)';
            const fillHeight = (bucket.filled / 100) * bucket.height;
            puzzleCtx.fillRect(bucket.x, bucket.y + bucket.height - fillHeight, bucket.width, fillHeight);

            // Bucket label
            puzzleCtx.fillStyle = '#FFD700';
            puzzleCtx.font = 'bold 14px Arial';
            puzzleCtx.textAlign = 'center';
            puzzleCtx.fillText('BUCKET', bucket.x + bucket.width / 2, bucket.y - 5);
            puzzleCtx.fillStyle = '#fff';
            puzzleCtx.font = '12px Arial';
            puzzleCtx.fillText(`${Math.floor(bucket.filled)}%`, bucket.x + bucket.width / 2, bucket.y + bucket.height / 2);

            // Calculate total water in system
            let totalWater = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (waterGrid[i][j] > 0) totalWater++;
                }
            }

            // Update status
            const bucketPercent = Math.floor(bucket.filled);
            if (bucket.filled >= 90) {
                document.getElementById('puzzleStatus').textContent = `üéâ Bucket Full! ${bucketPercent}%`;
            } else {
                document.getElementById('puzzleStatus').textContent = `Bucket: ${bucketPercent}% | Platforms: ${flowPlatforms.length} | Water Cells: ${totalWater}`;
            }

            requestAnimationFrame(animatePuzzle);
        }

        animatePuzzle();

    </script>
</body>
</html>
