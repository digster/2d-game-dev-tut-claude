<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation v2 - Advanced Physics</title>
    <link rel="stylesheet" href="shared/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üî¨ Simulation v2 - Advanced Physics</h1>
        <p class="subtitle">Accurate physics simulations using proper numerical methods and algorithms</p>

        <!-- Navigation -->
        <div class="nav">
            <a href="index.html" class="nav-button">‚Üê Home</a>
            <a href="simulation.html" class="nav-button">Simulation v1</a>
            <a href="simulation-v2.html" class="nav-button active">Simulation v2</a>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">üìö Advanced Simulations</div>
            <p style="text-align: center; color: #9e9e9e; margin-bottom: 20px;">
                Each simulation uses more accurate physics than basic implementations
            </p>
            <ul>
                <li><a href="#double-pendulum">1. Double Pendulum (Chaos Theory)</a> - Lagrangian mechanics, RK4 integration</li>
                <li><a href="#rigid-body">2. Rigid Body Physics</a> - Torque, angular momentum, SAT collision</li>
                <li><a href="#cloth">3. Cloth Simulation</a> - 3-spring model, tear mechanics</li>
                <li><a href="#sph-water">4. SPH Water v2</a> - Poly6/Spiky kernels, spatial hashing</li>
                <li><a href="#perlin-wind">5. Perlin Noise Wind Field</a> - Curl noise, divergence-free flow</li>
                <li><a href="#heat-diffusion">6. Heat Diffusion</a> - Heat equation, conductivity, convection</li>
            </ul>
        </div>

        <!-- Comparison Table -->
        <div class="section">
            <h2>üìä v1 vs v2 Comparison</h2>
            <div class="concept-box">
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <tr style="border-bottom: 2px solid #4fc3f7;">
                        <th style="text-align: left; padding: 10px; color: #4fc3f7;">Topic</th>
                        <th style="text-align: left; padding: 10px; color: #4fc3f7;">v1 (Basic)</th>
                        <th style="text-align: left; padding: 10px; color: #4fc3f7;">v2 (Accurate)</th>
                        <th style="text-align: left; padding: 10px; color: #4fc3f7;">Key Improvement</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #2d3354;">
                        <td style="padding: 10px;">Chaos</td>
                        <td style="padding: 10px; color: #9e9e9e;">None</td>
                        <td style="padding: 10px; color: #66bb6a;">Double pendulum</td>
                        <td style="padding: 10px;">RK4 integration, Lagrangian mechanics</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #2d3354;">
                        <td style="padding: 10px;">Rotation</td>
                        <td style="padding: 10px; color: #9e9e9e;">None</td>
                        <td style="padding: 10px; color: #66bb6a;">Rigid body</td>
                        <td style="padding: 10px;">Torque, angular momentum, tumbling</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #2d3354;">
                        <td style="padding: 10px;">Soft Body</td>
                        <td style="padding: 10px; color: #ffa726;">Verlet rope</td>
                        <td style="padding: 10px; color: #66bb6a;">Full cloth</td>
                        <td style="padding: 10px;">3 spring types, tear mechanics</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #2d3354;">
                        <td style="padding: 10px;">Fluid</td>
                        <td style="padding: 10px; color: #ffa726;">Linear SPH</td>
                        <td style="padding: 10px; color: #66bb6a;">Kernel-based SPH</td>
                        <td style="padding: 10px;">Poly6/Spiky kernels, surface tension</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #2d3354;">
                        <td style="padding: 10px;">Wind</td>
                        <td style="padding: 10px; color: #ffa726;">sin/cos noise</td>
                        <td style="padding: 10px; color: #66bb6a;">Perlin curl noise</td>
                        <td style="padding: 10px;">Aperiodic, divergence-free flow</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Thermal</td>
                        <td style="padding: 10px; color: #ffa726;">Probabilistic</td>
                        <td style="padding: 10px; color: #66bb6a;">Heat equation</td>
                        <td style="padding: 10px;">Physical conductivity, convection</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- ==================== DOUBLE PENDULUM ==================== -->
        <div id="double-pendulum" class="section">
            <span class="level-indicator level-expert">CHAOS THEORY</span>
            <h2>1. Double Pendulum</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>A double pendulum is a classic example of <strong>chaotic behavior</strong> - tiny changes in initial conditions lead to wildly different outcomes. Basic implementations fail because:</p>
                <ul>
                    <li><strong>Euler integration</strong> accumulates energy errors, making the pendulum spin faster over time</li>
                    <li><strong>Small-angle approximations</strong> (sin Œ∏ ‚âà Œ∏) break down for large swings</li>
                </ul>
                <p>Our v2 uses <strong>Lagrangian mechanics</strong> with <strong>Runge-Kutta 4</strong> integration for energy-conserving accuracy.</p>
            </div>

            <div class="concept-box">
                <h4>The Physics: Lagrangian Mechanics</h4>
                <p>Instead of F=ma, we use the <strong>Lagrangian</strong> L = T - V (kinetic minus potential energy):</p>
                <div class="formula">
                    Œ±‚ÇÅ = [‚àíg(2m‚ÇÅ+m‚ÇÇ)sin(Œ∏‚ÇÅ) ‚àí m‚ÇÇg¬∑sin(Œ∏‚ÇÅ‚àí2Œ∏‚ÇÇ) ‚àí 2sin(Œ∏‚ÇÅ‚àíŒ∏‚ÇÇ)m‚ÇÇ(œâ‚ÇÇ¬≤L‚ÇÇ + œâ‚ÇÅ¬≤L‚ÇÅcos(Œ∏‚ÇÅ‚àíŒ∏‚ÇÇ))] / [L‚ÇÅ(2m‚ÇÅ+m‚ÇÇ‚àím‚ÇÇcos(2Œ∏‚ÇÅ‚àí2Œ∏‚ÇÇ))]
                </div>
                <p>This looks scary, but the code handles it! The key insight: we track angles (Œ∏) and angular velocities (œâ), not x/y positions.</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Drag the pendulum bobs to set initial positions. Watch how tiny differences create completely different paths!</p>

            <canvas id="pendulumCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="pendulumReset">Reset</button>
                <button id="pendulumPause">Pause</button>
                <button id="pendulumCompare">Compare Mode</button>
                <button id="pendulumClearTrail">Clear Trail</button>
            </div>
            <div class="info-display" id="pendulumInfo">
                Energy: <span id="pendulumEnergy">0</span> J |
                Drag a bob to reposition |
                Compare mode shows chaos sensitivity
            </div>

            <details>
                <summary>üìù Click to see: Runge-Kutta 4 Integration</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// RK4 is crucial for chaotic systems - Euler would fail!
// It evaluates derivatives at 4 points per step for accuracy
function rk4Step(state, dt) {
    // state = [Œ∏1, œâ1, Œ∏2, œâ2]
    const k1 = derivatives(state);
    const k2 = derivatives(addArrays(state, scaleArray(k1, dt/2)));
    const k3 = derivatives(addArrays(state, scaleArray(k2, dt/2)));
    const k4 = derivatives(addArrays(state, scaleArray(k3, dt)));

    // Weighted average: (k1 + 2k2 + 2k3 + k4) / 6
    for (let i = 0; i < 4; i++) {
        state[i] += dt * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]) / 6;
    }
    return state;
}

// The actual physics - Lagrangian equations of motion
function derivatives([Œ∏1, œâ1, Œ∏2, œâ2]) {
    const g = 9.81;
    const m1 = 1, m2 = 1, L1 = 1, L2 = 1;

    const delta = Œ∏1 - Œ∏2;
    const sinDelta = Math.sin(delta);
    const cosDelta = Math.cos(delta);

    const denom1 = L1 * (2*m1 + m2 - m2*Math.cos(2*delta));
    const denom2 = L2 * (2*m1 + m2 - m2*Math.cos(2*delta));

    // Angular acceleration for pendulum 1
    const Œ±1 = (-g*(2*m1+m2)*Math.sin(Œ∏1)
                - m2*g*Math.sin(Œ∏1 - 2*Œ∏2)
                - 2*sinDelta*m2*(œâ2*œâ2*L2 + œâ1*œâ1*L1*cosDelta)) / denom1;

    // Angular acceleration for pendulum 2
    const Œ±2 = (2*sinDelta*(œâ1*œâ1*L1*(m1+m2)
                + g*(m1+m2)*Math.cos(Œ∏1)
                + œâ2*œâ2*L2*m2*cosDelta)) / denom2;

    return [œâ1, Œ±1, œâ2, Œ±2]; // [dŒ∏1/dt, dœâ1/dt, dŒ∏2/dt, dœâ2/dt]
}</code></pre>
                </div>
                <div class="example-box">
                    <h4>üí° Why RK4 Matters:</h4>
                    <p>Euler: <code>x += v * dt</code> - Simple but accumulates errors exponentially</p>
                    <p>RK4: Samples the derivative 4 times per step, achieving 4th-order accuracy. Energy stays conserved!</p>
                </div>
            </details>

            <details data-demo-id="doublePendulum" data-deps="clearCanvas">
                <summary>üìù Click to see: Full Double Pendulum Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class DoublePendulum {
    constructor(x, y, L1, L2, m1, m2, Œ∏1, Œ∏2) {
        this.origin = { x, y };
        this.L1 = L1;  // Length of first arm
        this.L2 = L2;  // Length of second arm
        this.m1 = m1;  // Mass of first bob
        this.m2 = m2;  // Mass of second bob

        // State: [Œ∏1, œâ1, Œ∏2, œâ2]
        this.state = [Œ∏1, 0, Œ∏2, 0];
        this.g = 9.81;
        this.trail = [];
        this.maxTrail = 500;
    }

    // Get bob positions from angles
    getPositions() {
        const [Œ∏1, , Œ∏2] = this.state;
        const x1 = this.origin.x + this.L1 * Math.sin(Œ∏1);
        const y1 = this.origin.y + this.L1 * Math.cos(Œ∏1);
        const x2 = x1 + this.L2 * Math.sin(Œ∏2);
        const y2 = y1 + this.L2 * Math.cos(Œ∏2);
        return { x1, y1, x2, y2 };
    }

    // Calculate total energy (should stay constant!)
    getEnergy() {
        const [Œ∏1, œâ1, Œ∏2, œâ2] = this.state;
        const { L1, L2, m1, m2, g } = this;

        // Kinetic energy
        const v1sq = L1*L1 * œâ1*œâ1;
        const v2sq = L1*L1*œâ1*œâ1 + L2*L2*œâ2*œâ2
                   + 2*L1*L2*œâ1*œâ2*Math.cos(Œ∏1-Œ∏2);
        const KE = 0.5*m1*v1sq + 0.5*m2*v2sq;

        // Potential energy (relative to origin)
        const y1 = -L1 * Math.cos(Œ∏1);
        const y2 = y1 - L2 * Math.cos(Œ∏2);
        const PE = m1*g*y1 + m2*g*y2;

        return KE + PE;
    }

    update(dt) {
        // Use multiple small RK4 steps for accuracy
        const steps = 10;
        const subDt = dt / steps;
        for (let i = 0; i < steps; i++) {
            this.rk4Step(subDt);
        }

        // Store trail
        const pos = this.getPositions();
        this.trail.push({ x: pos.x2, y: pos.y2 });
        if (this.trail.length > this.maxTrail) {
            this.trail.shift();
        }
    }

    rk4Step(dt) {
        const k1 = this.derivatives(this.state);
        const k2 = this.derivatives(this.addState(this.state, k1, dt/2));
        const k3 = this.derivatives(this.addState(this.state, k2, dt/2));
        const k4 = this.derivatives(this.addState(this.state, k3, dt));

        for (let i = 0; i < 4; i++) {
            this.state[i] += dt * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]) / 6;
        }
    }

    addState(state, deriv, dt) {
        return state.map((s, i) => s + deriv[i] * dt);
    }

    derivatives(state) {
        const [Œ∏1, œâ1, Œ∏2, œâ2] = state;
        const { L1, L2, m1, m2, g } = this;

        const delta = Œ∏1 - Œ∏2;
        const sinD = Math.sin(delta);
        const cosD = Math.cos(delta);
        const sin1 = Math.sin(Œ∏1);
        const sin2 = Math.sin(Œ∏2);

        const M = 2*m1 + m2 - m2*Math.cos(2*delta);

        const Œ±1 = (-g*(2*m1+m2)*sin1 - m2*g*Math.sin(Œ∏1-2*Œ∏2)
                   - 2*sinD*m2*(œâ2*œâ2*L2 + œâ1*œâ1*L1*cosD)) / (L1*M);

        const Œ±2 = (2*sinD*(œâ1*œâ1*L1*(m1+m2) + g*(m1+m2)*Math.cos(Œ∏1)
                   + œâ2*œâ2*L2*m2*cosD)) / (L2*M);

        return [œâ1, Œ±1, œâ2, Œ±2];
    }

    draw(ctx, color = '#4fc3f7') {
        const pos = this.getPositions();

        // Draw trail
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.3;
        for (let i = 0; i < this.trail.length; i++) {
            const p = this.trail[i];
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Draw arms
        ctx.beginPath();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 3;
        ctx.moveTo(this.origin.x, this.origin.y);
        ctx.lineTo(pos.x1, pos.y1);
        ctx.lineTo(pos.x2, pos.y2);
        ctx.stroke();

        // Draw bobs
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pos.x1, pos.y1, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(pos.x2, pos.y2, 12, 0, Math.PI * 2);
        ctx.fill();

        // Draw pivot
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.origin.x, this.origin.y, 5, 0, Math.PI * 2);
        ctx.fill();
    }
}</code></pre>
                </div>
            </details>
        </div>

        <!-- ==================== RIGID BODY PHYSICS ==================== -->
        <div id="rigid-body" class="section">
            <span class="level-indicator level-expert">ROTATION PHYSICS</span>
            <h2>2. Rigid Body Physics with Rotation</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>Most basic physics demos only handle <strong>translation</strong> (moving position). Real objects also <strong>rotate</strong> when hit off-center! This simulation includes:</p>
                <ul>
                    <li><strong>Moment of inertia:</strong> Resistance to rotation (like mass, but for spinning)</li>
                    <li><strong>Torque:</strong> Force that causes rotation (œÑ = r √ó F)</li>
                    <li><strong>Angular momentum:</strong> Conserved during collisions (L = I √ó œâ)</li>
                    <li><strong>SAT collision:</strong> Separating Axis Theorem for accurate polygon collision</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>The Physics: Torque and Angular Momentum</h4>
                <div class="formula">
                    Moment of Inertia (rectangle): I = (m/12) √ó (width¬≤ + height¬≤)
                </div>
                <div class="formula">
                    Torque: œÑ = r √ó F = |r| √ó |F| √ó sin(angle between them)
                </div>
                <div class="formula">
                    Angular acceleration: Œ± = œÑ / I
                </div>
                <p>When a collision happens off-center, it creates torque. The further from center, the more spin!</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Click to spawn boxes. They tumble realistically when they collide!</p>

            <canvas id="rigidCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="rigidSpawnBox">Spawn Box</button>
                <button id="rigidSpawnMany">Spawn 5</button>
                <button id="rigidClear">Clear</button>
                <button id="rigidPause">Pause</button>
            </div>
            <div class="info-display" id="rigidInfo">
                Click canvas to spawn at cursor | Bodies: <span id="rigidCount">0</span>
            </div>

            <details data-demo-id="rigidBody" data-deps="clearCanvas">
                <summary>üìù Click to see: Rigid Body Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class RigidBody {
    constructor(x, y, width, height, mass = 1) {
        this.pos = { x, y };
        this.vel = { x: 0, y: 0 };
        this.width = width;
        this.height = height;
        this.mass = mass;

        // Rotation properties
        this.angle = 0;          // Current angle in radians
        this.angularVel = 0;     // Angular velocity (rad/s)

        // Moment of inertia for a rectangle rotating about center
        this.inertia = (mass / 12) * (width*width + height*height);

        this.restitution = 0.6;  // Bounciness
        this.friction = 0.3;     // Surface friction
    }

    // Get corners in world space (for collision detection)
    getCorners() {
        const cos = Math.cos(this.angle);
        const sin = Math.sin(this.angle);
        const hw = this.width / 2;
        const hh = this.height / 2;

        // Local corners
        const local = [
            { x: -hw, y: -hh },
            { x:  hw, y: -hh },
            { x:  hw, y:  hh },
            { x: -hw, y:  hh }
        ];

        // Rotate and translate to world space
        return local.map(p => ({
            x: this.pos.x + p.x * cos - p.y * sin,
            y: this.pos.y + p.x * sin + p.y * cos
        }));
    }

    // Get axes for SAT (perpendicular to edges)
    getAxes() {
        const corners = this.getCorners();
        const axes = [];
        for (let i = 0; i < corners.length; i++) {
            const p1 = corners[i];
            const p2 = corners[(i + 1) % corners.length];
            // Edge vector
            const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
            // Perpendicular (normal)
            const len = Math.sqrt(edge.x*edge.x + edge.y*edge.y);
            axes.push({ x: -edge.y / len, y: edge.x / len });
        }
        return axes;
    }

    // Apply impulse at a point (causes both translation and rotation)
    applyImpulse(impulse, contactPoint) {
        // Linear impulse: changes velocity
        this.vel.x += impulse.x / this.mass;
        this.vel.y += impulse.y / this.mass;

        // Angular impulse: r √ó J (cross product in 2D)
        const r = {
            x: contactPoint.x - this.pos.x,
            y: contactPoint.y - this.pos.y
        };
        // 2D cross product: r.x * J.y - r.y * J.x
        const torque = r.x * impulse.y - r.y * impulse.x;
        this.angularVel += torque / this.inertia;
    }

    update(dt, gravity = 500) {
        // Apply gravity
        this.vel.y += gravity * dt;

        // Update position
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;

        // Update rotation
        this.angle += this.angularVel * dt;

        // Damping
        this.angularVel *= 0.999;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: SAT Collision Detection</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Separating Axis Theorem - works for ANY convex polygon
function satCollision(bodyA, bodyB) {
    const cornersA = bodyA.getCorners();
    const cornersB = bodyB.getCorners();

    // Check all axes from both shapes
    const axes = [...bodyA.getAxes(), ...bodyB.getAxes()];

    let minOverlap = Infinity;
    let smallestAxis = null;

    for (const axis of axes) {
        // Project both shapes onto this axis
        const projA = projectShape(cornersA, axis);
        const projB = projectShape(cornersB, axis);

        // Check for gap (separating axis found = no collision)
        const overlap = Math.min(projA.max - projB.min, projB.max - projA.min);
        if (overlap < 0) return null; // No collision!

        // Track smallest overlap for collision response
        if (overlap < minOverlap) {
            minOverlap = overlap;
            smallestAxis = axis;
        }
    }

    // Collision detected! Return penetration info
    return {
        normal: smallestAxis,
        depth: minOverlap,
        contactPoint: findContactPoint(cornersA, cornersB, smallestAxis)
    };
}

function projectShape(corners, axis) {
    let min = Infinity, max = -Infinity;
    for (const c of corners) {
        const proj = c.x * axis.x + c.y * axis.y;
        min = Math.min(min, proj);
        max = Math.max(max, proj);
    }
    return { min, max };
}</code></pre>
                </div>
                <div class="example-box">
                    <h4>üí° Why SAT Works:</h4>
                    <p>If you can find ANY axis where the projections don't overlap, the shapes are separated. For rectangles, we only need to check 4 axes (perpendicular to each edge). This works for any convex polygon!</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Impulse-Based Collision Response</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">function resolveCollision(bodyA, bodyB, collision) {
    const { normal, depth, contactPoint } = collision;

    // Separate bodies (push apart based on mass ratio)
    const totalMass = bodyA.mass + bodyB.mass;
    const moveA = depth * (bodyB.mass / totalMass);
    const moveB = depth * (bodyA.mass / totalMass);

    bodyA.pos.x -= normal.x * moveA;
    bodyA.pos.y -= normal.y * moveA;
    bodyB.pos.x += normal.x * moveB;
    bodyB.pos.y += normal.y * moveB;

    // Calculate relative velocity at contact point
    const rA = { x: contactPoint.x - bodyA.pos.x, y: contactPoint.y - bodyA.pos.y };
    const rB = { x: contactPoint.x - bodyB.pos.x, y: contactPoint.y - bodyB.pos.y };

    // Velocity at contact = linear + angular contribution
    const velA = {
        x: bodyA.vel.x - bodyA.angularVel * rA.y,
        y: bodyA.vel.y + bodyA.angularVel * rA.x
    };
    const velB = {
        x: bodyB.vel.x - bodyB.angularVel * rB.y,
        y: bodyB.vel.y + bodyB.angularVel * rB.x
    };

    const relVel = { x: velA.x - velB.x, y: velA.y - velB.y };
    const velAlongNormal = relVel.x * normal.x + relVel.y * normal.y;

    // Don't resolve if moving apart
    if (velAlongNormal > 0) return;

    // Restitution (bounciness)
    const e = Math.min(bodyA.restitution, bodyB.restitution);

    // Impulse magnitude (includes rotational terms!)
    const rAxN = rA.x * normal.y - rA.y * normal.x;
    const rBxN = rB.x * normal.y - rB.y * normal.x;

    const denom = 1/bodyA.mass + 1/bodyB.mass
                + (rAxN * rAxN) / bodyA.inertia
                + (rBxN * rBxN) / bodyB.inertia;

    const j = -(1 + e) * velAlongNormal / denom;

    const impulse = { x: j * normal.x, y: j * normal.y };

    // Apply impulse (causes both translation and rotation!)
    bodyA.applyImpulse(impulse, contactPoint);
    bodyB.applyImpulse({ x: -impulse.x, y: -impulse.y }, contactPoint);
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Key Insight:</strong> The impulse formula includes rotational terms (r √ó n / I). This means hitting a box off-center transfers more energy to rotation than hitting it dead-center!
                </div>
            </details>
        </div>

        <!-- ==================== CLOTH SIMULATION ==================== -->
        <div id="cloth" class="section">
            <span class="level-indicator level-expert">SOFT BODY</span>
            <h2>3. Cloth Simulation (3-Spring Model)</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>Basic Verlet rope simulations only connect adjacent particles. Real cloth needs <strong>three types of springs</strong> to behave correctly:</p>
                <ul>
                    <li><strong>Structural springs:</strong> Connect horizontally/vertically adjacent particles (prevents stretching)</li>
                    <li><strong>Shear springs:</strong> Connect diagonal neighbors (prevents the cloth from collapsing into a line)</li>
                    <li><strong>Bend springs:</strong> Connect every-other particle (prevents unrealistic folding)</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>The Physics: Verlet Integration with Constraints</h4>
                <div class="formula">
                    Position update: x_new = x + (x - x_old) * damping + acceleration * dt¬≤
                </div>
                <div class="formula">
                    Constraint satisfaction: Œîx = (current_length - rest_length) / current_length * 0.5
                </div>
                <p>We run multiple constraint iterations (8-16) per frame for stability. More iterations = stiffer cloth.</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Drag the cloth! Right-click to pin/unpin corners. Pull hard to tear it!</p>

            <canvas id="clothCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="clothReset">Reset</button>
                <button id="clothWind">Toggle Wind</button>
                <button id="clothGravity">Toggle Gravity</button>
                <button id="clothPause">Pause</button>
            </div>
            <div class="info-display" id="clothInfo">
                Drag particles | Right-click to pin/unpin | Pull hard to tear
            </div>

            <details data-demo-id="cloth" data-deps="clearCanvas">
                <summary>üìù Click to see: Cloth Particle System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class ClothParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.oldX = x;  // Verlet needs previous position
        this.oldY = y;
        this.pinned = false;
        this.mass = 1;
    }

    update(gravity, damping, dt) {
        if (this.pinned) return;

        // Verlet integration: x_new = x + (x - x_old) * damping + a * dt¬≤
        const vx = (this.x - this.oldX) * damping;
        const vy = (this.y - this.oldY) * damping;

        this.oldX = this.x;
        this.oldY = this.y;

        this.x += vx;
        this.y += vy + gravity * dt * dt;
    }

    applyForce(fx, fy, dt) {
        if (this.pinned) return;
        // Force ‚Üí acceleration ‚Üí velocity change stored in position difference
        this.x += fx / this.mass * dt * dt;
        this.y += fy / this.mass * dt * dt;
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Three Spring Types</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class ClothSpring {
    constructor(p1, p2, type, tearThreshold = 50) {
        this.p1 = p1;
        this.p2 = p2;
        this.type = type; // 'structural', 'shear', or 'bend'
        this.restLength = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        this.tearThreshold = tearThreshold;
        this.broken = false;

        // Different stiffness for different spring types
        this.stiffness = type === 'structural' ? 1.0
                       : type === 'shear' ? 0.7
                       : 0.3; // bend springs are softer
    }

    satisfy() {
        if (this.broken) return;

        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const currentLength = Math.hypot(dx, dy);

        // Check for tearing
        if (currentLength > this.restLength * this.tearThreshold / 10) {
            this.broken = true;
            return;
        }

        // Calculate correction
        const diff = (currentLength - this.restLength) / currentLength;
        const moveX = dx * diff * 0.5 * this.stiffness;
        const moveY = dy * diff * 0.5 * this.stiffness;

        // Move both particles (unless pinned)
        if (!this.p1.pinned) {
            this.p1.x += moveX;
            this.p1.y += moveY;
        }
        if (!this.p2.pinned) {
            this.p2.x -= moveX;
            this.p2.y -= moveY;
        }
    }
}

// Creating the spring network
function createClothSprings(particles, cols, rows, spacing) {
    const springs = [];

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            const i = y * cols + x;

            // Structural springs (horizontal and vertical)
            if (x < cols - 1) {
                springs.push(new ClothSpring(
                    particles[i], particles[i + 1], 'structural'
                ));
            }
            if (y < rows - 1) {
                springs.push(new ClothSpring(
                    particles[i], particles[i + cols], 'structural'
                ));
            }

            // Shear springs (diagonal)
            if (x < cols - 1 && y < rows - 1) {
                springs.push(new ClothSpring(
                    particles[i], particles[i + cols + 1], 'shear'
                ));
                springs.push(new ClothSpring(
                    particles[i + 1], particles[i + cols], 'shear'
                ));
            }

            // Bend springs (skip one particle)
            if (x < cols - 2) {
                springs.push(new ClothSpring(
                    particles[i], particles[i + 2], 'bend'
                ));
            }
            if (y < rows - 2) {
                springs.push(new ClothSpring(
                    particles[i], particles[i + cols * 2], 'bend'
                ));
            }
        }
    }

    return springs;
}</code></pre>
                </div>
                <div class="example-box">
                    <h4>üí° Why Three Spring Types Matter:</h4>
                    <ul>
                        <li><strong>Without shear springs:</strong> Cloth collapses diagonally into a thin line</li>
                        <li><strong>Without bend springs:</strong> Cloth folds too easily, creating unrealistic sharp creases</li>
                        <li><strong>Stiffness values:</strong> Structural > Shear > Bend mimics real fabric behavior</li>
                    </ul>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Multiple Constraint Iterations</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// The key to stable cloth: multiple constraint passes per frame
function updateCloth(particles, springs, iterations = 12) {
    // 1. Apply forces (gravity, wind)
    for (const p of particles) {
        p.update(gravity, damping, dt);
    }

    // 2. Satisfy constraints multiple times
    // More iterations = stiffer, more stable cloth
    for (let iter = 0; iter < iterations; iter++) {
        for (const spring of springs) {
            spring.satisfy();
        }
    }

    // 3. Boundary constraints
    for (const p of particles) {
        if (p.y > canvasHeight) {
            p.y = canvasHeight;
            p.oldY = p.y + (p.y - p.oldY) * 0.5; // Friction
        }
    }
}

// Why multiple iterations?
// Each satisfy() only moves particles halfway to satisfaction.
// After one pass, fixing spring A might break spring B.
// Multiple passes let the system converge to a valid state.</code></pre>
                </div>
            </details>
        </div>

        <!-- ==================== SPH WATER V2 ==================== -->
        <div id="sph-water" class="section">
            <span class="level-indicator level-expert">FLUID DYNAMICS</span>
            <h2>4. SPH Water v2 (Proper Kernels)</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>Basic SPH implementations use simple linear kernels. Industry-standard SPH uses <strong>specialized kernels</strong> for different physical quantities:</p>
                <ul>
                    <li><strong>Poly6 kernel:</strong> For density estimation (smooth, symmetric)</li>
                    <li><strong>Spiky kernel:</strong> For pressure gradients (prevents particles clumping)</li>
                    <li><strong>Viscosity kernel:</strong> For smooth velocity blending</li>
                </ul>
                <p>We also use <strong>spatial hashing</strong> for O(n) neighbor lookup instead of O(n¬≤).</p>
            </div>

            <div class="concept-box">
                <h4>The Physics: SPH Kernels</h4>
                <div class="formula">
                    Poly6 (density): W(r,h) = (315 / 64œÄh‚Åπ) √ó (h¬≤ - r¬≤)¬≥
                </div>
                <div class="formula">
                    Spiky (pressure): ‚àáW(r,h) = -(45 / œÄh‚Å∂) √ó (h - r)¬≤ √ó (rÃÇ)
                </div>
                <p>Each particle's density is the sum of neighboring masses weighted by the kernel. Pressure pushes particles apart!</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Click to add water! Watch the particles flow with proper fluid behavior.</p>

            <canvas id="sphCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="sphPour">Pour Water</button>
                <button id="sphReset">Reset</button>
                <button id="sphPause">Pause</button>
                <button id="sphViscosity">Toggle Viscosity</button>
            </div>
            <div class="info-display" id="sphInfo">
                Click to add particles | Particles: <span id="sphCount">0</span>
            </div>

            <details>
                <summary>üìù Click to see: SPH Kernels</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Smoothing kernels - the heart of accurate SPH
class SPHKernels {
    constructor(h) {
        this.h = h;  // Smoothing radius
        this.h2 = h * h;
        this.h6 = Math.pow(h, 6);
        this.h9 = Math.pow(h, 9);

        // Pre-computed constants
        this.poly6Const = 315 / (64 * Math.PI * this.h9);
        this.spikyConst = -45 / (Math.PI * this.h6);
        this.viscConst = 45 / (Math.PI * this.h6);
    }

    // Poly6 kernel - used for DENSITY calculation
    // Smooth and symmetric, great for summing contributions
    poly6(r2) {
        if (r2 >= this.h2) return 0;
        const diff = this.h2 - r2;
        return this.poly6Const * diff * diff * diff;
    }

    // Spiky kernel gradient - used for PRESSURE forces
    // Has a sharp peak that prevents particles from clumping
    spikyGrad(r, dx, dy) {
        if (r >= this.h || r < 0.0001) return { x: 0, y: 0 };
        const diff = this.h - r;
        const scale = this.spikyConst * diff * diff / r;
        return { x: scale * dx, y: scale * dy };
    }

    // Viscosity kernel Laplacian - used for VISCOSITY
    // Smooths velocity differences between neighbors
    viscLaplacian(r) {
        if (r >= this.h) return 0;
        return this.viscConst * (this.h - r);
    }
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Why Different Kernels?</strong>
                    <ul>
                        <li><strong>Poly6:</strong> Smooth falloff prevents density discontinuities</li>
                        <li><strong>Spiky:</strong> Sharp gradient at r=0 creates strong repulsion when particles get too close</li>
                        <li><strong>Viscosity:</strong> Laplacian form ensures velocity smoothing is physically correct</li>
                    </ul>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Spatial Hashing for O(n) Neighbor Lookup</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Spatial hash grid - turns O(n¬≤) into O(n) neighbor search!
class SpatialHash {
    constructor(cellSize) {
        this.cellSize = cellSize;
        this.grid = new Map();
    }

    // Hash function: convert (x,y) position to cell key
    hash(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        return `${cx},${cy}`;
    }

    clear() {
        this.grid.clear();
    }

    insert(particle) {
        const key = this.hash(particle.x, particle.y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(particle);
    }

    // Get all particles in neighboring cells
    getNeighbors(particle) {
        const neighbors = [];
        const cx = Math.floor(particle.x / this.cellSize);
        const cy = Math.floor(particle.y / this.cellSize);

        // Check 3x3 grid of cells around particle
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${cx + dx},${cy + dy}`;
                const cell = this.grid.get(key);
                if (cell) {
                    neighbors.push(...cell);
                }
            }
        }
        return neighbors;
    }
}

// Usage in SPH simulation:
function updateDensities(particles, spatialHash, kernels) {
    spatialHash.clear();
    for (const p of particles) {
        spatialHash.insert(p);
    }

    for (const p of particles) {
        p.density = 0;
        const neighbors = spatialHash.getNeighbors(p);

        for (const n of neighbors) {
            const dx = p.x - n.x;
            const dy = p.y - n.y;
            const r2 = dx*dx + dy*dy;

            // Only check particles within smoothing radius
            p.density += n.mass * kernels.poly6(r2);
        }

        // Calculate pressure from density
        p.pressure = GAS_CONSTANT * (p.density - REST_DENSITY);
    }
}</code></pre>
                </div>
                <div class="example-box">
                    <h4>üí° Performance Impact:</h4>
                    <p><strong>Without spatial hashing:</strong> 1000 particles = 1,000,000 distance checks per frame</p>
                    <p><strong>With spatial hashing:</strong> 1000 particles ‚âà 20,000 distance checks (50x faster!)</p>
                </div>
            </details>

            <details data-demo-id="sphWaterV2" data-deps="clearCanvas">
                <summary>üìù Click to see: Full SPH Particle Class</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class SPHParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.fx = 0;  // Force accumulator
        this.fy = 0;
        this.density = 0;
        this.pressure = 0;
        this.mass = 1;
    }

    applyForces(neighbors, kernels, viscosity) {
        this.fx = 0;
        this.fy = 0;

        for (const n of neighbors) {
            if (n === this) continue;

            const dx = n.x - this.x;
            const dy = n.y - this.y;
            const r = Math.sqrt(dx*dx + dy*dy);

            if (r < kernels.h && r > 0.0001) {
                // Pressure force (pushes particles apart)
                const pressureForce = -(this.pressure + n.pressure) /
                                      (2 * n.density);
                const grad = kernels.spikyGrad(r, dx, dy);
                this.fx += pressureForce * grad.x * n.mass;
                this.fy += pressureForce * grad.y * n.mass;

                // Viscosity force (smooths velocity)
                const viscForce = viscosity * kernels.viscLaplacian(r) /
                                  n.density;
                this.fx += viscForce * (n.vx - this.vx) * n.mass;
                this.fy += viscForce * (n.vy - this.vy) * n.mass;
            }
        }
    }

    integrate(dt, gravity) {
        // Apply gravity
        this.fy += gravity * this.density;

        // Update velocity
        this.vx += this.fx / this.density * dt;
        this.vy += this.fy / this.density * dt;

        // Update position
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }
}</code></pre>
                </div>
            </details>
        </div>

        <!-- ==================== PERLIN WIND FIELD ==================== -->
        <div id="perlin-wind" class="section">
            <span class="level-indicator level-expert">WIND PHYSICS</span>
            <h2>5. Perlin Noise Wind Field</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>Basic wind implementations use <code>sin(x) * cos(y)</code> which creates obviously repeating patterns. Real wind uses <strong>Perlin noise</strong> for organic, non-repeating flow, plus <strong>curl noise</strong> for physically accurate (divergence-free) fluid motion.</p>
                <ul>
                    <li><strong>Perlin noise:</strong> Smooth, continuous random values</li>
                    <li><strong>Curl noise:</strong> Takes gradient perpendicular to Perlin field (creates swirls, not compression)</li>
                    <li><strong>Multiple octaves:</strong> Large-scale flow + small-scale turbulence</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>The Physics: Curl Noise</h4>
                <p>Regular Perlin noise can create unrealistic convergence points. <strong>Curl noise</strong> uses the perpendicular gradient:</p>
                <div class="formula">
                    wind.x = ‚àÇPerlin/‚àÇy (partial derivative in y)
                </div>
                <div class="formula">
                    wind.y = -‚àÇPerlin/‚àÇx (negative partial derivative in x)
                </div>
                <p>This creates <strong>divergence-free flow</strong> - particles swirl but never converge to a point!</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Watch particles flow through the wind field. Adjust turbulence and time scale!</p>

            <canvas id="windCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="windReset">Reset</button>
                <button id="windPause">Pause</button>
                <button id="windShowField">Show Vector Field</button>
                <button id="windOctaves">Toggle Octaves</button>
            </div>
            <div class="info-display" id="windInfo">
                Turbulence: <input type="range" id="windTurbulence" min="1" max="10" value="3" style="width: 100px; vertical-align: middle;">
                | Time Scale: <input type="range" id="windTimeScale" min="1" max="20" value="5" style="width: 100px; vertical-align: middle;">
            </div>

            <details data-demo-id="perlinWind" data-deps="clearCanvas">
                <summary>üìù Click to see: Perlin Noise Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Classic Perlin noise implementation
class PerlinNoise {
    constructor() {
        // Permutation table for pseudo-random gradients
        this.perm = new Array(512);
        const p = [];
        for (let i = 0; i < 256; i++) p[i] = i;

        // Shuffle
        for (let i = 255; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [p[i], p[j]] = [p[j], p[i]];
        }

        // Duplicate for overflow
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
        }
    }

    // Fade function: 6t‚Åµ - 15t‚Å¥ + 10t¬≥ (smoother than linear)
    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    // Linear interpolation
    lerp(a, b, t) {
        return a + t * (b - a);
    }

    // Gradient function
    grad(hash, x, y, z) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }

    // 3D Perlin noise (x, y, time)
    noise(x, y, z = 0) {
        // Find unit cube containing point
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;

        // Find relative position in cube
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);

        // Compute fade curves
        const u = this.fade(x);
        const v = this.fade(y);
        const w = this.fade(z);

        // Hash coordinates of cube corners
        const A = this.perm[X] + Y;
        const AA = this.perm[A] + Z;
        const AB = this.perm[A + 1] + Z;
        const B = this.perm[X + 1] + Y;
        const BA = this.perm[B] + Z;
        const BB = this.perm[B + 1] + Z;

        // Blend results from 8 corners
        return this.lerp(
            this.lerp(
                this.lerp(
                    this.grad(this.perm[AA], x, y, z),
                    this.grad(this.perm[BA], x - 1, y, z), u),
                this.lerp(
                    this.grad(this.perm[AB], x, y - 1, z),
                    this.grad(this.perm[BB], x - 1, y - 1, z), u), v),
            this.lerp(
                this.lerp(
                    this.grad(this.perm[AA + 1], x, y, z - 1),
                    this.grad(this.perm[BA + 1], x - 1, y, z - 1), u),
                this.lerp(
                    this.grad(this.perm[AB + 1], x, y - 1, z - 1),
                    this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1), u), v), w);
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Curl Noise for Divergence-Free Flow</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Curl noise - creates swirling, divergence-free flow
function getCurlNoise(perlin, x, y, t, scale = 0.01, eps = 0.0001) {
    // Sample Perlin noise at 4 points around (x, y)
    const n = perlin.noise(x * scale, (y - eps) * scale, t);  // Above
    const s = perlin.noise(x * scale, (y + eps) * scale, t);  // Below
    const e = perlin.noise((x + eps) * scale, y * scale, t);  // Right
    const w = perlin.noise((x - eps) * scale, y * scale, t);  // Left

    // Compute partial derivatives (central difference)
    const dNoise_dy = (n - s) / (2 * eps);
    const dNoise_dx = (e - w) / (2 * eps);

    // Curl: perpendicular to gradient
    return {
        x: dNoise_dy,   // Wind X = d/dy
        y: -dNoise_dx   // Wind Y = -d/dx
    };
}

// Multiple octaves for detail at different scales
function getWindWithOctaves(perlin, x, y, t, octaves = 4) {
    let wind = { x: 0, y: 0 };
    let amplitude = 1;
    let frequency = 1;
    let maxAmp = 0;

    for (let i = 0; i < octaves; i++) {
        const curl = getCurlNoise(
            perlin,
            x * frequency,
            y * frequency,
            t * frequency,
            0.01
        );

        wind.x += curl.x * amplitude;
        wind.y += curl.y * amplitude;
        maxAmp += amplitude;

        // Each octave: higher frequency, lower amplitude
        amplitude *= 0.5;   // Persistence
        frequency *= 2.0;   // Lacunarity
    }

    // Normalize
    wind.x /= maxAmp;
    wind.y /= maxAmp;

    return wind;
}</code></pre>
                </div>
                <div class="key-point">
                    <strong>üí° Why Curl Noise?</strong>
                    <p>Regular Perlin noise can create "sinks" and "sources" where particles bunch up or spread out. Curl noise is <strong>divergence-free</strong>: ‚àá¬∑wind = 0. This means particles will swirl beautifully but never converge to a point!</p>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Wind Particle System</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class WindParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.life = 200 + Math.random() * 200;
        this.maxLife = this.life;
        this.history = [];
        this.maxHistory = 20;
    }

    update(wind, strength) {
        // Store position history for trail
        this.history.push({ x: this.x, y: this.y });
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }

        // Move with wind
        this.x += wind.x * strength;
        this.y += wind.y * strength;

        this.life--;

        // Wrap around edges
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
    }

    draw(ctx) {
        const alpha = this.life / this.maxLife;

        // Draw trail
        if (this.history.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.history[0].x, this.history[0].y);
            for (let i = 1; i < this.history.length; i++) {
                ctx.lineTo(this.history[i].x, this.history[i].y);
            }
            ctx.lineTo(this.x, this.y);
            ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.5})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw head
        ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}</code></pre>
                </div>
            </details>
        </div>

        <!-- ==================== HEAT DIFFUSION ==================== -->
        <div id="heat-diffusion" class="section">
            <span class="level-indicator level-expert">THERMAL</span>
            <h2>6. Heat Diffusion</h2>

            <div class="concept-box">
                <h4>Why This is More Accurate</h4>
                <p>Basic fire simulations use probability (random spread chance). Real heat transfer follows the <strong>heat equation</strong>:</p>
                <ul>
                    <li><strong>Conduction:</strong> Heat flows from hot to cold regions (‚àá¬≤T)</li>
                    <li><strong>Convection:</strong> Hot air rises, carrying heat upward</li>
                    <li><strong>Radiation:</strong> Hot objects cool by emitting energy</li>
                    <li><strong>Material properties:</strong> Metal conducts fast, wood slow</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>The Physics: Heat Equation</h4>
                <div class="formula">
                    ‚àÇT/‚àÇt = Œ±‚àá¬≤T + sources - sinks
                </div>
                <p>Where Œ± = thermal diffusivity = k/(œÅ¬∑c)</p>
                <ul>
                    <li><strong>k</strong> = thermal conductivity (how fast heat spreads)</li>
                    <li><strong>œÅ</strong> = density</li>
                    <li><strong>c</strong> = specific heat capacity (energy to raise temperature)</li>
                </ul>
                <p>The Laplacian ‚àá¬≤T measures how different a cell is from its neighbors!</p>
            </div>

            <h3>Interactive Demo</h3>
            <p>Click to add heat sources. Watch heat spread through different materials!</p>

            <canvas id="heatCanvas" width="800" height="500"></canvas>
            <div class="controls">
                <button id="heatReset">Reset</button>
                <button id="heatPause">Pause</button>
                <button id="heatMaterial">Toggle Material: <span id="heatMaterialName">Air</span></button>
                <button id="heatConvection">Toggle Convection</button>
            </div>
            <div class="info-display" id="heatInfo">
                Click to add heat | Materials: Air (fast), Metal (medium), Wood (slow) | Max temp: <span id="heatMaxTemp">0</span>¬∞C
            </div>

            <details data-demo-id="heatDiffusion" data-deps="clearCanvas">
                <summary>üìù Click to see: Heat Diffusion Implementation</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">class HeatGrid {
    constructor(width, height, cellSize) {
        this.cols = Math.floor(width / cellSize);
        this.rows = Math.floor(height / cellSize);
        this.cellSize = cellSize;

        // Temperature grid
        this.temp = this.createGrid(20);  // Ambient temp
        this.tempNew = this.createGrid(20);

        // Material properties per cell
        this.material = this.createGrid(0);  // 0=air, 1=metal, 2=wood

        // Material properties
        this.materials = {
            air:   { diffusivity: 0.5, emissivity: 0.1 },
            metal: { diffusivity: 0.9, emissivity: 0.02 },
            wood:  { diffusivity: 0.1, emissivity: 0.3 }
        };

        this.ambientTemp = 20;
        this.convectionStrength = 0.3;
        this.useConvection = true;
    }

    createGrid(defaultValue) {
        const grid = [];
        for (let y = 0; y < this.rows; y++) {
            grid[y] = new Array(this.cols).fill(defaultValue);
        }
        return grid;
    }

    getMaterial(type) {
        return type === 0 ? this.materials.air
             : type === 1 ? this.materials.metal
             : this.materials.wood;
    }

    update(dt) {
        // Solve heat equation: dT/dt = Œ± * ‚àá¬≤T
        for (let y = 1; y < this.rows - 1; y++) {
            for (let x = 1; x < this.cols - 1; x++) {
                const mat = this.getMaterial(this.material[y][x]);
                const alpha = mat.diffusivity;

                // Laplacian (how different is this cell from neighbors?)
                const laplacian =
                    this.temp[y-1][x] + this.temp[y+1][x] +
                    this.temp[y][x-1] + this.temp[y][x+1] -
                    4 * this.temp[y][x];

                // Heat diffusion
                let newTemp = this.temp[y][x] + alpha * laplacian * dt;

                // Convection (hot air rises)
                if (this.useConvection && this.material[y][x] === 0) {
                    const heatAbove = y > 0 ? this.temp[y-1][x] : this.temp[y][x];
                    const heatBelow = y < this.rows - 1 ? this.temp[y+1][x] : this.temp[y][x];

                    // Hot air rises: transfer heat upward
                    if (this.temp[y][x] > heatAbove) {
                        const rise = (this.temp[y][x] - heatAbove) * this.convectionStrength * dt;
                        newTemp -= rise;
                    }
                    // Pull heat from below
                    if (heatBelow > this.temp[y][x]) {
                        const pull = (heatBelow - this.temp[y][x]) * this.convectionStrength * dt * 0.5;
                        newTemp += pull;
                    }
                }

                // Radiation cooling (faster for high temps)
                const excess = newTemp - this.ambientTemp;
                if (excess > 0) {
                    newTemp -= excess * mat.emissivity * dt * 0.1;
                }

                // Clamp to valid range
                this.tempNew[y][x] = Math.max(this.ambientTemp, Math.min(1000, newTemp));
            }
        }

        // Swap buffers
        [this.temp, this.tempNew] = [this.tempNew, this.temp];
    }

    addHeat(x, y, amount, radius = 2) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);

        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist <= radius) {
                        this.temp[ny][nx] += amount * (1 - dist/radius);
                    }
                }
            }
        }
    }
}</code></pre>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Heat Visualization</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Color mapping: blue (cold) ‚Üí white ‚Üí yellow ‚Üí red (hot)
function tempToColor(temp, ambient = 20, maxTemp = 500) {
    const normalized = Math.max(0, (temp - ambient) / (maxTemp - ambient));

    if (normalized < 0.25) {
        // Cold: blue to white
        const t = normalized / 0.25;
        return `rgb(${Math.floor(100 + 155*t)}, ${Math.floor(100 + 155*t)}, 255)`;
    } else if (normalized < 0.5) {
        // Warm: white to yellow
        const t = (normalized - 0.25) / 0.25;
        return `rgb(255, 255, ${Math.floor(255 - 255*t)})`;
    } else if (normalized < 0.75) {
        // Hot: yellow to orange
        const t = (normalized - 0.5) / 0.25;
        return `rgb(255, ${Math.floor(255 - 100*t)}, 0)`;
    } else {
        // Very hot: orange to red
        const t = (normalized - 0.75) / 0.25;
        return `rgb(255, ${Math.floor(155 - 155*t)}, 0)`;
    }
}

function drawHeatGrid(ctx, heatGrid) {
    for (let y = 0; y < heatGrid.rows; y++) {
        for (let x = 0; x < heatGrid.cols; x++) {
            const temp = heatGrid.temp[y][x];
            const mat = heatGrid.material[y][x];

            // Base color from temperature
            ctx.fillStyle = tempToColor(temp);

            // Darken for solid materials
            if (mat === 1) { // Metal
                ctx.globalAlpha = 0.8;
            } else if (mat === 2) { // Wood
                ctx.globalAlpha = 0.6;
            } else {
                ctx.globalAlpha = temp > 25 ? 0.8 : 0.3;
            }

            ctx.fillRect(
                x * heatGrid.cellSize,
                y * heatGrid.cellSize,
                heatGrid.cellSize,
                heatGrid.cellSize
            );
        }
    }
    ctx.globalAlpha = 1;
}</code></pre>
                </div>
                <div class="example-box">
                    <h4>üí° Material Properties:</h4>
                    <ul>
                        <li><strong>Air:</strong> High diffusivity (heat spreads fast), low emissivity (cools slowly)</li>
                        <li><strong>Metal:</strong> Very high diffusivity (conducts heat quickly), low emissivity</li>
                        <li><strong>Wood:</strong> Low diffusivity (insulates), high emissivity (radiates heat away)</li>
                    </ul>
                </div>
            </details>

            <details>
                <summary>üìù Click to see: Combustion (Fire Spread)</summary>
                <div class="code-container">
                    <pre><code class="language-javascript">// Extended heat grid with combustion
class CombustibleHeatGrid extends HeatGrid {
    constructor(width, height, cellSize) {
        super(width, height, cellSize);

        // Fuel amount per cell
        this.fuel = this.createGrid(0);

        // Combustion parameters
        this.ignitionTemp = 200;   // Temperature to start burning
        this.burnRate = 0.5;       // How fast fuel burns
        this.heatPerFuel = 100;    // Heat released per unit fuel
    }

    setFuel(x, y, amount, radius = 5) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);

        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = cx + dx;
                const ny = cy + dy;
                if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
                    if (Math.sqrt(dx*dx + dy*dy) <= radius) {
                        this.fuel[ny][nx] = amount;
                        this.material[ny][nx] = 2; // Wood
                    }
                }
            }
        }
    }

    update(dt) {
        // First: handle combustion
        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                if (this.fuel[y][x] > 0 && this.temp[y][x] >= this.ignitionTemp) {
                    // Burning! Consume fuel and release heat
                    const burnAmount = Math.min(this.fuel[y][x], this.burnRate * dt);
                    this.fuel[y][x] -= burnAmount;
                    this.temp[y][x] += burnAmount * this.heatPerFuel;

                    // Fuel depleted: turn back to air
                    if (this.fuel[y][x] <= 0) {
                        this.material[y][x] = 0;
                    }
                }
            }
        }

        // Then: normal heat diffusion
        super.update(dt);
    }
}</code></pre>
                </div>
            </details>
        </div>

    </div>

    <!-- Scroll to Top -->
    <div class="scroll-to-top" id="scrollToTop">‚Üë</div>

    <script>
    // =====================================================
    // DOUBLE PENDULUM SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('pendulumCanvas');
        const ctx = canvas.getContext('2d');
        const energySpan = document.getElementById('pendulumEnergy');

        let paused = false;
        let compareMode = false;
        let pendulum1, pendulum2;
        let dragging = null;

        class DoublePendulum {
            constructor(x, y, L1, L2, m1, m2, Œ∏1, Œ∏2) {
                this.origin = { x, y };
                this.L1 = L1;
                this.L2 = L2;
                this.m1 = m1;
                this.m2 = m2;
                this.state = [Œ∏1, 0, Œ∏2, 0];
                this.g = 9.81;
                this.trail = [];
                this.maxTrail = 500;
            }

            getPositions() {
                const [Œ∏1, , Œ∏2] = this.state;
                const x1 = this.origin.x + this.L1 * Math.sin(Œ∏1);
                const y1 = this.origin.y + this.L1 * Math.cos(Œ∏1);
                const x2 = x1 + this.L2 * Math.sin(Œ∏2);
                const y2 = y1 + this.L2 * Math.cos(Œ∏2);
                return { x1, y1, x2, y2 };
            }

            getEnergy() {
                const [Œ∏1, œâ1, Œ∏2, œâ2] = this.state;
                const { L1, L2, m1, m2, g } = this;
                const v1sq = L1*L1 * œâ1*œâ1;
                const v2sq = L1*L1*œâ1*œâ1 + L2*L2*œâ2*œâ2 + 2*L1*L2*œâ1*œâ2*Math.cos(Œ∏1-Œ∏2);
                const KE = 0.5*m1*v1sq + 0.5*m2*v2sq;
                const y1 = -L1 * Math.cos(Œ∏1);
                const y2 = y1 - L2 * Math.cos(Œ∏2);
                const PE = m1*g*y1 + m2*g*y2;
                return KE + PE;
            }

            update(dt) {
                const steps = 10;
                const subDt = dt / steps;
                for (let i = 0; i < steps; i++) {
                    this.rk4Step(subDt);
                }
                const pos = this.getPositions();
                this.trail.push({ x: pos.x2, y: pos.y2 });
                if (this.trail.length > this.maxTrail) this.trail.shift();
            }

            rk4Step(dt) {
                const k1 = this.derivatives(this.state);
                const k2 = this.derivatives(this.addState(this.state, k1, dt/2));
                const k3 = this.derivatives(this.addState(this.state, k2, dt/2));
                const k4 = this.derivatives(this.addState(this.state, k3, dt));
                for (let i = 0; i < 4; i++) {
                    this.state[i] += dt * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]) / 6;
                }
            }

            addState(state, deriv, dt) {
                return state.map((s, i) => s + deriv[i] * dt);
            }

            derivatives(state) {
                const [Œ∏1, œâ1, Œ∏2, œâ2] = state;
                const { L1, L2, m1, m2, g } = this;
                const delta = Œ∏1 - Œ∏2;
                const sinD = Math.sin(delta);
                const cosD = Math.cos(delta);
                const M = 2*m1 + m2 - m2*Math.cos(2*delta);
                const Œ±1 = (-g*(2*m1+m2)*Math.sin(Œ∏1) - m2*g*Math.sin(Œ∏1-2*Œ∏2)
                           - 2*sinD*m2*(œâ2*œâ2*L2 + œâ1*œâ1*L1*cosD)) / (L1*M);
                const Œ±2 = (2*sinD*(œâ1*œâ1*L1*(m1+m2) + g*(m1+m2)*Math.cos(Œ∏1)
                           + œâ2*œâ2*L2*m2*cosD)) / (L2*M);
                return [œâ1, Œ±1, œâ2, Œ±2];
            }

            draw(ctx, color = '#4fc3f7') {
                const pos = this.getPositions();

                // Trail
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.4;
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Arms
                ctx.beginPath();
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 3;
                ctx.moveTo(this.origin.x, this.origin.y);
                ctx.lineTo(pos.x1, pos.y1);
                ctx.lineTo(pos.x2, pos.y2);
                ctx.stroke();

                // Bobs
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pos.x1, pos.y1, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(pos.x2, pos.y2, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Pivot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.origin.x, this.origin.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            clearTrail() {
                this.trail = [];
            }
        }

        function init() {
            const scale = 100;
            pendulum1 = new DoublePendulum(canvas.width/2, 100, scale, scale, 1, 1, Math.PI/2, Math.PI/2);
            if (compareMode) {
                pendulum2 = new DoublePendulum(canvas.width/2, 100, scale, scale, 1, 1, Math.PI/2 + 0.001, Math.PI/2);
            } else {
                pendulum2 = null;
            }
        }

        function update() {
            if (!paused) {
                pendulum1.update(0.02);
                if (pendulum2) pendulum2.update(0.02);
            }
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#1a1f3a';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            if (pendulum2) pendulum2.draw(ctx, '#ff6b6b');
            pendulum1.draw(ctx, '#4fc3f7');

            // Energy display
            const energy = pendulum1.getEnergy() * 100;
            energySpan.textContent = energy.toFixed(1);

            // Compare mode label
            if (compareMode) {
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '14px Arial';
                ctx.fillText('Blue: Original', 20, 30);
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText('Red: +0.001 rad difference', 20, 50);
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const pos = pendulum1.getPositions();
            const d1 = Math.hypot(mx - pos.x1, my - pos.y1);
            const d2 = Math.hypot(mx - pos.x2, my - pos.y2);

            if (d1 < 20) dragging = { pendulum: pendulum1, bob: 1 };
            else if (d2 < 20) dragging = { pendulum: pendulum1, bob: 2 };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            const p = dragging.pendulum;
            if (dragging.bob === 1) {
                const dx = mx - p.origin.x;
                const dy = my - p.origin.y;
                p.state[0] = Math.atan2(dx, dy);
                p.state[1] = 0;
            } else {
                const pos = p.getPositions();
                const dx = mx - pos.x1;
                const dy = my - pos.y1;
                p.state[2] = Math.atan2(dx, dy);
                p.state[3] = 0;
            }
            p.clearTrail();
            if (pendulum2 && compareMode) {
                pendulum2.state = [...p.state];
                pendulum2.state[0] += 0.001;
                pendulum2.clearTrail();
            }
        });

        canvas.addEventListener('mouseup', () => { dragging = null; });
        canvas.addEventListener('mouseleave', () => { dragging = null; });

        // Buttons
        document.getElementById('pendulumReset').addEventListener('click', init);
        document.getElementById('pendulumPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('pendulumCompare').addEventListener('click', function() {
            compareMode = !compareMode;
            this.classList.toggle('active', compareMode);
            init();
        });
        document.getElementById('pendulumClearTrail').addEventListener('click', () => {
            pendulum1.clearTrail();
            if (pendulum2) pendulum2.clearTrail();
        });

        init();
        animate();
    })();

    // =====================================================
    // RIGID BODY PHYSICS SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('rigidCanvas');
        const ctx = canvas.getContext('2d');
        const countSpan = document.getElementById('rigidCount');

        let paused = false;
        let bodies = [];
        const gravity = 500;

        class RigidBody {
            constructor(x, y, width, height, mass = 1) {
                this.pos = { x, y };
                this.vel = { x: (Math.random() - 0.5) * 200, y: 0 };
                this.width = width;
                this.height = height;
                this.mass = mass;
                this.angle = Math.random() * Math.PI * 2;
                this.angularVel = (Math.random() - 0.5) * 5;
                this.inertia = (mass / 12) * (width*width + height*height);
                this.restitution = 0.5;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }

            getCorners() {
                const cos = Math.cos(this.angle);
                const sin = Math.sin(this.angle);
                const hw = this.width / 2;
                const hh = this.height / 2;
                const local = [
                    { x: -hw, y: -hh },
                    { x:  hw, y: -hh },
                    { x:  hw, y:  hh },
                    { x: -hw, y:  hh }
                ];
                return local.map(p => ({
                    x: this.pos.x + p.x * cos - p.y * sin,
                    y: this.pos.y + p.x * sin + p.y * cos
                }));
            }

            getAxes() {
                const corners = this.getCorners();
                const axes = [];
                for (let i = 0; i < 2; i++) {
                    const p1 = corners[i];
                    const p2 = corners[(i + 1) % corners.length];
                    const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const len = Math.sqrt(edge.x*edge.x + edge.y*edge.y);
                    axes.push({ x: -edge.y / len, y: edge.x / len });
                }
                return axes;
            }

            applyImpulse(impulse, contactPoint) {
                this.vel.x += impulse.x / this.mass;
                this.vel.y += impulse.y / this.mass;
                const r = { x: contactPoint.x - this.pos.x, y: contactPoint.y - this.pos.y };
                const torque = r.x * impulse.y - r.y * impulse.x;
                this.angularVel += torque / this.inertia;
            }

            update(dt) {
                this.vel.y += gravity * dt;
                this.pos.x += this.vel.x * dt;
                this.pos.y += this.vel.y * dt;
                this.angle += this.angularVel * dt;
                this.angularVel *= 0.999;

                // Wall collisions
                const corners = this.getCorners();
                for (const c of corners) {
                    if (c.y > canvas.height - 10) {
                        this.pos.y -= c.y - (canvas.height - 10);
                        const r = { x: c.x - this.pos.x, y: c.y - this.pos.y };
                        const velAtPoint = {
                            x: this.vel.x - this.angularVel * r.y,
                            y: this.vel.y + this.angularVel * r.x
                        };
                        if (velAtPoint.y > 0) {
                            const j = -(1 + this.restitution) * velAtPoint.y /
                                     (1/this.mass + (r.x*r.x)/this.inertia);
                            this.applyImpulse({ x: -velAtPoint.x * 0.3, y: j }, c);
                        }
                    }
                    if (c.x < 10) {
                        this.pos.x += 10 - c.x;
                        this.vel.x = Math.abs(this.vel.x) * this.restitution;
                    }
                    if (c.x > canvas.width - 10) {
                        this.pos.x -= c.x - (canvas.width - 10);
                        this.vel.x = -Math.abs(this.vel.x) * this.restitution;
                    }
                }
            }

            draw(ctx) {
                const corners = this.getCorners();
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                for (let i = 1; i < corners.length; i++) {
                    ctx.lineTo(corners[i].x, corners[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function projectShape(corners, axis) {
            let min = Infinity, max = -Infinity;
            for (const c of corners) {
                const proj = c.x * axis.x + c.y * axis.y;
                min = Math.min(min, proj);
                max = Math.max(max, proj);
            }
            return { min, max };
        }

        function satCollision(bodyA, bodyB) {
            const cornersA = bodyA.getCorners();
            const cornersB = bodyB.getCorners();
            const axes = [...bodyA.getAxes(), ...bodyB.getAxes()];

            let minOverlap = Infinity;
            let smallestAxis = null;

            for (const axis of axes) {
                const projA = projectShape(cornersA, axis);
                const projB = projectShape(cornersB, axis);
                const overlap = Math.min(projA.max - projB.min, projB.max - projA.min);
                if (overlap < 0) return null;
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    smallestAxis = axis;
                }
            }

            // Ensure normal points from A to B
            const d = { x: bodyB.pos.x - bodyA.pos.x, y: bodyB.pos.y - bodyA.pos.y };
            if (d.x * smallestAxis.x + d.y * smallestAxis.y < 0) {
                smallestAxis = { x: -smallestAxis.x, y: -smallestAxis.y };
            }

            // Find contact point (simplified: use closest points)
            let contactPoint = { x: (bodyA.pos.x + bodyB.pos.x) / 2, y: (bodyA.pos.y + bodyB.pos.y) / 2 };

            return { normal: smallestAxis, depth: minOverlap, contactPoint };
        }

        function resolveCollision(bodyA, bodyB, collision) {
            const { normal, depth, contactPoint } = collision;

            const totalMass = bodyA.mass + bodyB.mass;
            bodyA.pos.x -= normal.x * depth * (bodyB.mass / totalMass);
            bodyA.pos.y -= normal.y * depth * (bodyB.mass / totalMass);
            bodyB.pos.x += normal.x * depth * (bodyA.mass / totalMass);
            bodyB.pos.y += normal.y * depth * (bodyA.mass / totalMass);

            const rA = { x: contactPoint.x - bodyA.pos.x, y: contactPoint.y - bodyA.pos.y };
            const rB = { x: contactPoint.x - bodyB.pos.x, y: contactPoint.y - bodyB.pos.y };

            const velA = {
                x: bodyA.vel.x - bodyA.angularVel * rA.y,
                y: bodyA.vel.y + bodyA.angularVel * rA.x
            };
            const velB = {
                x: bodyB.vel.x - bodyB.angularVel * rB.y,
                y: bodyB.vel.y + bodyB.angularVel * rB.x
            };

            const relVel = { x: velA.x - velB.x, y: velA.y - velB.y };
            const velAlongNormal = relVel.x * normal.x + relVel.y * normal.y;

            if (velAlongNormal > 0) return;

            const e = Math.min(bodyA.restitution, bodyB.restitution);
            const rAxN = rA.x * normal.y - rA.y * normal.x;
            const rBxN = rB.x * normal.y - rB.y * normal.x;

            const denom = 1/bodyA.mass + 1/bodyB.mass + (rAxN*rAxN)/bodyA.inertia + (rBxN*rBxN)/bodyB.inertia;
            const j = -(1 + e) * velAlongNormal / denom;

            const impulse = { x: j * normal.x, y: j * normal.y };
            bodyA.applyImpulse(impulse, contactPoint);
            bodyB.applyImpulse({ x: -impulse.x, y: -impulse.y }, contactPoint);
        }

        function spawnBox(x, y) {
            const w = 30 + Math.random() * 40;
            const h = 30 + Math.random() * 40;
            bodies.push(new RigidBody(x, y, w, h, w * h * 0.001));
            countSpan.textContent = bodies.length;
        }

        function update() {
            if (paused) return;
            const dt = 1/60;

            for (const body of bodies) {
                body.update(dt);
            }

            // Body-body collisions
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const collision = satCollision(bodies[i], bodies[j]);
                    if (collision) {
                        resolveCollision(bodies[i], bodies[j], collision);
                    }
                }
            }

            // Remove bodies that fell too far
            bodies = bodies.filter(b => b.pos.y < canvas.height + 200);
            countSpan.textContent = bodies.length;
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ground
            ctx.fillStyle = '#1a1f3a';
            ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
            ctx.fillRect(0, 0, 10, canvas.height);
            ctx.fillRect(canvas.width - 10, 0, 10, canvas.height);

            for (const body of bodies) {
                body.draw(ctx);
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            spawnBox(e.clientX - rect.left, e.clientY - rect.top);
        });

        document.getElementById('rigidSpawnBox').addEventListener('click', () => {
            spawnBox(100 + Math.random() * 600, 50);
        });

        document.getElementById('rigidSpawnMany').addEventListener('click', () => {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => spawnBox(100 + Math.random() * 600, 50), i * 100);
            }
        });

        document.getElementById('rigidClear').addEventListener('click', () => {
            bodies = [];
            countSpan.textContent = 0;
        });

        document.getElementById('rigidPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });

        // Start with a few boxes
        for (let i = 0; i < 3; i++) {
            spawnBox(200 + i * 150, 100);
        }

        animate();
    })();

    // =====================================================
    // CLOTH SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('clothCanvas');
        const ctx = canvas.getContext('2d');

        let paused = false;
        let wind = false;
        let gravity = 500;
        let particles = [];
        let springs = [];
        let dragging = null;

        const cols = 25;
        const rows = 15;
        const spacing = 20;
        const startX = (canvas.width - (cols - 1) * spacing) / 2;
        const startY = 50;

        class ClothParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.oldX = x;
                this.oldY = y;
                this.pinned = false;
            }

            update(grav, damping, dt) {
                if (this.pinned) return;
                const vx = (this.x - this.oldX) * damping;
                const vy = (this.y - this.oldY) * damping;
                this.oldX = this.x;
                this.oldY = this.y;
                this.x += vx;
                this.y += vy + grav * dt * dt;
            }
        }

        class ClothSpring {
            constructor(p1, p2, type) {
                this.p1 = p1;
                this.p2 = p2;
                this.type = type;
                this.restLength = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                this.broken = false;
                this.stiffness = type === 'structural' ? 1.0 : type === 'shear' ? 0.7 : 0.3;
                this.tearThreshold = type === 'structural' ? 3.5 : type === 'shear' ? 4 : 5;
            }

            satisfy() {
                if (this.broken) return;
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const currentLength = Math.hypot(dx, dy);
                if (currentLength > this.restLength * this.tearThreshold) {
                    this.broken = true;
                    return;
                }
                if (currentLength < 0.0001) return;
                const diff = (currentLength - this.restLength) / currentLength;
                const moveX = dx * diff * 0.5 * this.stiffness;
                const moveY = dy * diff * 0.5 * this.stiffness;
                if (!this.p1.pinned) { this.p1.x += moveX; this.p1.y += moveY; }
                if (!this.p2.pinned) { this.p2.x -= moveX; this.p2.y -= moveY; }
            }
        }

        function init() {
            particles = [];
            springs = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const p = new ClothParticle(startX + x * spacing, startY + y * spacing);
                    if (y === 0 && (x === 0 || x === cols - 1 || x === Math.floor(cols / 2))) {
                        p.pinned = true;
                    }
                    particles.push(p);
                }
            }
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = y * cols + x;
                    if (x < cols - 1) springs.push(new ClothSpring(particles[i], particles[i + 1], 'structural'));
                    if (y < rows - 1) springs.push(new ClothSpring(particles[i], particles[i + cols], 'structural'));
                    if (x < cols - 1 && y < rows - 1) {
                        springs.push(new ClothSpring(particles[i], particles[i + cols + 1], 'shear'));
                        springs.push(new ClothSpring(particles[i + 1], particles[i + cols], 'shear'));
                    }
                    if (x < cols - 2) springs.push(new ClothSpring(particles[i], particles[i + 2], 'bend'));
                    if (y < rows - 2) springs.push(new ClothSpring(particles[i], particles[i + cols * 2], 'bend'));
                }
            }
        }

        function update() {
            if (paused) return;
            const dt = 1 / 60;
            for (const p of particles) {
                if (wind) {
                    const windForce = (Math.sin(Date.now() * 0.001) + 1) * 50;
                    p.x += windForce * dt * dt;
                }
                p.update(gravity, 0.98, dt);
            }
            for (let iter = 0; iter < 12; iter++) {
                for (const s of springs) s.satisfy();
            }
            for (const p of particles) {
                if (p.y > canvas.height - 10) { p.y = canvas.height - 10; p.oldY = p.y; }
                if (p.x < 10) { p.x = 10; p.oldX = p.x; }
                if (p.x > canvas.width - 10) { p.x = canvas.width - 10; p.oldX = p.x; }
            }
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (const s of springs) {
                if (s.broken) continue;
                ctx.beginPath();
                ctx.moveTo(s.p1.x, s.p1.y);
                ctx.lineTo(s.p2.x, s.p2.y);
                ctx.strokeStyle = s.type === 'structural' ? '#4fc3f7' : s.type === 'shear' ? '#66bb6a' : '#ffa726';
                ctx.lineWidth = s.type === 'structural' ? 2 : 1;
                ctx.globalAlpha = s.type === 'bend' ? 0.3 : 0.8;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            for (const p of particles) {
                ctx.fillStyle = p.pinned ? '#ff6b6b' : '#fff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.pinned ? 6 : 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            if (e.button === 2) {
                for (const p of particles) {
                    if (Math.hypot(mx - p.x, my - p.y) < 15) {
                        p.pinned = !p.pinned;
                        break;
                    }
                }
            } else {
                for (const p of particles) {
                    if (Math.hypot(mx - p.x, my - p.y) < 15) {
                        dragging = p;
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = canvas.getBoundingClientRect();
            dragging.x = e.clientX - rect.left;
            dragging.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', () => { dragging = null; });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('clothReset').addEventListener('click', init);
        document.getElementById('clothWind').addEventListener('click', function() {
            wind = !wind;
            this.classList.toggle('active', wind);
        });
        document.getElementById('clothGravity').addEventListener('click', function() {
            gravity = gravity === 500 ? 0 : 500;
            this.classList.toggle('active', gravity === 0);
        });
        document.getElementById('clothPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });

        init();
        animate();
    })();

    // =====================================================
    // SPH WATER SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('sphCanvas');
        const ctx = canvas.getContext('2d');
        const countSpan = document.getElementById('sphCount');

        let paused = false;
        let highViscosity = false;
        let particles = [];
        let pouring = false;

        const H = 20;
        const H2 = H * H;
        const MASS = 1;
        const REST_DENSITY = 1;
        const GAS_CONSTANT = 200;
        const VISCOSITY = 0.5;
        const GRAVITY = 300;

        const poly6Const = 315 / (64 * Math.PI * Math.pow(H, 9));
        const spikyConst = -45 / (Math.PI * Math.pow(H, 6));
        const viscConst = 45 / (Math.PI * Math.pow(H, 6));

        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }
            clear() { this.grid.clear(); }
            hash(x, y) { return `${Math.floor(x / this.cellSize)},${Math.floor(y / this.cellSize)}`; }
            insert(p) {
                const key = this.hash(p.x, p.y);
                if (!this.grid.has(key)) this.grid.set(key, []);
                this.grid.get(key).push(p);
            }
            getNeighbors(p) {
                const neighbors = [];
                const cx = Math.floor(p.x / this.cellSize);
                const cy = Math.floor(p.y / this.cellSize);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const cell = this.grid.get(`${cx + dx},${cy + dy}`);
                        if (cell) neighbors.push(...cell);
                    }
                }
                return neighbors;
            }
        }

        const spatialHash = new SpatialHash(H);

        class SPHParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = 0;
                this.fx = 0;
                this.fy = 0;
                this.density = 0;
                this.pressure = 0;
            }
        }

        function poly6(r2) {
            if (r2 >= H2) return 0;
            const diff = H2 - r2;
            return poly6Const * diff * diff * diff;
        }

        function spikyGrad(r, dx, dy) {
            if (r >= H || r < 0.0001) return { x: 0, y: 0 };
            const diff = H - r;
            const scale = spikyConst * diff * diff / r;
            return { x: scale * dx, y: scale * dy };
        }

        function viscLaplacian(r) {
            if (r >= H) return 0;
            return viscConst * (H - r);
        }

        function update() {
            if (paused) return;
            const dt = 1 / 60;
            const visc = highViscosity ? VISCOSITY * 5 : VISCOSITY;

            spatialHash.clear();
            for (const p of particles) spatialHash.insert(p);

            // Compute density and pressure
            for (const p of particles) {
                p.density = 0;
                const neighbors = spatialHash.getNeighbors(p);
                for (const n of neighbors) {
                    const r2 = (p.x - n.x) ** 2 + (p.y - n.y) ** 2;
                    p.density += MASS * poly6(r2);
                }
                p.density = Math.max(p.density, REST_DENSITY);
                p.pressure = GAS_CONSTANT * (p.density - REST_DENSITY);
            }

            // Compute forces
            for (const p of particles) {
                p.fx = 0;
                p.fy = GRAVITY * p.density;
                const neighbors = spatialHash.getNeighbors(p);
                for (const n of neighbors) {
                    if (n === p) continue;
                    const dx = n.x - p.x;
                    const dy = n.y - p.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    if (r < H && r > 0.0001) {
                        const pressureForce = -(p.pressure + n.pressure) / (2 * n.density);
                        const grad = spikyGrad(r, dx, dy);
                        p.fx += pressureForce * grad.x * MASS;
                        p.fy += pressureForce * grad.y * MASS;
                        const viscForce = visc * viscLaplacian(r) / n.density;
                        p.fx += viscForce * (n.vx - p.vx) * MASS;
                        p.fy += viscForce * (n.vy - p.vy) * MASS;
                    }
                }
            }

            // Integrate
            for (const p of particles) {
                p.vx += p.fx / p.density * dt;
                p.vy += p.fy / p.density * dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Boundaries
                if (p.x < 10) { p.x = 10; p.vx *= -0.5; }
                if (p.x > canvas.width - 10) { p.x = canvas.width - 10; p.vx *= -0.5; }
                if (p.y < 10) { p.y = 10; p.vy *= -0.5; }
                if (p.y > canvas.height - 10) { p.y = canvas.height - 10; p.vy *= -0.5; }
            }
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles
            for (const p of particles) {
                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                const hue = 200 - Math.min(speed, 100);
                ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            countSpan.textContent = particles.length;
        }

        function animate() {
            if (pouring && particles.length < 500) {
                for (let i = 0; i < 3; i++) {
                    particles.push(new SPHParticle(200 + Math.random() * 50, 50 + Math.random() * 20));
                }
            }
            update();
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            if (particles.length >= 500) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            for (let i = 0; i < 10; i++) {
                particles.push(new SPHParticle(mx + (Math.random() - 0.5) * 30, my + (Math.random() - 0.5) * 30));
            }
        });

        document.getElementById('sphPour').addEventListener('click', function() {
            pouring = !pouring;
            this.classList.toggle('active', pouring);
        });
        document.getElementById('sphReset').addEventListener('click', () => { particles = []; });
        document.getElementById('sphPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('sphViscosity').addEventListener('click', function() {
            highViscosity = !highViscosity;
            this.classList.toggle('active', highViscosity);
        });

        animate();
    })();

    // =====================================================
    // PERLIN WIND FIELD SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('windCanvas');
        const ctx = canvas.getContext('2d');

        let paused = false;
        let showField = false;
        let useOctaves = true;
        let particles = [];
        let time = 0;

        class PerlinNoise {
            constructor() {
                this.perm = new Array(512);
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                for (let i = 0; i < 512; i++) this.perm[i] = p[i & 255];
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }
            noise(x, y, z = 0) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = this.fade(x), v = this.fade(y), w = this.fade(z);
                const A = this.perm[X] + Y, AA = this.perm[A] + Z, AB = this.perm[A + 1] + Z;
                const B = this.perm[X + 1] + Y, BA = this.perm[B] + Z, BB = this.perm[B + 1] + Z;
                return this.lerp(
                    this.lerp(this.lerp(this.grad(this.perm[AA], x, y, z), this.grad(this.perm[BA], x-1, y, z), u),
                              this.lerp(this.grad(this.perm[AB], x, y-1, z), this.grad(this.perm[BB], x-1, y-1, z), u), v),
                    this.lerp(this.lerp(this.grad(this.perm[AA+1], x, y, z-1), this.grad(this.perm[BA+1], x-1, y, z-1), u),
                              this.lerp(this.grad(this.perm[AB+1], x, y-1, z-1), this.grad(this.perm[BB+1], x-1, y-1, z-1), u), v), w);
            }
        }

        const perlin = new PerlinNoise();

        function getCurlNoise(x, y, t, scale) {
            const eps = 1;
            const n = perlin.noise(x * scale, (y - eps) * scale, t);
            const s = perlin.noise(x * scale, (y + eps) * scale, t);
            const e = perlin.noise((x + eps) * scale, y * scale, t);
            const w = perlin.noise((x - eps) * scale, y * scale, t);
            return { x: (n - s) / (2 * eps), y: -(e - w) / (2 * eps) };
        }

        function getWind(x, y, t) {
            const turbulence = parseFloat(document.getElementById('windTurbulence').value) / 100;
            if (!useOctaves) return getCurlNoise(x, y, t, turbulence);

            let wind = { x: 0, y: 0 };
            let amp = 1, freq = 1, maxAmp = 0;
            for (let i = 0; i < 4; i++) {
                const curl = getCurlNoise(x * freq, y * freq, t * freq, turbulence);
                wind.x += curl.x * amp;
                wind.y += curl.y * amp;
                maxAmp += amp;
                amp *= 0.5;
                freq *= 2;
            }
            wind.x /= maxAmp;
            wind.y /= maxAmp;
            return wind;
        }

        class WindParticle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.life = 100 + Math.random() * 200;
                this.maxLife = this.life;
                this.history = [];
            }
            update(t) {
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > 15) this.history.shift();

                const wind = getWind(this.x, this.y, t);
                const strength = 3;
                this.x += wind.x * strength;
                this.y += wind.y * strength;
                this.life--;

                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;

                if (this.life <= 0) this.reset();
            }
            draw(ctx) {
                const alpha = this.life / this.maxLife;
                if (this.history.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (const p of this.history) ctx.lineTo(p.x, p.y);
                    ctx.lineTo(this.x, this.y);
                    ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function init() {
            particles = [];
            for (let i = 0; i < 500; i++) particles.push(new WindParticle());
        }

        function drawVectorField(t) {
            const spacing = 30;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let x = spacing; x < canvas.width; x += spacing) {
                for (let y = spacing; y < canvas.height; y += spacing) {
                    const wind = getWind(x, y, t);
                    const len = 15;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + wind.x * len, y + wind.y * len);
                    ctx.stroke();
                }
            }
        }

        function update() {
            if (paused) return;
            const timeScale = parseFloat(document.getElementById('windTimeScale').value) / 1000;
            time += timeScale;
            for (const p of particles) p.update(time);
        }

        function draw() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (showField) drawVectorField(time);
            for (const p of particles) p.draw(ctx);
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        document.getElementById('windReset').addEventListener('click', init);
        document.getElementById('windPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('windShowField').addEventListener('click', function() {
            showField = !showField;
            this.classList.toggle('active', showField);
        });
        document.getElementById('windOctaves').addEventListener('click', function() {
            useOctaves = !useOctaves;
            this.classList.toggle('active', useOctaves);
        });

        init();
        animate();
    })();

    // =====================================================
    // HEAT DIFFUSION SIMULATION
    // =====================================================
    (function() {
        const canvas = document.getElementById('heatCanvas');
        const ctx = canvas.getContext('2d');
        const maxTempSpan = document.getElementById('heatMaxTemp');
        const materialNameSpan = document.getElementById('heatMaterialName');

        let paused = false;
        let useConvection = true;
        let paintMaterial = 0;
        let isMouseDown = false;

        const cellSize = 8;
        const cols = Math.floor(canvas.width / cellSize);
        const rows = Math.floor(canvas.height / cellSize);

        const materials = {
            0: { name: 'Air', diffusivity: 0.4, emissivity: 0.05, color: '#1a1f3a' },
            1: { name: 'Metal', diffusivity: 0.8, emissivity: 0.01, color: '#607d8b' },
            2: { name: 'Wood', diffusivity: 0.08, emissivity: 0.2, color: '#8d6e63' }
        };

        let temp = [], tempNew = [], material = [];
        const ambientTemp = 20;

        function init() {
            temp = []; tempNew = []; material = [];
            for (let y = 0; y < rows; y++) {
                temp[y] = new Array(cols).fill(ambientTemp);
                tempNew[y] = new Array(cols).fill(ambientTemp);
                material[y] = new Array(cols).fill(0);
            }
            // Add some metal blocks
            for (let y = 15; y < 25; y++) {
                for (let x = 20; x < 40; x++) material[y][x] = 1;
            }
            // Add some wood
            for (let y = 35; y < 50; y++) {
                for (let x = 60; x < 80; x++) material[y][x] = 2;
            }
        }

        function tempToColor(t) {
            const normalized = Math.max(0, Math.min(1, (t - ambientTemp) / 400));
            if (normalized < 0.25) {
                const f = normalized / 0.25;
                return `rgb(${Math.floor(50 + 50*f)}, ${Math.floor(50 + 50*f)}, ${Math.floor(100 + 155*f)})`;
            } else if (normalized < 0.5) {
                const f = (normalized - 0.25) / 0.25;
                return `rgb(${Math.floor(100 + 155*f)}, ${Math.floor(100 + 155*f)}, 255)`;
            } else if (normalized < 0.75) {
                const f = (normalized - 0.5) / 0.25;
                return `rgb(255, ${Math.floor(255 - 55*f)}, ${Math.floor(255 - 255*f)})`;
            } else {
                const f = (normalized - 0.75) / 0.25;
                return `rgb(255, ${Math.floor(200 - 150*f)}, 0)`;
            }
        }

        function update() {
            if (paused) return;
            const dt = 0.1;

            for (let y = 1; y < rows - 1; y++) {
                for (let x = 1; x < cols - 1; x++) {
                    const mat = materials[material[y][x]];
                    const laplacian = temp[y-1][x] + temp[y+1][x] + temp[y][x-1] + temp[y][x+1] - 4 * temp[y][x];
                    let newT = temp[y][x] + mat.diffusivity * laplacian * dt;

                    if (useConvection && material[y][x] === 0 && y > 0) {
                        const heatBelow = y < rows - 1 ? temp[y + 1][x] : temp[y][x];
                        if (heatBelow > temp[y][x]) {
                            newT += (heatBelow - temp[y][x]) * 0.15 * dt;
                        }
                    }

                    const excess = newT - ambientTemp;
                    if (excess > 0) newT -= excess * mat.emissivity * dt * 0.05;

                    tempNew[y][x] = Math.max(ambientTemp, Math.min(600, newT));
                }
            }
            [temp, tempNew] = [tempNew, temp];
        }

        function draw() {
            let maxT = ambientTemp;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const t = temp[y][x];
                    const mat = material[y][x];
                    if (t > maxT) maxT = t;

                    if (t > ambientTemp + 5) {
                        ctx.fillStyle = tempToColor(t);
                    } else {
                        ctx.fillStyle = materials[mat].color;
                    }
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
            maxTempSpan.textContent = Math.floor(maxT);
        }

        function addHeat(mx, my, amount) {
            const cx = Math.floor(mx / cellSize);
            const cy = Math.floor(my / cellSize);
            const radius = 3;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist <= radius) {
                            temp[ny][nx] += amount * (1 - dist / radius);
                        }
                    }
                }
            }
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            addHeat(e.clientX - rect.left, e.clientY - rect.top, 150);
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            const rect = canvas.getBoundingClientRect();
            addHeat(e.clientX - rect.left, e.clientY - rect.top, 50);
        });
        canvas.addEventListener('mouseup', () => { isMouseDown = false; });
        canvas.addEventListener('mouseleave', () => { isMouseDown = false; });

        document.getElementById('heatReset').addEventListener('click', init);
        document.getElementById('heatPause').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('heatMaterial').addEventListener('click', function() {
            paintMaterial = (paintMaterial + 1) % 3;
            materialNameSpan.textContent = materials[paintMaterial].name;
        });
        document.getElementById('heatConvection').addEventListener('click', function() {
            useConvection = !useConvection;
            this.classList.toggle('active', !useConvection);
        });

        init();
        animate();
    })();

    // Scroll to top
    const scrollToTopBtn = document.getElementById('scrollToTop');
    scrollToTopBtn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    });
    window.addEventListener('scroll', () => {
        scrollToTopBtn.style.opacity = window.pageYOffset > 300 ? '1' : '0';
    });
    scrollToTopBtn.style.opacity = '0';
    scrollToTopBtn.style.transition = 'opacity 0.3s';
    </script>

    <!-- Export Demo System -->
    <script src="shared/dependency-bundles.js"></script>
    <script src="shared/demo-bundles.js"></script>
    <script src="shared/export-demo.js"></script>
</body>
</html>
